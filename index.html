<!DOCTYPE html>
<html lang="en">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="蔡胖子" />


    
    


<meta name="description" content="我每天都好困">
<meta property="og:type" content="website">
<meta property="og:title" content="蔡胖子">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="蔡胖子">
<meta property="og:description" content="我每天都好困">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="蔡胖子">
<meta name="twitter:card" content="summary">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="蔡胖子" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">



    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>蔡胖子</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/caicai.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:2195361512@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="/psh193" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" href="/qq_52464789" title="CSDN"></a>
                            
                                <a class="fa QQ" href="/2195361512" title="QQ"></a>
                            
                                <a class="fa 微信" href="/pshlpjswaxx" title="微信"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/caicai.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:2195361512@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="/psh193" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="/qq_52464789" title="CSDN"></a>
                            
                                <a class="fa QQ" target="_blank" href="/2195361512" title="QQ"></a>
                            
                                <a class="fa 微信" target="_blank" href="/pshlpjswaxx" title="微信"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-数据结构阶段_1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/" class="article-date">
      <time datetime="2023-02-02T14:33:55.000Z" itemprop="datePublished">2023-02-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/">数据结构笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>[TOC]</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>：为了解决问题，代码的总执行次数</p>
<p>运算：</p>
<blockquote>
<p>1.舍弃掉计算结果中的常数项</p>
<p>2.多项式级别的运算，只保留最大项</p>
<p>3.如果当前的算法在</p>
<p>的资源消耗内即可完成。复杂度为O(1)</p>
</blockquote>
<h4 id="经验性结论："><a href="#经验性结论：" class="headerlink" title="经验性结论："></a>经验性结论：</h4><blockquote>
<p>1.单纯的顺序结构或选择结构，时间复杂度都是O(1)</p>
<p>2.一个简单的循环结构一般情况下时间复杂度是O(n)</p>
<p>3.一般情况下，两层 循环嵌套，时间复杂度是O(n^2)</p>
<p>4.采用二分的分治法，时间复杂度是log2(n)</p>
<p>5.会采用分治、递归、动态规划等算法用空间换取时间效率</p>
<p>6.两个顺序执行的循环，时间消耗取二者里的大值O(max(m,n))</p>
</blockquote>
<p>简单的循环结构的特殊情况下：</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658213184731.png" alt="1658213184731"></p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>：为了解决问题额外消耗的空间</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658212623728.png" alt="1658212623728"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658214129313.png" alt="1658214129313"></p>
<p>结构</p>
<h4 id="线性结构："><a href="#线性结构：" class="headerlink" title="线性结构："></a>线性结构：</h4><p>一对一结构</p>
<p>链式存储（链表）：</p>
<p>顺序存储（数组）：</p>
<h5 id="数组：空间连续，类型相同"><a href="#数组：空间连续，类型相同" class="headerlink" title="数组：空间连续，类型相同"></a>数组：空间连续，类型相同</h5><blockquote>
<p>1.基于索引的查询速度快，O(1)</p>
<p>2.对无序数组的数值搜索，O(n)</p>
<p>3.对于有序数组的数值搜索，O(log2(n))</p>
<p>4.在数组空间足够的前提下：</p>
<p>尾添加：O(1)    尾删除：O(1)</p>
<p>头添加、头删除、中间添加、中间删除，O(n)</p>
<p>空间不够：</p>
<p>添加：添加元素需要进行空间申请，及原有数据的拷贝，O(n)</p>
<p>删除：尾删除O(1)，中间删除、头删除：O(n)</p>
</blockquote>
<p>对一个地址进行加减就是偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">*(&amp;a + 1) = ? //得到的是乱码</span><br><span class="line">//&amp;a得到的是整个数组的地址，虽然整个数组的首地址跟首元素的首地址值是一样的，但是表达的意义是不一样的</span><br><span class="line">//对地址进行加减是对地址进行偏移量</span><br><span class="line">//所以&amp;a + 1就是偏移一个数组这么大，指针取不到，因为已经超过了数组的范围，所以得到的是乱码</span><br></pre></td></tr></table></figure>

<p>例题：一个有n个元素的数组，每个元素的值范围在0~n-1之间。检测数据是否重复出现，若重复出现，则当前组数据时坏数据</p>
<h5 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h5><blockquote>
<p>1.存储方式：数组时顺序存储，链表是链式存储</p>
<p>2.内存分配方式：数组静态分配，链表动态分配</p>
<p>3.存取方式：数组元素直接存取，链表元素要遍历链表</p>
<p>4.插入和删除方式：数组需要移动组内元素，链表不需要移动</p>
</blockquote>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><blockquote>
<p>1.链表搜索，O(n)</p>
<p>2.链表添加：</p>
<p>头添加、头删除：O(1)，数据按照添加顺序倒序</p>
<p>中间添加、删除、尾添加、尾删除：O(n)</p>
<p>ps：最常用的是尾添加，头添加会出现逆序的情况</p>
</blockquote>
<h5 id="单链表倒置："><a href="#单链表倒置：" class="headerlink" title="单链表倒置："></a>单链表倒置：</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658815809784.png" alt="1658815809784"></p>
<blockquote>
<p>1.头插法：建立三个指针，用指针1指向空，指针2和3分别指向A和B，断开A和B之间的指针，   让B指向A，然后将三个指针分别向后移动一位。时间复杂度O(n),空间复杂度O(1)</p>
<p>2.栈：入栈再出栈。时间复杂度：O(n),空间复杂度O(n)</p>
<p>3.暴力解法：遍历链表找到E，再遍历链表找到D,让E指向D，依次遍历。时间复杂度：O(n^2),空间复杂度O(1)</p>
</blockquote>
<h5 id="链表重置："><a href="#链表重置：" class="headerlink" title="链表重置："></a>链表重置：</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658815907537.png" alt="1658815907537"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//分三个步骤</span><br><span class="line">//1.找到链表的中间结点</span><br><span class="line">//2.由中间结点为分隔点，将后半链表倒置</span><br><span class="line">//3.在第一条链表的基础上，在每一个结点的后面都插入第二条链表的一个结点</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658821706891.png" alt="1658821706891"></p>
<blockquote>
<p>1.head tail</p>
<p>2.处理</p>
<p>（1）比较L1，L2</p>
<p>（2）小的尾添加到newlist</p>
<p>（3）继续（1）（2）</p>
<p>（4）将有剩余的list添加到newList</p>
</blockquote>
<h5 id="单链表相交问题"><a href="#单链表相交问题" class="headerlink" title="单链表相交问题"></a>单链表相交问题</h5><p>方法：</p>
<blockquote>
<p>1.判断末尾结点是否相同</p>
<p>2.将两条链表入栈，判断出栈结点是否相同，当出栈结点不同时，那么下一个出栈的结点就是交点</p>
<p>3.数学方法：遍历，让长的那条链表先走完两条链表长度的差值，然后一起走同时比较</p>
</blockquote>
<h5 id="循环链表的特性"><a href="#循环链表的特性" class="headerlink" title="循环链表的特性"></a>循环链表的特性</h5><blockquote>
<p>从环上任意一点出发均能遍历整个链表</p>
</blockquote>
<h5 id="判断单链表是否有环，如果有环的话，找到环的入口节点"><a href="#判断单链表是否有环，如果有环的话，找到环的入口节点" class="headerlink" title="判断单链表是否有环，如果有环的话，找到环的入口节点"></a>判断单链表是否有环，如果有环的话，找到环的入口节点</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668600031375.png" alt="1668600031375"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668600976682.png" alt="1668600976682"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668601548436.png" alt="1668601548436"></p>
<blockquote>
<p>快慢指针，慢指针一次走一步，快指针一次走两步，快慢指针一定会在环上相遇</p>
<p>（1）断开：在快慢指针相遇的结点断开，就变成了单链表找相交结点问题</p>
<p>（2）倍数：假设两个指针在c点相遇，那么满指针走了a+b，快指针走了a+b+k(b+c)（假设快指针在还上走了k圈），两者相等得出a&#x3D;c+(k-1)(b+c)，让慢指针回到头结点，此时快慢指针都走一步，走c那么长，此时快指针走到B点也就是入口节点，二者继续走相遇的点就是入口结点</p>
<p>（3）环长：两个指针在环上相遇，一个指针不动，让另一个指针在环上走一圈记录长度就是环长x，然后两个指针回到起始结点，二号指针先走x步，两个指针再一起走，相遇的点就是入口结点</p>
</blockquote>
<h5 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h5><blockquote>
<p>1.在原结点后面复制一个新的结点</p>
<p>2.复制结点的随机指针指向原结点随机指针的下一个</p>
<p>3.分离原结点和复制后的结点链表</p>
</blockquote>
<h4 id="哈希表HashTable"><a href="#哈希表HashTable" class="headerlink" title="哈希表HashTable"></a>哈希表HashTable</h4><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668770833339.png" alt="1668770833339"></p>
<blockquote>
<p>1.定散列函数：</p>
<p>求整取余&#x2F;留存取余：P &#x3D; key % M。将数据通过取余分成不同的组用数组存起来，此时数组是指针数组</p>
<p>2.定解决哈希冲突的办法</p>
<p>开放地址法：（1）线性探测：发生冲突后依次查看当前地址后面有没有空位，有空位则将冲突元素放在空位</p>
<p>​						（2）二次探测：以一个不断变化的步长寻找有没有空位</p>
<p>拉链法：发生冲突的组内元素用链表连接起来，并将单链表的头结点存到对应的单元中</p>
</blockquote>
<p>哈希表的创建</p>
<blockquote>
<p>1.定义结构体：数据，next</p>
<p>2.定义结构体类型指针数组，将数组赋空值</p>
<p>3.当前数据取余m值，将当前数据添加到对应组中去（头插）</p>
</blockquote>
<p>哈希表的弊端</p>
<blockquote>
<p>1.空间消耗大</p>
<p>2.需要一次把所有数据都加载进来</p>
</blockquote>
<h4 id="回溯法（BackTracking）"><a href="#回溯法（BackTracking）" class="headerlink" title="回溯法（BackTracking）"></a>回溯法（BackTracking）</h4><p>回溯法，又叫试探法，是一种寻找<strong>最优解</strong>的<strong>暴力搜寻法。</strong>但是，由于暴力，回溯法的**时*间复杂度较高***，因此在比较一些数字较大的问题时，比如最短路径问题等，运行时间一般比较长。 </p>
<p>在1、2、3、4中找到长度为2的集合，可以以1或2或3为开头</p>
<p>以1位开头，待选为2、3、4，首先选择2，组成集合【1，2】，符合要求，然后放弃2，再选择3，组成【1,3】，符合要求，然后放弃3，再选择4，组成【1,4】，符合要求，然后放弃4。</p>
<p>以1为开头的选择已经耗尽，然后放弃1，选择2，待选为3、4。。。。这样循环下去</p>
<p>回溯法纵向是一个递归的过程，横向是一个循环的过程</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671346305079.png" alt="1671346305079"></p>
<h5 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h5><blockquote>
<p>1.组合问题（无序）</p>
<p>2.分割问题（字符串分割成子串）</p>
<p>3.子集问题（求一个数组的全部子集）</p>
<p>4.排列问题（有序）</p>
<p>5.棋盘问题、迷宫问题</p>
</blockquote>
<h5 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">用传出参数或全局变量收集结果，而不是用返回值</span><br><span class="line">//一定要分成横纵两个方面思考回溯</span><br><span class="line">void backtracking(参数) &#123;//根据数据的不同选择的参数类型也不同</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;//注意i=0,i=start的区别</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归  注意(i)和(i++)的区别  后面会懂</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h5><p>1.得到所有排列（需要存储空间存储结果）</p>
<p>2.打印所有排列</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674543867540.png" alt="1674543867540"></p>
<p>如果需要保存结果第一步需要申请空间保存</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671351850651.png" alt="1671351850651"></p>
<p>交换法&#x2F;标记法</p>
<p>交换法：从集合中选择一个元素，剩下的元素进行全排列；选择的元素与第一个元素进行交换，得到所有全排列后要还原，回到原始状态</p>
<p>标记法：需要开辟一个新空间，将选择的元素标记存入新空间，接下来从未标记的元素中进行选择，得到排列结果后要撤销标记</p>
<h5 id="全排列代码"><a href="#全排列代码" class="headerlink" title="全排列代码"></a>全排列代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> 1#include&lt;stdio.h&gt;</span><br><span class="line"> 2 </span><br><span class="line"> 3 void Arrange(int arr[],int nLen,int start)</span><br><span class="line"> 4 &#123;</span><br><span class="line"> 5     if(start == nLen)</span><br><span class="line"> 6     &#123;</span><br><span class="line"> 7         int i;</span><br><span class="line"> 8         for(i=0; i&lt;nLen; i++)</span><br><span class="line"> 9         &#123;</span><br><span class="line">10             printf(&quot;%d&quot;,arr[i]);</span><br><span class="line">11         &#125;</span><br><span class="line">12         printf(&quot;\n&quot;);</span><br><span class="line">13         return ;</span><br><span class="line">14     &#125;</span><br><span class="line">15 </span><br><span class="line">16     int i;</span><br><span class="line">17     int temp;</span><br><span class="line">18     for(i=start; i&lt;nLen; i++)</span><br><span class="line">19     &#123;</span><br><span class="line">20         temp = arr[i];</span><br><span class="line">21         arr[i] = arr[start];</span><br><span class="line">22         arr[start] = temp;</span><br><span class="line">23                                                                                                                                                                                   </span><br><span class="line">24         Arrange(arr,nLen,start+1);</span><br><span class="line">25 </span><br><span class="line">26         temp = arr[i];</span><br><span class="line">27         arr[i] = arr[start];</span><br><span class="line">28         arr[start] = temp;</span><br><span class="line">29     &#125;</span><br><span class="line">30 &#125;</span><br><span class="line">31 </span><br><span class="line">32 int main()</span><br><span class="line">33 &#123;</span><br><span class="line">34     int arr[] = &#123;1,2,3&#125;;</span><br><span class="line">35     Arrange(arr,3,0);</span><br><span class="line">36     return 0;</span><br><span class="line">37 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h4><p>题目描述：</p>
<p> 请实现一个函数用来匹配包括’.‘和’<em>‘的正则表达式。模式中的字符’.‘表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。 例如：模式串“aab”,匹配串<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674559930857.png" alt="1674559930857"></p>
<p>解题思路：</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674561559858.png" alt="1674561559858"></p>
<p>首先我们应从模式字符串里进行匹配，并看下一位是否含有*，如果有的话：</p>
<p>判断对应位置的字符是否相等，如果不相等，则模式字符串移动两位（消去），继续匹配<br>如果相等（出现.也算相等)，则可以消去模式字符，也可以不消去，继续递归向后匹配，此处用到回溯（如果*前是0次，则模式串不动，匹配串向后移动两位；如果星号前是1次，则模式串向后移动一位，匹配串向后移动两位；如果星号前是多次，则模式串++，匹配串不动）</p>
<p>如果没有的话两个字符串位置对照进行比较:</p>
<p>如果不相等则匹配不成功（模式字符串里有.算做相等的情况）</p>
<p>如果相等则模式串和匹配串都向后移一位</p>
<h4 id="跳跃列表：SkipList"><a href="#跳跃列表：SkipList" class="headerlink" title="跳跃列表：SkipList"></a>跳跃列表：SkipList</h4><p>基于有序链表：</p>
<p>log2n（增删查）</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669030359455.png" alt="1669030359455"></p>
<p>跳跃列表插入</p>
<blockquote>
<p>1.申请空间表格（指针数组），保存插入数据各层的前一个节点是什么，列表有几层就申请相应层数的空间</p>
<p>2.找到对应插入数据的每层前一个元素是什么并填入表格</p>
<p>3.随机判断每层节点是否存在，如果L1层存在再判断L2是否存在，如果L1层不存在，L2层就不做处理了</p>
<p>4.将生成的节点放入列表中，完成每层节点的连接</p>
</blockquote>
<h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>当前问题能拆解成更小的子问题，子问题除数据规模以外，解决问题的方法与当前问题完全相同，并有明确的终止条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//函数返回值 名字（参数）</span><br><span class="line">//&#123;</span><br><span class="line">	//终点</span><br><span class="line">	//递归主体</span><br><span class="line">//&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h5><p>题意说明<br>一只青蛙可以一次跳 1 级台阶或一次跳 2 级台阶,例如:跳上第一级台阶只有一种跳法:直接跳 1 级即可。跳上两级台阶,有两种跳法: 每次跳 1 级,跳两次; 或者一次跳 2 级.问要跳上第 n 级台阶有多少种跳法?</p>
<p>解题思路<br>我们设台阶数位N;<br>当N&#x3D;1时，当然只有1种跳法；<br>当N&#x3D;2时，青蛙可以跳2次1层和跳1次2层；<br>当N&#x3D;3时，当有3层台阶时，青蛙可以选择先跳1层，剩下2层台阶，所以此时就是有2层台阶时的跳法，有2种；当青蛙选择第一次跳2层台阶时，剩下1层台阶，此时有1层台阶时的跳法，所以3层台阶时的方法是：2层台阶的方法 + 1层台阶的方法。<br>当N&#x3D;4时，具体跳法为: 1、先跳1层 若先跳1层，则剩下3层，接下来就是3层台阶的跳法。 2、先跳2层 若先跳2层，则剩下2层，接下俩就是2层台阶的跳法，所以4层台阶的方法为：3层台阶的方法+2层台阶的方法。</p>
<p>以此类推，当N&#x3D;n时，n层台阶的方法为: n-1层台阶的方法+ n-2 层台阶的方法。</p>
<p>青蛙跳台阶问题：n级台阶第一步跳一节，还剩n-1阶，第一步跳两节还剩n-2阶</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668169187719.png" alt="1668169187719"></p>
<h5 id="斐波那契递归写法："><a href="#斐波那契递归写法：" class="headerlink" title="斐波那契递归写法："></a>斐波那契递归写法：</h5><p>当n超过50时计算时间非常长</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668165014035.png" alt="1668165014035">原因是每个点展开都是一次函数调用，将要调用2的50次方-1的函数，时间消耗大</p>
<p>斐波那契循环写法：</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668165498658.png" alt="1668165498658"></p>
<p>需要三个变量，从3开始算，上一次f(i-1)的值就是下一次f(i-2)的值，上一次f(i)的值就是下一次f(i-1)的值</p>
<p>斐波那契数学方法：</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668168217604.png" alt="1668168217604"></p>
<h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><blockquote>
<p>1.问题难度随着数据规模缩小而降低（降低）</p>
<p>2.当前问题可拆分成多个解决方法完全相同的小问题（可拆分）</p>
<p>3.子问题的解可合并（可合并）</p>
<p>4.子问题的解相互独立（独立）</p>
</blockquote>
<h5 id="二分查找（折半查找）Binary-Chop：前提：对有序数组进行查找"><a href="#二分查找（折半查找）Binary-Chop：前提：对有序数组进行查找" class="headerlink" title="二分查找（折半查找）Binary Chop：前提：对有序数组进行查找"></a>二分查找（折半查找）Binary Chop：前提：对有序数组进行查找</h5><blockquote>
<p>1.找到中间结点</p>
<p>2.比较</p>
<p>（1）&#x3D;&#x3D;成功返回</p>
<p>（2）Mid &lt; target（右半部分）</p>
<p>（3）Mid &gt; target（左半部分）</p>
</blockquote>
<p>栈（stack）：</p>
<p>堆：需要new获得当前放的什么内容，由程序员决定</p>
<p>字符常量</p>
<p>全局&#x2F;静态：都在一个区域</p>
<p>区别</p>
<blockquote>
<p>1.全局变量可以跨文件引用，静态变量只能局部引用</p>
<p>2.默认初始化为0</p>
<p>3.静态变量赋初值只会执行一次，会在其作用域内保存其值</p>
</blockquote>
<p>代码</p>
<p>堆和栈的区别：</p>
<blockquote>
<ol>
<li></li>
</ol>
<p>2.生命周期不一样</p>
<p>3.生长方向不一样，栈区从高地址向低地址分配</p>
<p>4.堆区不连续，栈区连续，堆区通过链表存放，每查找一个数据需要遍历一遍，效率低</p>
<p>5.只有堆区会产生内部碎片</p>
</blockquote>
<p>例题：如何将n个有序链表合并成一个有序的</p>
<h4 id="栈（stack）：（数据结构栈）FIFO"><a href="#栈（stack）：（数据结构栈）FIFO" class="headerlink" title="栈（stack）：（数据结构栈）FIFO"></a>栈（stack）：（数据结构栈）FIFO</h4><p>push</p>
<blockquote>
<p>1.new下一个新top</p>
<p>2.新Top指向原Top</p>
</blockquote>
<p>pop</p>
<blockquote>
<p>1.原Top &#x3D; 原Top的下一个</p>
<p>2.将原top拿走</p>
</blockquote>
<p>定义：先进后出</p>
<h4 id="队列（FIFO）"><a href="#队列（FIFO）" class="headerlink" title="队列（FIFO）"></a>队列（FIFO）</h4><h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><p>两个栈实现队列（先进先出，push、pop）</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669373013840.png" alt="1669373013840"></p>
<blockquote>
<p>1.s1入栈，s2出栈</p>
<p>2.push：s2非空，将s2中的数据移至s1，再将数据入栈s1</p>
<p>3.pop：如果s2中存在要pop的数据，直接从s2pop，如果数据不在s2中，将s1中数据移至s2，从s2pop</p>
</blockquote>
<p>两个队列实现栈（先进先出，Push、Pop）</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669376074829.png" alt="1669376074829"><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669376074912.png" alt="1669376074912"></p>
<blockquote>
<p>1.Push：将新来的数据放到非空队列中</p>
<p>2.Pop：找到非空队列，将非空队列中的处尾元素以外的所有数据放到另一个队列中，然后弹出尾元素</p>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669378935451.png" alt="1669378935451"></p>
<p>s1和s2的区别</p>
<blockquote>
<p>1.s1-&gt;字符常量区-&gt;只读，s2-&gt;栈区-&gt;可读可写</p>
<p>2.*s1不能被赋值，因为在字符常量区，只读不可写</p>
<p>*s2能被赋值，可以修改</p>
<p>3.s1是指针，可以做左值，被赋值</p>
<p>s2是数组，不可以作为左值，不鞥能被赋值</p>
<p>4.s1是指针，指向的字符串第一个字符的地址，所以sizeof(s1) &#x3D; 4</p>
<p>sizeof(s2) &#x3D; 6（字符串长度为5.末尾还有个换行符\0）</p>
</blockquote>
<p>s1和s2相同点</p>
<blockquote>
<p>1.strlen &#x3D; 5</p>
<p>2.作为形参使用时完全相同</p>
</blockquote>
<h5 id="字符串空格替换"><a href="#字符串空格替换" class="headerlink" title="字符串空格替换"></a>字符串空格替换</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669631235050.png" alt="1669631235050"></p>
<p>方法</p>
<blockquote>
<p>1.遍历，遇到空格替换成123，需要额外的空间</p>
<p>2.先拆分，后拼接，需要额外的空间</p>
<p>3.后-&gt;前</p>
<p>数组扩充到空格数量的一定倍数，然后定义i,J分别指向新旧数组尾，然后逆遍历判断，不是空格就赋值，是空格的话就在数组后面插入123</p>
</blockquote>
<h5 id="字符串倒置"><a href="#字符串倒置" class="headerlink" title="字符串倒置"></a>字符串倒置</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669632962420.png" alt="1669632962420"></p>
<blockquote>
<p>1.拆成串，单词倒置</p>
<p>2.整个reverse，再将单词reverse</p>
<p>3.在空格处拆分字符串，重新拼接</p>
</blockquote>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669633762419.png" alt="1669633762419"></p>
<blockquote>
<p>1.reverse： 先整个翻转，然后再以e和f分为两部分单独翻转</p>
<p>2.queue： 从倒数第k个开始进队列，到字符串结束再从首位置开始进队列，完整进一遍队列，出队</p>
</blockquote>
<h5 id="寻找字符"><a href="#寻找字符" class="headerlink" title="寻找字符"></a>寻找字符</h5><p>在字符串中找第一个只出现一次的字符</p>
<blockquote>
<p>1.暴力：每个字符都跟后序的字符比较，如果不相同就是第一次只出现一次的字符</p>
<p>2.哈希</p>
</blockquote>
<h5 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669720112896.png" alt="1669720112896"></p>
<p>next数组记录主串子串匹配的最大长度</p>
<p>next:每个字符与前面字符比较，a前面无字符与之匹配，所以next值是0，b前面以为next值是0，所以要和第一位比较，不相同，所以b的next值也是0，c同理，第四位a前面的next值是0，所以与第一位相比较，相同所以next值是1，第五位b前面next值是1，所以与标志位为1的字符相比较，也就是第二个字符，相同，则next值是2，同理第六位c，第七位d前面的next值是3，所以要与第四位字符相比较，不相同，但是因为前面字符没有比较过，所以假设b在第四位，第四位前面的next值是0，所以重新与第一位比较，不相同，则为0,。。。</p>
<p>kmp：主串不回退，匹配串回溯</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669720990171.png" alt="1669720990171"></p>
<p>匹配：两个指针分别指向两个串的第一位，字符相同则向后走，字符不相同时，子串的指针回退到前一位next值的标志位，如果还不相同则继续回退，如果子串指针已经回退下标位为0的位置还不相同，则主串向后走一位，继续重新匹配，如果主串指针走到最后说明匹配失败，如果子串指针走到最后说明匹配成功，此时子串指针走到空，主串指针走到子串字符的下一位，用主串指针的标志位减掉子串长度就是子串在主串中第一次出现的位置</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669722186568.png" alt="1669722186568"></p>
<h5 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h5><p>Sunday：在一个字符串中找另一个字符串首次出现的地址</p>
<p>算法过程：</p>
<p>首先将匹配字符串与主字符串的开头对其，进行一个一个的比较字符串是否相等，如果相等则同时向后移动，直到第一个不相等的字符。如上图所示，第一个不相等的字符为主字符串中的a对应匹配字符串中的d。现在我们知道主字符串和匹配字符串此时是不匹配的，那么我们知道从主字符串和匹配字符串对齐位置处开始，往后数匹配字符串的长度（这里是10）个字符，此时对应的字符串一定和匹配字符串是不匹配的，如下图所示：<br> <img src="https://img-blog.csdnimg.cn/ebceaf5850d24e98ab98fcb443e0a775.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p>
<p>如上图所示，上面用虚线框柱的主字符串中的子字符串一定与匹配字符串不匹配。由于在此处时主字符串和匹配字符串不匹配，因此我们可以直接略过这个位置，看虚线框后面的一个字符，然后查找该字符在匹配字符串中从后往前数第一次出现的位置，并将这两个字符对其，重新将主字符串和匹配字符串进行比较，如下图所示：<br> <img src="https://img-blog.csdnimg.cn/be8b84f80a3a4decbb8f3f360828a855.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p>
<p>如上图所示，重新将两个字符串对其，即将这里的d字符对其，然后重新从匹配字符串的开头进行匹配两个字符串。匹配的第一个字符为主字符串的a与匹配字符串的c，显然不相等，因此，同样看从主字符串匹配开始处数匹配字符串长度个单位，这个长度之后的字符为a，因此在匹配字符串中从后往前查找a第一次出现的位置，将两个a对齐，即重复上一个步骤，如下图所示：<br> <img src="https://img-blog.csdnimg.cn/a106294aec474249b5868beffd82f112.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p>
<p> Sunday匹配算法的大致过程就是这样，只要当前有字符不匹配，那么从匹配开始处数匹配字符串长度个字符，这些个字符肯定不匹配，既然这些一定不匹配，那么我们就直接看匹配字符串长度的下一个字符，然后在匹配字符串中查找该字符从后往前，第一次出现该字符的位置，然后将这两个字符对其 </p>
<p> 虚线框后的字符<code>g</code>在匹配字符串中并未出现，因此我们直接将匹配字符串于<code>g</code>后的下一个字符对齐，如下图所示： </p>
<p> <img src="https://img-blog.csdnimg.cn/bb5cf62d3bde4e40839fcdad4d692575.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p>
<p> 在此种情况下，将主串中的<code>I</code>与匹配串中的<code>c</code>进行对齐，重新开始匹配。 </p>
<p> Sunday算法的实现过程中，其时间耗费大多是在查找虚线框后的这个字符在匹配字符串中的位置时所需的花费。如果我们能减少查找字符的时间花费，那么我们就能大大减少Sunday算法的时间复杂度。 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671264272302.png" alt="1671264272302"></p>
<p>建立一个next数组，以每个字符为索引值（因为字符对于计算机来说是一串数字，是可以被当做索引值的），初始化每个数组中的值为-1，从前往后遍历匹配串，将每个字符的下标值记录到数组中，如果遇到重复的字符，直接用后面字符的下标值覆盖掉前面的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include&lt;stdio.h&gt;</span><br><span class="line"> 2 #include&lt;stdlib.h&gt;</span><br><span class="line"> 3 #include&lt;string.h&gt;</span><br><span class="line"> 4 </span><br><span class="line"> 5 int Sunday(const char *src,const char *match)</span><br><span class="line"> 6 &#123;</span><br><span class="line"> 7     if(src == NULL || match == NULL)return -1;</span><br><span class="line"> 8 </span><br><span class="line"> 9     //get next array</span><br><span class="line">10     int *pNext = NULL;</span><br><span class="line">11     pNext = (int*)malloc(sizeof(int)*256);</span><br><span class="line">12     memset(pNext,-1,sizeof(int)*256);</span><br><span class="line">13 </span><br><span class="line">14     int i;</span><br><span class="line">15     for(i=0; i&lt;strlen(match); i++)</span><br><span class="line">16     &#123;</span><br><span class="line">17         pNext[match[i]] = i;</span><br><span class="line">18     &#125;</span><br><span class="line">19 </span><br><span class="line">20     //pipei</span><br><span class="line">21     i=0;</span><br><span class="line">22     int j=0;</span><br><span class="line">23     int k=0;</span><br><span class="line">24     while(i&lt;strlen(src) &amp;&amp; j&lt;strlen(match))</span><br><span class="line">25     &#123;</span><br><span class="line">26         if(src[i] == match[j])</span><br><span class="line">27         &#123;</span><br><span class="line">28             i++;</span><br><span class="line">29             j++;</span><br><span class="line">30         &#125;</span><br><span class="line">31 </span><br><span class="line">32         else                                                                                                                                                                      </span><br><span class="line">33         &#123;</span><br><span class="line">34             if(k+strlen(match) &lt; strlen(src))</span><br><span class="line">35             &#123;</span><br><span class="line">36                 i = k+strlen(match) - pNext[src[k+strlen(match)]];</span><br><span class="line">37                 k = i;</span><br><span class="line">38                 j = 0;</span><br><span class="line">39             &#125;</span><br><span class="line">40             else</span><br><span class="line">41             &#123;</span><br><span class="line">42                 return -1;</span><br><span class="line">43             &#125;</span><br><span class="line">44         &#125;</span><br><span class="line">45     &#125;</span><br><span class="line">47     if(j == strlen(match))</span><br><span class="line">48     &#123;</span><br><span class="line">49         return k;</span><br><span class="line">50     &#125;</span><br><span class="line">51     else</span><br><span class="line">52     &#123;</span><br><span class="line">53         return -1;</span><br><span class="line">54     &#125;</span><br><span class="line">55 </span><br><span class="line">56 &#125;</span><br><span class="line">57 </span><br><span class="line">58 </span><br><span class="line">59 </span><br><span class="line">60 int main()</span><br><span class="line">61 &#123;</span><br><span class="line">62     int Index = Sunday(&quot;swofnvjfiakdiaabcabcjfger&quot;,&quot;abcabc&quot;);</span><br><span class="line">63     printf(&quot;%d\n&quot;,Index);</span><br><span class="line">64     return 0;</span><br><span class="line">65 &#125;                   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p>结点之间有分支，具有层次关系</p>
<p>树的定义：树是n个结点的有限集。（树的定义是一个递归的定义）</p>
<p>n &#x3D; 0为空树</p>
<p>有且仅有一个特定的结点称为根结点</p>
<p>（根结点：非空树中无前驱结点的结点）</p>
<p>其余称为根的子树</p>
<p>结点的度：结点拥有的子树数。</p>
<p>树的度：树内各结点的度的最大值</p>
<p>终端结点（叶子）：度&#x3D;0</p>
<p>非终端结点（分支结点）：度 !&#x3D; 0</p>
<p>内部结点：根结点以外的分支结点</p>
<p>兄弟结点：结点有共同的双亲</p>
<p>结点的祖先：从根到该结点所经分支上的所有结点</p>
<p>树的深度：树中结点的最大层次</p>
<p>有序树：树中结点的各子树从左至右有次序</p>
<p>森林：是m棵互不相交的树的集合</p>
<p>注：对于中间结点，高度和深度不是一个概念，高度是从下往上看，深度是从上往下看</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树：由一个根结点及两棵互不相交的分别称为这个根的左子树和右子树的二叉树组成</p>
<p>特殊二叉树：（在顺序存储方式下可以复原）</p>
<h5 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h5><p>1、一个有k层的二叉树总的结点个数最多有2^k-1个</p>
<p>2、一个有k层的二叉树总的叶子结点最多有2^(k-1)个</p>
<p>3、对于任何一棵二叉树T,如果其叶子数为n0，度为2的结点数n2，则n0 &#x3D; n2 + 1。</p>
<p>性质3说明：</p>
<p>叶子的度为0为n0，度为2的结点为n2，一个二叉树</p>
<p>从下往上看，每个结点都有一条边去连接双亲，所以总边数是n-1</p>
<p>(根结点无双亲);</p>
<p>从上往下看总边数&#x3D;n2<em>2 + n1</em>1 + n0;</p>
<p>n-1 &#x3D; n2<em>2 + n1</em>1 + n0，n &#x3D; n2<em>2 + n1</em>1 + n0 +1，总结点数n &#x3D; n2 + n1 + n0</p>
<p>所以n0 &#x3D; n2 + 1</p>
<p>4、具有n个结点的完全二叉树的深度为floor(log2(n)) + 1</p>
<p>5、如果结点的编号是i，那么她的双亲编号是i&#x2F;2；她的左孩子结点是2i，右孩子是2i+1</p>
<p>将一棵完全二叉树从上到下从左到右从一开始编号，编号为i的结点如果满足2i&lt;&#x3D;n，则编号为i的结点有左孩子，如果满足2i+1&lt;&#x3D;n，则该结点有右孩子</p>
<p>父亲结点的编号范围是1~n&#x2F;2</p>
<p>如果是从0开始编号，那么有左孩子：2i+1&lt;n，右孩子：21+2&lt;n，父亲编号范围：0~n&#x2F;2-1。</p>
<h5 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h5><p>一个深度为k且有2^k-1个结点的二叉树</p>
<p>特点：</p>
<p>1、每层结点数都达到最大</p>
<p>2、叶子结点全部在底层</p>
<p>编号规则：从根结点开始，自上而下，自左到右</p>
<h5 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h5><p>深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号1~n的结点一一对应时，称为完全二叉树</p>
<p>注：在满二叉树中，从最后一个结点开始，<strong>连续</strong>去掉任意个结点，即是一棵完全二叉树</p>
<p>特点：</p>
<blockquote>
<p>每个结点最多有两个孩子</p>
<p>子树有左右之分，次序不能颠倒</p>
<p>可以是空集</p>
</blockquote>
<h5 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h5><blockquote>
<p>值</p>
<p>左子结点</p>
<p>右子结点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void CreateBiTree(BinaryTree **pTree)</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line"></span><br><span class="line">    if(num == 0)return;</span><br><span class="line"> </span><br><span class="line">    //jiedian tainjia</span><br><span class="line">    *pTree = (BinaryTree*)malloc(sizeof(BinaryTree));</span><br><span class="line">    (*pTree)-&gt;Value = num;</span><br><span class="line">    (*pTree)-&gt;pLeft = NULL;</span><br><span class="line">    (*pTree)-&gt;pRight = NULL;</span><br><span class="line"></span><br><span class="line">    CreateBiTree(&amp;(*pTree)-&gt;pLeft);</span><br><span class="line">    CreateBiTree(&amp;(*pTree)-&gt;pRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>深度遍历</p>
<blockquote>
<p>1.前序：根、左、右。</p>
<p>2.中序：左、根、右。</p>
<p>3.后序：左、右、根。</p>
</blockquote>
<h6 id="递归遍历："><a href="#递归遍历：" class="headerlink" title="递归遍历："></a>递归遍历：</h6><p>先序算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status PreOrderTraverse(BiTree T)&#123;</span><br><span class="line">	if(T == NULL)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		//访问根结点</span><br><span class="line">		//visit(T)</span><br><span class="line">		cout&lt;&lt;T-&gt;data;</span><br><span class="line">		//递归遍历左子树 </span><br><span class="line">		PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">		//递归遍历右子树</span><br><span class="line">		PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status InOrderTraverse(BiTree T)&#123;</span><br><span class="line">	if(T == NULL)return 1;</span><br><span class="line">	else&#123;</span><br><span class="line">		//递归遍历左子树</span><br><span class="line">		InOrderTraverse(T-&gt;lchild);</span><br><span class="line">		//访问根结点</span><br><span class="line">		//visit(T)</span><br><span class="line">		cout&lt;&lt;T-&gt;data;</span><br><span class="line">		//递归遍历右子树</span><br><span class="line">		InOrderTraverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status PostOrderTraverse(BiTree T)&#123;</span><br><span class="line">	if(T == NULL)return 1;</span><br><span class="line">	else&#123;</span><br><span class="line">		//递归遍历左子树</span><br><span class="line">		PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">		//递归遍历右子树</span><br><span class="line">		PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">		//访问根结点</span><br><span class="line">		//visit(T)</span><br><span class="line">		cout&lt;&lt;T-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h6><p>先序遍历</p>
<p>1、申请栈保存非空节点</p>
<p>2、遍历</p>
<p>结点非空，入栈，打印保存结点，找左孩子结点，当结点为空时结束</p>
<p>结束后弹出结点</p>
<p>处理右侧结点，如果当前结点非空，打印保存下来，找当前结点的左侧结点，步骤同上</p>
<p>没有待处理数据的时候停止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">46 void PreOrderTraversal(BinaryTree* pTree)</span><br><span class="line">47 &#123;</span><br><span class="line">48     if(pTree == NULL)return ;</span><br><span class="line">49 </span><br><span class="line">50     stack&lt;BinaryTree*&gt; s;</span><br><span class="line">51 </span><br><span class="line">52     while(1)</span><br><span class="line">53     &#123;</span><br><span class="line">54         while(pTree)</span><br><span class="line">55         &#123;</span><br><span class="line">56             //打印</span><br><span class="line">57             cout&lt;&lt;pTree-&gt;Value&lt;&lt;&quot; &quot;;</span><br><span class="line">58             //入站</span><br><span class="line">59             s.push(pTree);</span><br><span class="line">60 </span><br><span class="line">61             //左</span><br><span class="line">62             pTree = pTree-&gt;pLeft;</span><br><span class="line">63         &#125;</span><br><span class="line">64         if(s.empty())break;</span><br><span class="line">65 </span><br><span class="line">66         pTree = s.top();</span><br><span class="line">67         s.pop();</span><br><span class="line">68 </span><br><span class="line">69         pTree = pTree-&gt;pRight;</span><br><span class="line">70     &#125;</span><br><span class="line">71 </span><br><span class="line">72 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中序遍历</p>
<p>1、申请栈空间</p>
<p>2、遍历</p>
<p>结点非空，保存起来入栈，找到左子节点，当结点为空时结束</p>
<p>结束时，弹出，打印</p>
<p>处理右子结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> 75 void InOrderTraversal(BinaryTree* pTree)</span><br><span class="line"> 76 &#123;</span><br><span class="line"> 77     if(pTree == NULL)return ;</span><br><span class="line"> 78 </span><br><span class="line"> 79     stack&lt;BinaryTree*&gt; s;</span><br><span class="line"> 80 </span><br><span class="line"> 81     while(1)</span><br><span class="line"> 82     &#123;</span><br><span class="line"> 83         while(pTree)</span><br><span class="line"> 84         &#123;</span><br><span class="line"> 85             //入站</span><br><span class="line"> 86             s.push(pTree);</span><br><span class="line"> 87 </span><br><span class="line"> 88             //左</span><br><span class="line"> 89             pTree = pTree-&gt;pLeft;</span><br><span class="line"> 90         &#125;</span><br><span class="line"> 91         if(s.empty())break;</span><br><span class="line"> 92 </span><br><span class="line"> 93         pTree = s.top();</span><br><span class="line"> 94 </span><br><span class="line"> 95         //打印</span><br><span class="line"> 96         cout&lt;&lt;pTree-&gt;Value&lt;&lt;&quot; &quot;;</span><br><span class="line"> 97 </span><br><span class="line"> 98         s.pop();</span><br><span class="line"> 99 </span><br><span class="line">100         pTree = pTree-&gt;pRight;</span><br><span class="line">101     &#125;</span><br><span class="line">102 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后序遍历</p>
<p>1、申请栈空间</p>
<p>2、遍历</p>
<p>结点非空，保存结点入栈，找左子节点</p>
<p>栈顶元素是否有右子结点</p>
<p>（1）如果有，未处理，处理</p>
<p>（2）如果有，已经处理过&#x2F;没有，则弹出，打印</p>
<p>判断右子结点是否被处理过：栈顶元素的右子结点是否等于上次打印结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">104 void LastOrderTraversal(BinaryTree* pTree)</span><br><span class="line">105 &#123;</span><br><span class="line">106     if(pTree == NULL)return ;</span><br><span class="line">107 </span><br><span class="line">108     stack&lt;BinaryTree*&gt; s;</span><br><span class="line">109 </span><br><span class="line">110     BinaryTree* pMark = NULL;</span><br><span class="line">111 </span><br><span class="line">112     while(1)</span><br><span class="line">113     &#123;</span><br><span class="line">114         while(pTree)</span><br><span class="line">115         &#123;</span><br><span class="line">116             //保存</span><br><span class="line">117             s.push(pTree);</span><br><span class="line">118             //左</span><br><span class="line">119             pTree = pTree-&gt;pLeft;</span><br><span class="line">120         &#125;</span><br><span class="line">121 </span><br><span class="line">122         if(s.empty())break;</span><br><span class="line">123 </span><br><span class="line">124         if(s.top()-&gt;pRight == pMark || s.top()-&gt;pRight == NULL)</span><br><span class="line">125         &#123;</span><br><span class="line">126             //弹出</span><br><span class="line">127             pMark = s.top();</span><br><span class="line">128             s.pop();                                                                                                                                                              </span><br><span class="line">129             //打印</span><br><span class="line">130             cout&lt;&lt;pMark-&gt;Value&lt;&lt;&quot; &quot;;</span><br><span class="line">131         &#125;</span><br><span class="line">132         else</span><br><span class="line">133         &#123;</span><br><span class="line">134             pTree = s.top()-&gt;pRight;</span><br><span class="line">135         &#125;</span><br><span class="line">136     &#125;</span><br><span class="line">137 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="广度遍历"><a href="#广度遍历" class="headerlink" title="广度遍历"></a>广度遍历</h6><blockquote>
<p>层序：按照从上到下从左到右依次遍历</p>
</blockquote>
<p>层序遍历</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674642041271.png" alt="1674642041271"></p>
<p>如果按照每层从左到右的遍历逻辑，这棵二叉树的层序遍历序列就是 [ 1 , 4 , 2 , 7 , 20 , 5 ] </p>
<p> 同一层中的节点自左向右遍历是通过队列实现的： 先将根结点1入队，然后让1出队，处理根结点，然后将它的左孩子4和右孩子2依次放入队列，然后让4出队，处理结点4的同时将结点4的左孩子7和右孩子20入队，然后让结点2出队，处理结点2的同时让结点2的左孩子5入队，所有结点处理完成即队列为空时结束</p>
<p>这样就实现了层序依次遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">45 void LevelTraversal(BinaryTree *pTree)</span><br><span class="line">46 &#123;</span><br><span class="line">47     if(pTree == NULL)return;</span><br><span class="line">48 </span><br><span class="line">49     //队列</span><br><span class="line">50     queue&lt;BinaryTree*&gt; q;</span><br><span class="line">51 </span><br><span class="line">52     //根节点入队</span><br><span class="line">53     q.push(pTree);</span><br><span class="line">54 </span><br><span class="line">55     //遍历</span><br><span class="line">56     while(!q.empty())</span><br><span class="line">57     &#123;</span><br><span class="line">58         pTree = q.front();</span><br><span class="line">59         q.pop();</span><br><span class="line">60 </span><br><span class="line">61         cout&lt;&lt;pTree-&gt;Value&lt;&lt;&quot; &quot;;</span><br><span class="line">62 </span><br><span class="line">63         //非空左右孩子节点入队</span><br><span class="line">64         if(pTree-&gt;pLeft != NULL)</span><br><span class="line">65         &#123;</span><br><span class="line">66             q.push(pTree-&gt;pLeft);</span><br><span class="line">67         &#125;</span><br><span class="line">68         if(pTree-&gt;pRight != NULL)</span><br><span class="line">69         &#123;</span><br><span class="line">70             q.push(pTree-&gt;pRight);</span><br><span class="line">71         &#125;</span><br><span class="line">72     &#125;</span><br><span class="line">73 </span><br><span class="line">74 &#125;</span><br></pre></td></tr></table></figure>

<p>根据二叉数的前序和中序或者后序和中序能构造出二叉数</p>
<h4 id="完全二叉树的创建"><a href="#完全二叉树的创建" class="headerlink" title="完全二叉树的创建"></a>完全二叉树的创建</h4><p>先把数据放入一个结构体数组中，然后进行数据的关联（找到左右子树）</p>
<p>从0开始编号，根据性质，左子树的结点编号是2i+1，2i+2，父亲结点的编号是0~n&#x2F;2-1.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	BinaryTree *CreateCBT(int arr[],int nLength)</span><br><span class="line">102 &#123;</span><br><span class="line">103     if(arr == NULL || nLength &lt;=0) return ;</span><br><span class="line">104 </span><br><span class="line">105     //空间申请</span><br><span class="line">106     BinaryTree *pCBT = NULL;</span><br><span class="line">107     pCBT = (BinaryTree*)malloc(sizeof(BinaryTree)*nLength);</span><br><span class="line">108 </span><br><span class="line">109     //赋值</span><br><span class="line">110     int i;</span><br><span class="line">111     for(i=0; i&lt;nLength; i++)</span><br><span class="line">112     &#123;</span><br><span class="line">113         pCBT[i].Value = arr[i];</span><br><span class="line">114         pCBT[i].pLeft = NULL;</span><br><span class="line">115         pCBT[i].pRight = NULL;</span><br><span class="line">116     &#125;</span><br><span class="line">117 </span><br><span class="line">118     //父子关系关联</span><br><span class="line">119     for(i=0; i&lt;nLength/2; i++)</span><br><span class="line">120     &#123;</span><br><span class="line">121         if(2*i+1 &lt;= nLength -1)</span><br><span class="line">122         &#123;</span><br><span class="line">123             pCBT[i].pLeft = &amp;pCBT[2*i+1];</span><br><span class="line">124         &#125;</span><br><span class="line">125 </span><br><span class="line">126         if(2*i+2 &lt;= nLength-1)</span><br><span class="line">127         &#123;</span><br><span class="line">128             pCBT[i].pRight = &amp;pCBT[2*i+2];</span><br><span class="line">129         &#125;</span><br><span class="line">130     &#125;</span><br><span class="line">131     return pCBT;</span><br><span class="line">132 </span><br><span class="line">133 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="二叉搜索树-x2F-排序二叉树（BST）"><a href="#二叉搜索树-x2F-排序二叉树（BST）" class="headerlink" title="二叉搜索树&#x2F;排序二叉树（BST）"></a>二叉搜索树&#x2F;排序二叉树（BST）</h4><p>定义：树中的任意一个父亲结点的值都比整棵左子树大，都比整棵右子树小</p>
<p>搜索速度变慢的情况：当子树都在一边，退化成链表，平均分配搜索的优势没有了，增删的优势也没有了</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674632474001.png" alt="1674632474001"></p>
<h5 id="构建排序二叉树"><a href="#构建排序二叉树" class="headerlink" title="构建排序二叉树"></a>构建排序二叉树</h5><p>1、如果是空树，则添加的结点就是根</p>
<p>2、如果树是非空，遍历</p>
<p>和当前的根结点进行比较，如果当前节点比父亲大，去右子树处理，如果比父亲小，去左子树处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">26 void AddNode(BinaryTree **pTree ,int nNum)</span><br><span class="line">27 &#123;</span><br><span class="line">28     //数值放入节点</span><br><span class="line">29     BinaryTree* pTemp = NULL;</span><br><span class="line">30     pTemp = (BinaryTree*)malloc(sizeof(BinaryTree));</span><br><span class="line">31     pTemp-&gt;Value = nNum;</span><br><span class="line">32     pTemp-&gt;pLeft = NULL;</span><br><span class="line">33     pTemp-&gt;pRight = NULL;</span><br><span class="line">34 </span><br><span class="line">35     //放入树中</span><br><span class="line">36     if(*pTree == NULL)</span><br><span class="line">37     &#123;</span><br><span class="line">38         *pTree = pTemp;</span><br><span class="line">39         return;</span><br><span class="line">40     &#125;</span><br><span class="line">41     </span><br><span class="line">42     BinaryTree* pNode = *pTree;</span><br><span class="line">43 </span><br><span class="line">44     while(pNode)</span><br><span class="line">45     &#123;</span><br><span class="line">46         if(pNode-&gt;Value &gt; nNum)</span><br><span class="line">47         &#123;</span><br><span class="line">48             if(pNode-&gt;pLeft == NULL)</span><br><span class="line">49             &#123;</span><br><span class="line">50                 pNode-&gt;pLeft = pTemp;</span><br><span class="line">51                 return;</span><br><span class="line">52             &#125;</span><br><span class="line">53             //向左走</span><br><span class="line">54             pNode = pNode-&gt;pLeft;</span><br><span class="line">55         &#125;</span><br><span class="line">56 </span><br><span class="line">57         else if(pNode-&gt;Value &lt; nNum)</span><br><span class="line">58         &#123;</span><br><span class="line">59             if(pNode-&gt;pRight == NULL)</span><br><span class="line">60             &#123;</span><br><span class="line">61                 pNode-&gt;pRight = pTemp;</span><br><span class="line">62                 return ;</span><br><span class="line">63             &#125;</span><br><span class="line">64             //向右走</span><br><span class="line">65             pNode = pNode-&gt;pRight;</span><br><span class="line">66         &#125;</span><br><span class="line">67         </span><br><span class="line">68         else</span><br><span class="line">69         &#123;</span><br><span class="line">70             printf(&quot;data error\n&quot;);</span><br><span class="line">71             free(pTemp);</span><br><span class="line">72             pTemp = NULL;</span><br><span class="line">73             return;</span><br><span class="line">74         &#125;</span><br><span class="line">75     &#125;</span><br><span class="line">76 &#125;</span><br><span class="line">77 </span><br><span class="line">78 BinaryTree* CreateBST()</span><br><span class="line">79 &#123;</span><br><span class="line">80     int nNum;</span><br><span class="line">81     int nLen;</span><br><span class="line">82     int i;</span><br><span class="line">83 </span><br><span class="line">84     BinaryTree* pTree = NULL;</span><br><span class="line">85     printf(&quot;请输入节点个数\n&quot;);</span><br><span class="line">86     scanf(&quot;%d\n&quot;,&amp;nLen);</span><br><span class="line">87 </span><br><span class="line">88     for(i=0;i&lt;nLen;i++)</span><br><span class="line">89     &#123;</span><br><span class="line">90         scanf(&quot;%d&quot;,&amp;nNum);</span><br><span class="line">91 </span><br><span class="line">92         //节点添加</span><br><span class="line">93         AddNode(&amp;pTree,nNum);</span><br><span class="line">94     &#125;</span><br><span class="line">95     return pTree;</span><br><span class="line">96 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="排序二叉树的删除"><a href="#排序二叉树的删除" class="headerlink" title="排序二叉树的删除"></a>排序二叉树的删除</h5><p>分三种情况</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674821731882.png" alt="1674821731882"></p>
<h6 id="第一种情况：删除叶子结点。比如：2-5-9-12"><a href="#第一种情况：删除叶子结点。比如：2-5-9-12" class="headerlink" title="第一种情况：删除叶子结点。比如：2,5,9,12."></a>第一种情况：删除叶子结点。比如：2,5,9,12.</h6><p>(1) 需求先去找到要删除的结点 targetNode。</p>
<p>(2) 找到 targetNode 的 父结点 parent。</p>
<p>(3) 确定 targetNode 是 parent 的左子结点还是右子结点。</p>
<p>(4) 根据前面的情况来对应删除。</p>
<p>左子结点 parent.left &#x3D; null</p>
<p>右子结点 parent.right &#x3D; null</p>
<h6 id="第二种情况：删除只有一棵子树的结点。比如：1"><a href="#第二种情况：删除只有一棵子树的结点。比如：1" class="headerlink" title="第二种情况：删除只有一棵子树的结点。比如：1"></a>第二种情况：删除只有一棵子树的结点。比如：1</h6><p>(1) 需求先去找到要删除的结点 targetNode。</p>
<p>(2) 找到 targetNode 的 父结点 parent。</p>
<p>(3) 确定 targetNode 的子结点是左子结点还是右子结点。</p>
<p>(4) targetNode 是 parent 的左子结点还是右子结点。</p>
<p>(5) 如果 targetNode 有左子结点</p>
<p>a 如果 targetNode 是 parent 的左子结点</p>
<p>parent.left &#x3D; targetNode.left;</p>
<p>b 如果 targetNode 是 parent 的右子结点</p>
<p>parent.right &#x3D; targetNode.left;</p>
<p>(6) 如果 targetNode 有右子结点</p>
<p>a 如果 targetNode 是 parent 的左子结点</p>
<p>parent.left &#x3D; targetNode.right;</p>
<p>b 如果 targetNode 是 parent 的右子结点</p>
<p>parent.right &#x3D; targetNode.right</p>
<h6 id="第三种情况：删除有两棵子树的结点。比如：7-3-10。"><a href="#第三种情况：删除有两棵子树的结点。比如：7-3-10。" class="headerlink" title="第三种情况：删除有两棵子树的结点。比如：7,3,10。"></a>第三种情况：删除有两棵子树的结点。比如：7,3,10。</h6><p>(1) 需求先去找到要删除的结点 targetNode。</p>
<p>(2) 找到 targetNode 的 父结点 parent。</p>
<p>(3) 从 targetNode 的右子树找到最小的结点。</p>
<p>(4) 用一个临时变量， 将最小结点的值保存到 temp</p>
<p>(5) 删除该最小结点</p>
<p>(6) targetNode.value &#x3D; temp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> 98 void Search(BinaryTree* pTree,int nNum,BinaryTree **pDel,BinaryTree **pFather)</span><br><span class="line"> 99 &#123;</span><br><span class="line">100     while(pTree)</span><br><span class="line">101     &#123;   </span><br><span class="line">102         if(pTree-&gt;Value == nNum)</span><br><span class="line">103         &#123;   </span><br><span class="line">104             *pDel = pTree;</span><br><span class="line">105             return;</span><br><span class="line">106         &#125;</span><br><span class="line">107         else if(pTree-&gt;Value &gt; nNum)</span><br><span class="line">108         &#123;   </span><br><span class="line">109             //左侧</span><br><span class="line">110             *pFather = pTree;</span><br><span class="line">111             pTree = pTree-&gt;pLeft;</span><br><span class="line">112         &#125;</span><br><span class="line">113         else</span><br><span class="line">114         &#123;   </span><br><span class="line">115             //右侧</span><br><span class="line">116             *pFather = pTree;</span><br><span class="line">117             pTree = pTree-&gt;pRight;</span><br><span class="line">118         &#125;</span><br><span class="line">119     &#125;</span><br><span class="line">120     *pFather = NULL;</span><br><span class="line">121 &#125;</span><br><span class="line">123 void DelNode(BinaryTree **pTree,int nNum)</span><br><span class="line">124 &#123;</span><br><span class="line">125     //查找</span><br><span class="line">126     BinaryTree* pDel = NULL;</span><br><span class="line">127     BinaryTree* pFather = NULL;</span><br><span class="line">128 </span><br><span class="line">129     Search(*pTree,nNum,&amp;pDel,&amp;pFather);</span><br><span class="line">130 </span><br><span class="line">131     //未找到</span><br><span class="line">132     if(pDel == NULL)return ;</span><br><span class="line">133 </span><br><span class="line">134     //两个孩子</span><br><span class="line">135     BinaryTree* pMark = NULL;</span><br><span class="line">136     if(pDel-&gt;pLeft != NULL &amp;&amp; pDel-&gt;pRight != NULL)</span><br><span class="line">137     &#123;</span><br><span class="line">138         pMark = pDel;</span><br><span class="line">139 </span><br><span class="line">140         //左子树的最右值</span><br><span class="line">141         pFather = pDel;</span><br><span class="line">142         pDel = pDel-&gt;pLeft;</span><br><span class="line">143 </span><br><span class="line">144         while(pDel-&gt;pRight != NULL)</span><br><span class="line">145         &#123;</span><br><span class="line">146             pFather = pDel;</span><br><span class="line">147             pDel = pDel-&gt;pRight;</span><br><span class="line">148         &#125;</span><br><span class="line">149 </span><br><span class="line">150         //值覆盖</span><br><span class="line">151         pMark-&gt;Value = pDel-&gt;Value;</span><br><span class="line">152     &#125;</span><br><span class="line">153 </span><br><span class="line">154     //0个孩子或1个孩子</span><br><span class="line">155     //换根</span><br><span class="line">156     if(pFather == NULL)</span><br><span class="line">157     &#123;</span><br><span class="line">158         *pTree = pDel-&gt;pLeft ? pDel-&gt;pLeft : pDel-&gt;pRight;</span><br><span class="line">159         free(pDel);</span><br><span class="line">160         return;</span><br><span class="line">161     &#125;</span><br><span class="line">162     else</span><br><span class="line">163     &#123;</span><br><span class="line">164         if(pDel == pFather-&gt;pLeft)</span><br><span class="line">165         &#123;</span><br><span class="line">166             pFather-&gt;pLeft = pDel-&gt;pLeft ? pDel-&gt;pLeft : pDel-&gt;pRight;</span><br><span class="line">167         &#125;</span><br><span class="line">168         else</span><br><span class="line">169         &#123;</span><br><span class="line">170             pFather-&gt;pRight = pDel-&gt;pLeft ? pDel-&gt;pLeft : pDel-&gt;pRight;     </span><br><span class="line">171         &#125;</span><br><span class="line">172     &#125;</span><br><span class="line">173 </span><br><span class="line">174 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="如何将一棵排序二叉树转变为有序的双向链表"><a href="#如何将一棵排序二叉树转变为有序的双向链表" class="headerlink" title="如何将一棵排序二叉树转变为有序的双向链表"></a>如何将一棵排序二叉树转变为有序的双向链表</h5><p>以中序遍历的方式遍历BST，在遍历的时候把当前结点以尾添加的形式添加到双向链表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">176 void BSTToList(BinaryTree* pTree,BinaryTree** pHead,BinaryTree** pTail)</span><br><span class="line">177 &#123;</span><br><span class="line">178     if(pTree == NULL)return;</span><br><span class="line">179 </span><br><span class="line">180     //左子树</span><br><span class="line">181     BSTToList(pTree-&gt;pLeft,pHead,pTail);</span><br><span class="line">182 </span><br><span class="line">183     //处理节点</span><br><span class="line">184     if(*pHead == NULL)</span><br><span class="line">185     &#123;</span><br><span class="line">186         *pHead = pTree;                                                                                                                                                           </span><br><span class="line">187     &#125;</span><br><span class="line">188     else</span><br><span class="line">189     &#123;</span><br><span class="line">190         (*pTail)-&gt;pRight = pTree;</span><br><span class="line">191         pTree-&gt;pLeft = *pTail;</span><br><span class="line">192     &#125;</span><br><span class="line">193     *pTail = pTree;</span><br><span class="line">194 </span><br><span class="line">195     //右子树</span><br><span class="line">196     BSTToList(pTree-&gt;pRight,pHead,pTail);</span><br><span class="line">197 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="平衡二叉树-x2F-平衡二叉搜索树（AVL树）"><a href="#平衡二叉树-x2F-平衡二叉搜索树（AVL树）" class="headerlink" title="平衡二叉树&#x2F;平衡二叉搜索树（AVL树）"></a>平衡二叉树&#x2F;平衡二叉搜索树（AVL树）</h4><p>定义：在二叉搜索树的前提下，保证任意一个结点的左右子树的高度差不超过1</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674820003348.png" alt="1674820003348"></p>
<h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><p>右旋：指将根节点的左侧往右拉，原先的左子节点变成新的父节点，并把多余的右子节点出让，给已经降级的根节点当左子节点 </p>
<p>二叉树调整的时候都是从下往上的顺序，所以先动节点5</p>
<p> （1）原先的根节点为7，左子节点4有个右子节点5 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893373496.png" alt="1674893373496"></p>
<p> （2）暂且不看右子节点5，先将二叉树右旋，新的父节点为4 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893407903.png" alt="1674893407903"></p>
<p> （3）再将原右子节点5，作为已降级的7的左子节点即可 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893428956.png" alt="1674893428956"></p>
<p>当节点7有父亲节点时，除了上述处理外，结点4的父亲是原来结点7的父亲，最多动四个结点，三对父子关系</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674906000237.png" alt="1674906000237"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">52 void RightRotate(BinaryTree *pNode)</span><br><span class="line">53 &#123;</span><br><span class="line">54     if(pNode == NULL || pNode-&gt;pLeft == NULL)return;</span><br><span class="line">55 </span><br><span class="line">56     BinaryTree *pMark = pNode-&gt;pLeft;</span><br><span class="line">57 </span><br><span class="line">58     //三个孩子的关系</span><br><span class="line">59     pNode-&gt;pLeft = pMark-&gt;pRight;</span><br><span class="line">60     pMark-&gt;pRight = pNode;</span><br><span class="line">61 </span><br><span class="line">62     if(pNode-&gt;pFather != NULL)</span><br><span class="line">63     &#123;</span><br><span class="line">64         if(pNode == pNode-&gt;pFather-&gt;pLeft)</span><br><span class="line">65         &#123;</span><br><span class="line">66             pNode-&gt;pFather-&gt;pLeft = pMark;</span><br><span class="line">67         &#125;</span><br><span class="line">68         else</span><br><span class="line">69         &#123;</span><br><span class="line">70             pNode-&gt;pFather-&gt;pRight = pMark;</span><br><span class="line">71         &#125;</span><br><span class="line">72     &#125;</span><br><span class="line">73     else</span><br><span class="line">74     &#123;</span><br><span class="line">75         pTree = pMark;</span><br><span class="line">76     &#125;</span><br><span class="line">77 </span><br><span class="line">78     //三个父亲的关系</span><br><span class="line">79     if(pNode-&gt;pLeft != NULL)</span><br><span class="line">80     &#123;</span><br><span class="line">81         pNode-&gt;pLeft-&gt;pFather = pNode;</span><br><span class="line">82     &#125;</span><br><span class="line">83 </span><br><span class="line">84     pMark-&gt;pFather = pNode-&gt;pFather;</span><br><span class="line">85     pNode-&gt;pFather = pMark;</span><br><span class="line">86 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="旋转的情况"><a href="#旋转的情况" class="headerlink" title="旋转的情况"></a>旋转的情况</h5><p> 左子树高：右旋；右子树高：左旋； </p>
<p>右旋：左的左引起的不平衡</p>
<p>左旋：右的右引起的不平衡</p>
<p>左右旋：左的右引起的不平衡</p>
<p>右左旋：右的左引起的不平衡</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674908927263.png" alt="1674908927263"></p>
<h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><p> 左旋：指将根节点的右侧往左拉，原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674907940748.png" alt="1674907940748"></p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p> 红黑树是一种自平衡的二叉查找树，是一种高效的查找树。 </p>
<p>红黑树的特性</p>
<blockquote>
<p>1、每个节点的颜色，要么是黑色，要么是红色</p>
<p>2、根节点必须是黑色的</p>
<p>3、认为终端节点是黑色的，称之为黑哨兵</p>
<p>4、树中不允许两个红结点为父子关系</p>
<p>5、从任意节点向下出发，所能到达的各个终端节点的各条路径上，黑节点的数目必须是完全相同的</p>
</blockquote>
<p>红黑树的增加、删除、查找的时间消耗都是log(2n)</p>
<p>因为红黑树的五条性质，红黑树上路径的长度不会超过另一条路径的两倍</p>
<h5 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h5><p>插入时：插入的结点一定是红色的，如果为黑色，会破坏第五条规则</p>
<ul>
<li><p>如果插入的结点是根节点，将颜色改为黑色</p>
</li>
<li><p>插入的结点的父结点是黑色的，则插入完成</p>
</li>
<li><p>插入的结点的父结点是红色的，则需要修复，且继续向上调整，直到为根或满足规则</p>
<p>如果叔叔节点是红色的，父亲-&gt;黑色，叔叔-&gt;黑色，爷爷-&gt;红色，爷爷为新的操作节点，重新调整</p>
<p>如果叔叔节点时黑色的，</p>
<p>父亲是爷爷的左侧，当前结点是父亲的右侧，让父亲作为新的当前节点，以当前节点为旋转点左旋 </p>
<p>父亲是爷爷的左侧，当前结点是父亲的左侧，父亲-&gt;黑色，爷爷-&gt;红色，以爷爷为旋转点右旋，如果平衡则结束</p>
<p>父亲是爷爷的右侧，当前节点是父亲的左侧，让父亲作为新的调整节点，以新的调整节点为旋转点右旋</p>
<p>父亲是爷爷的右侧，当前结点是父亲的右侧，父亲-&gt;黑色，爷爷-&gt;红色，以爷爷为旋转点左旋，如果平衡则结束</p>
</li>
<li><p>如果根修改之后为红色，一定要改过来，改为黑色</p>
</li>
</ul>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674983264886.png" alt="1674983264886"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675164219988.png" alt="1675164219988"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"> 89 RBT *GetFather(RBT *pTree,int nNum)</span><br><span class="line"> 90 &#123;</span><br><span class="line"> 91     while(pTree)</span><br><span class="line"> 92     &#123;   </span><br><span class="line"> 93         if(pTree-&gt;Value &gt; nNum)</span><br><span class="line"> 94         &#123;   </span><br><span class="line"> 95             //左侧</span><br><span class="line"> 96             if(pTree-&gt;pLeft == NULL)return pTree;</span><br><span class="line"> 97             pTree = pTree-&gt;pLeft;</span><br><span class="line"> 98         &#125;</span><br><span class="line"> 99         else if(pTree-&gt;Value &lt; nNum)</span><br><span class="line">100         &#123;   </span><br><span class="line">101             //右侧</span><br><span class="line">102             if(pTree-&gt;pRight == NULL)return pTree;</span><br><span class="line">103             pTree = pTree-&gt;pRight;</span><br><span class="line">104         &#125;</span><br><span class="line">105         else</span><br><span class="line">106         &#123;   </span><br><span class="line">107             printf(&quot;data error\n&quot;);</span><br><span class="line">108             exit(1);</span><br><span class="line">109         &#125;</span><br><span class="line">110     &#125;</span><br><span class="line">111     return NULL;</span><br><span class="line">112 &#125;</span><br><span class="line">113 </span><br><span class="line">114 RBT *GetUncle(RBT *pFather)</span><br><span class="line">115 &#123;</span><br><span class="line">116     if(pFather == pFather-&gt;pFather-&gt;pLeft)</span><br><span class="line">117     &#123;</span><br><span class="line">118         return pFather-&gt;pFather-&gt;pRight;</span><br><span class="line">119     &#125;</span><br><span class="line">120     else</span><br><span class="line">121     &#123;</span><br><span class="line">122         return pFather-&gt;pFather-&gt;pLeft;</span><br><span class="line">123     &#125;</span><br><span class="line">124 &#125;</span><br><span class="line">126 void AddNode(int nNum)</span><br><span class="line">127 &#123;</span><br><span class="line">128     RBT *pTemp = NULL;</span><br><span class="line">129     pTemp = (RBT*)malloc(sizeof(RBT));</span><br><span class="line">130     pTemp-&gt;Value = nNum;</span><br><span class="line">131     pTemp-&gt;Color = RED;</span><br><span class="line">132     pTemp-&gt;pLeft = NULL;</span><br><span class="line">133     pTemp-&gt;pRight = NULL;</span><br><span class="line">134     pTemp-&gt;pFather = NULL;</span><br><span class="line">135 </span><br><span class="line">136     //找到父亲节点</span><br><span class="line">137     RBT *pNode = NULL;</span><br><span class="line">138     pNode = GetFather(pRBT,nNum);</span><br><span class="line">139     pTemp-&gt;pFather = pNode;</span><br><span class="line">140 </span><br><span class="line">141     //空树</span><br><span class="line">142     if(pNode == NULL)</span><br><span class="line">143     &#123;</span><br><span class="line">144         pRBT = pTemp;</span><br><span class="line">145         pRBT-&gt;Color = BLACK;</span><br><span class="line">146         return ;</span><br><span class="line">147     &#125;</span><br><span class="line">148 </span><br><span class="line">149     //非空树</span><br><span class="line">150     //连接</span><br><span class="line">151     if(nNum &lt; pNode-&gt;Value)</span><br><span class="line">152     &#123;</span><br><span class="line">153         pNode-&gt;pLeft = pTemp;</span><br><span class="line">154     &#125;</span><br><span class="line">155     else</span><br><span class="line">156     &#123;</span><br><span class="line">157         pNode-&gt;pRight = pTemp;</span><br><span class="line">158     &#125;</span><br><span class="line">159 </span><br><span class="line">160     //父亲黑</span><br><span class="line">161     if(pNode-&gt;Color == BLACK)</span><br><span class="line">162     &#123;</span><br><span class="line">163         return ;</span><br><span class="line">164     &#125;</span><br><span class="line">165                                                                                                                                                                                   </span><br><span class="line">166     //父亲红</span><br><span class="line">167     RBT *pGrandFather = NULL;</span><br><span class="line">168     RBT *pUncle = NULL;</span><br><span class="line">169 </span><br><span class="line">170     while(pNode-&gt;Color == RED)</span><br><span class="line">171     &#123;</span><br><span class="line">172         pGrandFather = pNode-&gt;pFather;</span><br><span class="line">173         pUncle = GetUncle(pNode);</span><br><span class="line">174 </span><br><span class="line">175         //叔叔红</span><br><span class="line">176         if(pUncle-&gt;Color == RED &amp;&amp; pUncle != NULL)</span><br><span class="line">177         &#123;</span><br><span class="line">178             pNode-&gt;Color = BLACK;</span><br><span class="line">179             pUncle-&gt;Color = BLACK;</span><br><span class="line">180             pGrandFather-&gt;Color = RED;</span><br><span class="line">181 </span><br><span class="line">182             pTemp = pGrandFather;</span><br><span class="line">183             pNode = pTemp-&gt;pFather;</span><br><span class="line">184 </span><br><span class="line">185             //根</span><br><span class="line">186             if(pNode == NULL)</span><br><span class="line">187             &#123;</span><br><span class="line">188                 pTemp-&gt;Color = BLACK;</span><br><span class="line">189                 break;</span><br><span class="line">190             &#125;</span><br><span class="line">191             continue;</span><br><span class="line">192         &#125;</span><br><span class="line">193 </span><br><span class="line">194         //叔叔黑</span><br><span class="line">195         if(pUncle-&gt;Color == BLACK || pUncle == NULL)</span><br><span class="line">196         &#123;</span><br><span class="line">197             //父亲是爷爷的左侧</span><br><span class="line">198             if(pNode == pGrandFather-&gt;pLeft)</span><br><span class="line">199             &#123;</span><br><span class="line">200                 //当前节点是父亲的左侧</span><br><span class="line">201                 if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">202                 &#123;</span><br><span class="line">203                     pNode-&gt;Color = BLACK;</span><br><span class="line">204                     pGrandFather-&gt;Color = RED;</span><br><span class="line">205                     RightRotate(pGrandFather);</span><br><span class="line">206                     break;</span><br><span class="line">207                 &#125;</span><br><span class="line">208                 //当前节点是父亲的右侧</span><br><span class="line">209                 if(pTemp == pNode-&gt;pRight)</span><br><span class="line">210                 &#123;</span><br><span class="line">211                     pTemp = pNode;</span><br><span class="line">212                     LeftRotate(pTemp);</span><br><span class="line">213 </span><br><span class="line">214                     //更新父亲</span><br><span class="line">215                     pNode = pTemp-&gt;pFather;</span><br><span class="line">216                 &#125;</span><br><span class="line">217             &#125;</span><br><span class="line">218 </span><br><span class="line">219             //父亲是爷爷的右侧</span><br><span class="line">220             if(pNode == pGrandFather-&gt;pRight)</span><br><span class="line">221             &#123;</span><br><span class="line">222                 //当前节点是父亲的右侧</span><br><span class="line">223                 if(pTemp == pNode-&gt;pRight)</span><br><span class="line">224                 &#123;</span><br><span class="line">225                     pNode-&gt;Color = BLACK;</span><br><span class="line">226                     pGrandFather-&gt;Color = RED;</span><br><span class="line">227                     LeftRotate(pGrandFather);</span><br><span class="line">228                     break;</span><br><span class="line">229                 &#125;</span><br><span class="line">230 </span><br><span class="line">231                 //当前节点是父亲的左侧</span><br><span class="line">232                 if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">233                 &#123;</span><br><span class="line">234                     pTemp = pNode;</span><br><span class="line">235                     RightRotate(pTemp);</span><br><span class="line">236 </span><br><span class="line">237                     //更新父亲</span><br><span class="line">238                     pNode = pTemp-&gt;pFather;</span><br><span class="line">239                 &#125;</span><br><span class="line">240             &#125;</span><br><span class="line">241         &#125;</span><br><span class="line">242     &#125;</span><br><span class="line">243 </span><br><span class="line">244 &#125;</span><br><span class="line">245 </span><br><span class="line">246 void CreateRBT()</span><br><span class="line">247 &#123;</span><br><span class="line">248     int nLen;</span><br><span class="line">249     int nNum;</span><br><span class="line">250     scanf(&quot;%d&quot;,&amp;nLen);</span><br><span class="line">251 </span><br><span class="line">252     int i;</span><br><span class="line">253     for(i=0; i&lt;nLen; i++)</span><br><span class="line">254         &#123;</span><br><span class="line">255             scanf(&quot;%d&quot;,&amp;nNum);</span><br><span class="line">256             AddNode(nNum);</span><br><span class="line">257         &#125;</span><br><span class="line">258 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h5><p>真正被删除的结点的颜色</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675321702785.png" alt="1675321702785"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675337723859.png" alt="1675337723859"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">RBT *FindNode(RBT *pTree,int nNum)</span><br><span class="line">&#123;</span><br><span class="line">	while(pTree)</span><br><span class="line">	&#123;</span><br><span class="line">		if(pTree-&gt;nValue == nNum)</span><br><span class="line">		&#123;</span><br><span class="line">			return pTree;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(pTree-&gt;nValue &gt; nNum)</span><br><span class="line">		&#123;</span><br><span class="line">			pTree = pTree-&gt;pLeft;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pTree = pTree-&gt;pRight;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DelNode(int nNum)</span><br><span class="line">&#123;</span><br><span class="line">	//查找</span><br><span class="line">	RBT *pTemp = NULL;</span><br><span class="line">	pTemp = FindNode(pRBT,nNum);</span><br><span class="line"></span><br><span class="line">	if(pTemp == NULL)return;</span><br><span class="line">	</span><br><span class="line">	RBT *pMark = NULL;</span><br><span class="line">	//孩子情况分析</span><br><span class="line">	if(pTemp-&gt;pLeft != NULL &amp;&amp; pTemp-&gt;pRight != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		pMark = pTemp;</span><br><span class="line">		pTemp = pTemp-&gt;pLeft;</span><br><span class="line">		while(pTemp-&gt;pRight != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			pTemp = pTemp-&gt;pRight;</span><br><span class="line">		&#125;</span><br><span class="line">		pMark-&gt;nValue = pTemp-&gt;nValue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//颜色情况讨论</span><br><span class="line">	RBT *pNode = pTemp-&gt;pFather;</span><br><span class="line"></span><br><span class="line">	//1.根</span><br><span class="line">	if(pNode == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		//无子</span><br><span class="line">		if(pTemp-&gt;pLeft == NULL &amp;&amp; pTemp-&gt;pRight == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			free(pTemp);</span><br><span class="line">			pTemp = NULL;</span><br><span class="line">			pRBT = NULL;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//有一个红子</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pRBT = pTemp-&gt;pLeft ? pTemp-&gt;pLeft : pTemp-&gt;pRight;</span><br><span class="line">			pRBT-&gt;nColor = BLACK;</span><br><span class="line">			pRBT-&gt;pFather = NULL;</span><br><span class="line"></span><br><span class="line">			free(pTemp);</span><br><span class="line">			pTemp = NULL;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.非根</span><br><span class="line">	//2.1节点红</span><br><span class="line">	if(pTemp-&gt;nColor == RED)</span><br><span class="line">	&#123;</span><br><span class="line">		if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pLeft = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pRight = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		free(pTemp);</span><br><span class="line">		pTemp = NULL;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.2节点黑色且有一个红子</span><br><span class="line">	if(pTemp-&gt;nColor == BLACK &amp;&amp; (pTemp-&gt;pLeft != NULL || pTemp-&gt;pRight != NULL))</span><br><span class="line">	&#123;</span><br><span class="line">		if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pLeft = pTemp-&gt;pLeft ? pTemp-&gt;pLeft : pTemp-&gt;pRight;</span><br><span class="line">			pNode-&gt;pLeft-&gt;nColor = BLACK;</span><br><span class="line">			pNode-&gt;pLeft-&gt;pFather = pNode;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pRight = pTemp-&gt;pLeft ? pTemp-&gt;pLeft : pTemp-&gt;pRight;</span><br><span class="line">			pNode-&gt;pRight-&gt;nColor = BLACK;</span><br><span class="line">			pNode-&gt;pRight-&gt;pFather = pNode;</span><br><span class="line">		&#125;</span><br><span class="line">		free(pTemp);</span><br><span class="line">		pTemp = NULL;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//节点黑色且无子</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		RBT *pBrother = GetUncle(pTemp);</span><br><span class="line"></span><br><span class="line">		//删除</span><br><span class="line">		if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pLeft = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pRight = NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		free(pTemp);</span><br><span class="line">		pTemp = NULL;</span><br><span class="line">		</span><br><span class="line">		//调整</span><br><span class="line">		while(1)</span><br><span class="line">		&#123;</span><br><span class="line">			//兄弟是红色</span><br><span class="line">			if(pBrother-&gt;nColor == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				pNode-&gt;nColor = RED;</span><br><span class="line">				pBrother-&gt;nColor = BLACK;</span><br><span class="line"></span><br><span class="line">				if(pBrother == pNode-&gt;pRight)</span><br><span class="line">				&#123;</span><br><span class="line">					LeftRotate(pNode);</span><br><span class="line">					pBrother = pNode-&gt;pRight;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					RightRotate(pNode);</span><br><span class="line">					pBrother = pNode-&gt;pLeft;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//兄弟是黑色</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				//两个侄子全黑</span><br><span class="line">				if((pBrother-&gt;pLeft == NULL &amp;&amp; pBrother-&gt;pRight == NULL)||</span><br><span class="line">					((pBrother-&gt;pLeft != NULL &amp;&amp; pBrother-&gt;pLeft-&gt;nColor == BLACK) &amp;&amp;</span><br><span class="line">					(pBrother-&gt;pRight != NULL &amp;&amp; pBrother-&gt;pRight-&gt;nColor == BLACK)))</span><br><span class="line">				&#123;</span><br><span class="line">					//父亲为红色</span><br><span class="line">					if(pNode-&gt;nColor == RED)</span><br><span class="line">					&#123;</span><br><span class="line">						pNode-&gt;nColor = BLACK;</span><br><span class="line">						pBrother-&gt;nColor = RED;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					//父为黑色</span><br><span class="line">					else</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = RED;</span><br><span class="line">						pTemp = pNode;</span><br><span class="line">						pNode = pTemp-&gt;pFather;</span><br><span class="line"></span><br><span class="line">						if(pNode == NULL)</span><br><span class="line">						&#123;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						pBrother = GetUncle(pTemp);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				//左侄子红 右侄子黑</span><br><span class="line">				else if((pBrother-&gt;pLeft != NULL &amp;&amp; pBrother-&gt;pLeft-&gt;nColor == RED)&amp;&amp;</span><br><span class="line">					(pBrother-&gt;pRight == NULL || pBrother-&gt;pRight-&gt;nColor == BLACK))</span><br><span class="line">				&#123;</span><br><span class="line">					//兄弟在父亲的右侧</span><br><span class="line">					if(pBrother == pNode-&gt;pRight)</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = RED;</span><br><span class="line">						pBrother-&gt;pLeft-&gt;nColor = BLACK;</span><br><span class="line">						RightRotate(pBrother);</span><br><span class="line">						pBrother = pNode-&gt;pRight;</span><br><span class="line">					&#125;</span><br><span class="line">					//兄弟在父亲的左侧</span><br><span class="line">					else</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = pNode-&gt;nColor;</span><br><span class="line">						pNode-&gt;nColor = BLACK;</span><br><span class="line">						pBrother-&gt;pLeft-&gt;nColor = BLACK;</span><br><span class="line">						RightRotate(pNode);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				//右侄子为红色</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					//兄弟在父亲左侧</span><br><span class="line">					if(pBrother == pNode-&gt;pLeft)</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = RED;</span><br><span class="line">						pBrother-&gt;pRight-&gt;nColor = BLACK;</span><br><span class="line">						LeftRotate(pBrother);</span><br><span class="line">						pBrother = pNode-&gt;pLeft;</span><br><span class="line">					&#125;</span><br><span class="line">					//兄弟在父亲的右侧</span><br><span class="line">					else</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = pNode-&gt;nColor;</span><br><span class="line">						pNode-&gt;nColor = BLACK;</span><br><span class="line">						pBrother-&gt;pRight-&gt;nColor = BLACK;</span><br><span class="line">						LeftRotate(pNode);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>红黑树的增删查的时间复杂度都是log2n</p>
<p>红黑树的应用：进程管理，内存管理，epoll模型</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>适合作为索引的结构搜索速度必须要快，有三种结构：哈希表，RBT，B+树</p>
<p>哈希表的弊端：空间固定，适合处理数据量比较少的数据</p>
<p>RBT：搜索速度快，适合频繁增删，适合处理数量不确定的数据，非常适合在内存中使用</p>
<p>B+树：适合多路的平衡搜索树。层高低，适合用于磁盘里，进行磁盘的寻址。</p>
<p>MYSQL中的索引的实现就是应用B+树</p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>m阶</p>
<p>所有的节点都是key-value结构</p>
<h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><blockquote>
<p>1.每个节点最多有m-1个关键字</p>
<p>2.根节点最少可以有一个关键字</p>
<p>3.每个节点最少有ceil(m&#x2F;2)-1个关键字</p>
<p>4.每个节点的关键字都按照从小到大的顺序排列，每个关键字的左子树的所有关键字都小于它，右子树的关键字都大于它</p>
<p>5.所有叶子节点都位于同一层</p>
</blockquote>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675344373357.png" alt="1675344373357"></p>
<h5 id="B-Tree插入"><a href="#B-Tree插入" class="headerlink" title="B-Tree插入"></a>B-Tree插入</h5><p>插入：（键值对：记录）</p>
<p>如果要插入的记录已经存在，用需要插入的value替换旧的value</p>
<p>如果要插入的记录不在</p>
<blockquote>
<p>1.根据要插入的key，找到叶子节点并插入</p>
<p>2.判断节点关键字的个数是否小于m-1，</p>
<p>小于，操作结束；</p>
<p>大于，当前节点发生裂变，以中间节点为中心，分裂成左右两部分，中间关键字上升至父节点中，这个关键字的左子树指向分裂后的左半部分，右子树指向分裂后的右半部分</p>
<p>父亲结点作为新的操作结点重新讨论</p>
</blockquote>
<h5 id="B-Tree删除"><a href="#B-Tree删除" class="headerlink" title="B-Tree删除"></a>B-Tree删除</h5><blockquote>
<p>1.当前被删除关键字key在非叶子结点，则采取替换方式，用后继key覆盖要删除的key（最后要删除的关键字一定在叶子节点）</p>
<p>2.删除之后，当前节点的关键字个数大于ceil(m&#x2F;2)-1，则结束</p>
<p>3.删除之后，当前节点的关键字个数不大于ceil(m&#x2F;2)-1，看兄弟节点的个数是否大于ceil(m&#x2F;2)-1</p>
<p>大于：将父亲节点内的关键字下移至当前节点，兄弟节点的关键字上移至父亲节点</p>
<p>等于：父亲节点的一个key下移，与当前节点以及当前节点的兄弟节点合并成一个新节点</p>
</blockquote>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B-Tree无法进行范围搜索</p>
<p>B+Tree：多路平衡搜索树</p>
<blockquote>
<p>1.B+树包含两种类型的节点：内部节点（索引节点），叶子节点</p>
<p>只有叶子节点才包含真正的数据内容，剩下的节点里只有关键字（根结点可以是内部节点也可以是叶子节点）</p>
<p>2.B+树与B树不同于内部节点不保存数据，只适用于与索引，所有记录都保存在叶子节点</p>
<p>3.M阶B+节点内最多有m-1个关键字</p>
<p>4.关键字值在节点内部，按照从小到大的顺序排列，对于一个内部节点，左子树的所有key均小于它，右子树的key均大于它</p>
<p>5.每个叶子节点都存有指向相邻叶子节点的指针，叶子节点本身依关键字的大小从小到大顺序链接</p>
</blockquote>
<h5 id="B-树插入"><a href="#B-树插入" class="headerlink" title="B+树插入"></a>B+树插入</h5><blockquote>
<p>1.空树，创建一个叶子节点，把记录放入其中，此时这个叶子节点也是根结点</p>
<p>2.根据key值可以找到对应的叶子节点进行插入，判断当前结点的关键字个数</p>
<p>小于等于m-1，插入结束</p>
<p>大于m-1，分裂，左叶子节点包含前m&#x2F;2个记录，右叶子节点包含剩余的记录</p>
<p>第m&#x2F;2+1个记录的key进位到父亲结点中</p>
<p>3.如果父亲结点满足关键字的个数小于等于m-1，结束</p>
<p>若不满足，裂变</p>
</blockquote>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675347696332.png" alt="1675347696332"></p>
<h3 id="冒泡排序：BubbleSort"><a href="#冒泡排序：BubbleSort" class="headerlink" title="冒泡排序：BubbleSort"></a>冒泡排序：BubbleSort</h3><p>核心思想：相邻两个元素进行大小比较，如果前一个比后一个大，交换</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675214291252.png" alt="1675214291252"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/01/31/hexo%E4%BD%BF%E7%94%A8/" class="article-date">
      <time datetime="2023-01-31T03:23:53.000Z" itemprop="datePublished">2023-01-31</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/hexo%E4%BD%BF%E7%94%A8/">hexo使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="HEXO使用"><a href="#HEXO使用" class="headerlink" title="HEXO使用"></a>HEXO使用</h1><h2 id="1-博客文件夹的位置"><a href="#1-博客文件夹的位置" class="headerlink" title="1.博客文件夹的位置"></a>1.博客文件夹的位置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">博客位置：</span><br><span class="line">E:/blog</span><br><span class="line">源文件位置：</span><br><span class="line">E:/blog/source/posts_</span><br><span class="line">博客地址</span><br><span class="line">https://psh193.github.io/</span><br></pre></td></tr></table></figure>

<h2 id="2-对博客进行操作"><a href="#2-对博客进行操作" class="headerlink" title="2.对博客进行操作"></a>2.对博客进行操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">新建博客：</span><br><span class="line">1.</span><br><span class="line">在E:/blog下打开 git bash 输入代码</span><br><span class="line">hexo new &quot;标题&quot;</span><br><span class="line">后用vi打开编辑</span><br><span class="line">如：</span><br><span class="line">hexo new &quot;我是蔡胖子略略略&quot;</span><br><span class="line">该方式新建博客会自动添加标题和时间的配置文段</span><br><span class="line">2.</span><br><span class="line">直接在E:/blog/source/posts_下新建.md文件编写</span><br><span class="line">但该方式新建博客不会自动添加配置文段，需要自己手动添加</span><br><span class="line">方法为：</span><br><span class="line">在最上面右键空白处点击-&gt;插入-&gt;YAML Front Matter</span><br></pre></td></tr></table></figure>

<h2 id="3-博客的更新-部署"><a href="#3-博客的更新-部署" class="headerlink" title="3.博客的更新(部署)"></a>3.博客的更新(部署)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">三连代码：</span><br><span class="line">在E:/blog下打开 git bash 输入代码</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">分别是清除、生成、部署，每次更新博客直接按顺序运行上三行代码</span><br><span class="line">注：当开启steam++加速器加速时会占用网络，上传会失败，需要关闭加速器再上传</span><br></pre></td></tr></table></figure>

<h2 id="4-博客的运行"><a href="#4-博客的运行" class="headerlink" title="4.博客的运行"></a>4.博客的运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">博客更新后要很久才能看到博客更新的状态，为了快速看到更新效果可以运行博客</span><br><span class="line">在E:/blog下打开 git bash 输入代码</span><br><span class="line">hexo s</span><br><span class="line">运行该代码后会给你一个网址，运行结果如下：</span><br><span class="line">LENOVO@LAPTOP-OFBGASM2 MINGW64 /e/blog</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo s</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">其中http://localhost:4000/就是系统为你分配的临时网址地址，端口为4000，可以看到博客执行后的效果。</span><br><span class="line">注：复制该网址时需右键复制，不能按 Ctrl+C ，因为unix中 Ctrl+C 为终止进程的信号！！！</span><br><span class="line">注：查看完执行结果后切记按一下 Ctrl+C 结束运行，否则会一直占用4000端口</span><br></pre></td></tr></table></figure>

<h2 id="5-4000端口被占用"><a href="#5-4000端口被占用" class="headerlink" title="5.4000端口被占用"></a>5.4000端口被占用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">所有人运行代码hexo s时返回结果都是http://localhost:4000/，因此常常出现4000端口被占用的情况</span><br><span class="line">解决：更换5000端口或更大的端口</span><br><span class="line">代码：</span><br><span class="line">hexo s -p 5000 #更换5000端口执行</span><br><span class="line">若5000也被占用同理换更大的端口</span><br><span class="line"></span><br><span class="line">执行结果如下：</span><br><span class="line">LENOVO@LAPTOP-OFBGASM2 MINGW64 /e/blog</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo s -p 5000</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:5000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<h2 id="6-配置文件-config-yml"><a href="#6-配置文件-config-yml" class="headerlink" title="6.配置文件_config.yml"></a>6.配置文件_config.yml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预知后事如何听，请听下回讲解~</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-C++笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/01/31/C++%E7%AC%94%E8%AE%B0/" class="article-date">
      <time datetime="2023-01-31T02:47:53.000Z" itemprop="datePublished">2023-01-31</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/C++%E7%AC%94%E8%AE%B0/">C++笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>[TOC]</p>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>面向对象的三大特性：封装、继承、多态</p>
<p>封装：将零散的数据和算法放在一个集合里，方便管理和使用</p>
<p>复用性：公共功能、过程的抽象，体现为能被重复使用的类、方法，就要要求我们针对某一类功能而不是针对某一个功能去设计</p>
<p>扩展性：增加新的功能不影响原来已经封装好的功能</p>
<h4 id="vs项目"><a href="#vs项目" class="headerlink" title="vs项目"></a>vs项目</h4><p>.sln文件对应的是解决方案，其它的文件是打开过程中产生的临时文件，是可以删掉的</p>
<p>Debug里是生成的可执行程序，调试版本，生成的程序比较大</p>
<p>真正上线之前要生成一个release版本</p>
<p>给别人分享代码是Debug和release都是不需要的</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>头文件不需要加.h</p>
<p>需要打开一个命名空间</p>
<h5 id="使用一个命名空间"><a href="#使用一个命名空间" class="headerlink" title="使用一个命名空间"></a>使用一个命名空间</h5><blockquote>
<p>1.using namespace 命名空间名：注意和其它命名空间名字冲突问题</p>
<p>2.手动指定命名空间及成员</p>
<p>3.显式的指定使用命名空间里的成员</p>
</blockquote>
<h5 id="定义命名空间：区分同一个作用域下的相同成员或者函数"><a href="#定义命名空间：区分同一个作用域下的相同成员或者函数" class="headerlink" title="定义命名空间：区分同一个作用域下的相同成员或者函数"></a>定义命名空间：区分同一个作用域下的相同成员或者函数</h5><p>namespace AA{</p>
<p>};</p>
<p>如果全局和命名空间有相同变量，优先使用全局的，如果全局没有再使用命名空间暴露出来的</p>
<h5 id="作用域：成员能使用的一个范围"><a href="#作用域：成员能使用的一个范围" class="headerlink" title="作用域：成员能使用的一个范围"></a>作用域：成员能使用的一个范围</h5><p>::作用域运算符，::前未指定作用域即全局作用域</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1670387586358.png" alt="1670387586358"></p>
<p>下面的A输出的值是30</p>
<h4 id="动态申请空间"><a href="#动态申请空间" class="headerlink" title="动态申请空间"></a>动态申请空间</h4><h5 id="C语言动态申请空间malloc"><a href="#C语言动态申请空间malloc" class="headerlink" title="C语言动态申请空间malloc"></a>C语言动态申请空间malloc</h5><h5 id="new类型"><a href="#new类型" class="headerlink" title="new类型"></a>new类型</h5><p>变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//int *p1 = new int;//申请空间</span><br><span class="line">int *p1 = new int(10);//申请空间并初始化指定值</span><br><span class="line"></span><br><span class="line">delete p1;//释放空间</span><br><span class="line">p1 = NULL;</span><br></pre></td></tr></table></figure>

<p>数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//int* p3 =  new int[10];//申请空间，返回数组的首地址</span><br><span class="line">int* p3 =  new int[10]();//申请空间并初始化</span><br><span class="line"></span><br><span class="line">delete []p3;//释放数组需要加上括号</span><br></pre></td></tr></table></figure>

<p>指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int **p4 = new int*; //指针的地址</span><br><span class="line">int* * p5 = new int*[];//指针数组</span><br><span class="line">int (**p6)[] = new (int(*) []);//数组指针</span><br></pre></td></tr></table></figure>

<p>二维数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int(*p7)[3] = new int [2][3]</span><br></pre></td></tr></table></figure>

<h5 id="C和C-的相同点与不同点"><a href="#C和C-的相同点与不同点" class="headerlink" title="C和C++的相同点与不同点"></a>C和C++的相同点与不同点</h5><p>相同点：在堆区动态申请空间</p>
<p>区别：</p>
<blockquote>
<p>1.new - delete C++关键字，编译器支持，malloc-free函数，需要头文件支持</p>
<p>2.malloc需要显式指定所需要的空间大小，new需要类型，根据类型计算所需要的空间</p>
<p>3.malloc  void* 需要强转，new不需要</p>
<p>**4.new-delete申请、释放对象内存空间，会自动调用构造函数和析构函数</p>
</blockquote>
<h4 id="BOOL-bool"><a href="#BOOL-bool" class="headerlink" title="BOOL  -  bool"></a>BOOL  -  bool</h4><blockquote>
<p>1.C:BOOL windows 系统提供 int 的别名（typedef）</p>
<p>C++:bool关键字</p>
<p>2.C:TRUE FALSE 宏</p>
<p>C++:true  false  关键字</p>
<p>3.C:BOOL类型变量 占用4个字节空间</p>
<p>C++:占用1个字节空间</p>
</blockquote>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;cxr&quot;;//字符串定义</span><br><span class="line">string str1 = &quot;cc&quot;;</span><br><span class="line">str1 = &quot;xx&quot;;//字符串重新赋值</span><br><span class="line"></span><br><span class="line">string str3 = &quot;cxr&quot; + str;//字符串利用操作符拼接</span><br></pre></td></tr></table></figure>

<h5 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">string str1 = str.substr(3,2);//字符串截取    str1=45</span><br></pre></td></tr></table></figure>

<h5 id="const-char-和string转换"><a href="#const-char-和string转换" class="headerlink" title="const char*和string转换"></a>const char*和string转换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//string -&gt; const char*</span><br><span class="line">const char *p =  str.c_str();</span><br><span class="line"></span><br><span class="line">//const char* -&gt; string</span><br><span class="line">string str = (char*)str;</span><br></pre></td></tr></table></figure>

<h4 id="NULL-nullptr"><a href="#NULL-nullptr" class="headerlink" title="NULL  nullptr"></a>NULL  nullptr</h4><blockquote>
<p>1.C:NULL是一个宏，整型数字</p>
<p>C++:nullptr关键字</p>
<p>2.NULL：代表整数0</p>
<p>nullptr：代表空指针</p>
</blockquote>
<h4 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h4><blockquote>
<p>在函数声明处，函数参数可以指定默认值，从右往左依次制定，不能间断</p>
<p>如果函数声明和定义分开，在函数声明处指定默认值即可</p>
</blockquote>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><blockquote>
<p>在同一个作用域下，函数名相同，参数列表不同（参数的类型，数量，顺序），对返回值没有要求的多个函数</p>
<p>编译器可以根据重载函数的参数自动区别调用对应的函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//不是函数重载，而是函数重定义，二者函数参数都是指针</span><br><span class="line">void func1(char *p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func1(char arr[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//是函数重载</span><br><span class="line">void show(int a)&#123;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void show(int &amp;a)&#123;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义函数指针区分两个函数</span><br><span class="line">void (*p_fun1)(int) = &amp;show;</span><br><span class="line">void (*p_fun2)(int&amp;) = &amp;show;</span><br><span class="line"></span><br><span class="line">//调用函数指针</span><br><span class="line">(*p_fun1)(a);</span><br><span class="line">(*p_fun2)(a);</span><br></pre></td></tr></table></figure>

<h5 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h5><p>函数传参三种形式，值  地址  引用（不推荐值传递，尤其是复合类型）</p>
<p>如果在函数内修改实参，一定要地址、引用传递</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用：对已存在的一块内存起别名，引用一旦定义就必须初始化，指向一块空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int &amp;b = a; //并不是取地址，而是定义引用</span><br><span class="line">//a和b的值和地址都是一样的，无论二者谁的值改变，另一个都会改变</span><br><span class="line">//两个函数都可以通过形参改变实参</span><br><span class="line">void fun (int *p)&#123;</span><br><span class="line"> *p = 20;</span><br><span class="line">&#125;</span><br><span class="line">void fun (int &amp;p)&#123;</span><br><span class="line"> p = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h5><blockquote>
<p>1.引用定义就要初始化，指针可以不用初始化（不推荐）</p>
<p>2.引用一旦引用某个空间，就不能再引用其他空间，指针可以修改其指向的空间</p>
<p>3.有空的指针，没有空的引用</p>
<p>4.引用不会额外开辟空间，指针会开辟存储地址的空间</p>
<p>5.指针可以有多级，引用不能有多级</p>
</blockquote>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类：完成某一功能相关的数据和算法的集合</p>
<p>类名一般是以C开头，类是一个抽象的概念</p>
<h5 id="C-中类和结构体的区别"><a href="#C-中类和结构体的区别" class="headerlink" title="C++中类和结构体的区别"></a>C++中类和结构体的区别</h5><blockquote>
<p>1.默认的访问修饰符不同，结构体public，类private</p>
<p>2.默认的继承方式不同，结构体public，类private</p>
</blockquote>
<h5 id="访问修饰符："><a href="#访问修饰符：" class="headerlink" title="访问修饰符："></a>访问修饰符：</h5><p>约束类成员的一个使用范围，默认的访问修饰符是private私有的</p>
<blockquote>
<p>private：私有的，类成员只能在类内使用</p>
<p>protected：保护的，类成员在类内核子类中可以使用</p>
<p>public：公共的，类成员在类内和类外，只要能定义对象的地方都可以使用</p>
</blockquote>
<p>具体概念：用类实例化的一个变量，对象</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><blockquote>
<p>无返回值（不是void，而是真的没有）函数名时当前的类名，无参，函数体代码为空</p>
<p>在定义对象的时候自动调用，用来初始化类成员属性,构造函数允许有多个，他们是函数重载的关系</p>
<p>一旦手动重构了构造函数，编译器将不再提供默认的无参构造</p>
</blockquote>
<h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><blockquote>
<p>编译器会默认提供</p>
<p>默认的析构函数：无返回值（不是void，而是真的没有）函数名时当前的类名，无参，函数体代码为空</p>
<p>析构函数只允许有一个，并且无参数</p>
<p>析构函数作用：用来回收成员申请的额外的空间，在对象声明周期结束前（对象回收前）自动调用</p>
<p>一旦手动重构了析构函数，编译器将不再提供默认的无参析构</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class CPeople&#123;</span><br><span class="line">public:</span><br><span class="line">	CPeople()&#123;	//构造函数</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	CPeople(string name)&#123;	//构造函数</span><br><span class="line">		m_strName = name;</span><br><span class="line">		m_bSex = true;</span><br><span class="line">		m_nAge = 20;</span><br><span class="line">		m_pNote = nullptr;</span><br><span class="line">		</span><br><span class="line">		m_pNote = new char[10]();</span><br><span class="line">	&#125;</span><br><span class="line">	~CPeople()&#123;	//析构函数</span><br><span class="line">		if(m_pNote)&#123;</span><br><span class="line">			delete []m_pNote;</span><br><span class="line">			m_pNote = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void eat()&#123;		//成员函数（成员方法）</span><br><span class="line">            cout&lt;&lt;m_strName&lt;&lt;&quot;正在吃饭&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">public:</span><br><span class="line">	string m_strName;//类成员属性（类成员变量）以m_开头</span><br><span class="line">	char * m_pNote;</span><br><span class="line">protected:</span><br><span class="line">	bool m_bSex;</span><br><span class="line">private:			//对于私有、保护的成员，可以提供一对公共的set/get接口，按照指定的规则进行设置访问</span><br><span class="line">					//数据成员</span><br><span class="line">	int m_nAge;</span><br><span class="line">public:</span><br><span class="line">	void SetAge(int age)&#123;	</span><br><span class="line">		if(0&lt;=age &amp;&amp; age &lt;=150)&#123;</span><br><span class="line">			m_nAge = age;</span><br><span class="line">		&#125;</span><br><span class="line">		m_nAge = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int GetAge()&#123;</span><br><span class="line">		return m_nAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CPeople peo;	//对象</span><br><span class="line">	peo.m_strName = &quot;黎明&quot;;</span><br><span class="line">	peo.eat();</span><br><span class="line">	peo.SetAge(20);</span><br><span class="line">	peo.GetAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="封装链表"><a href="#封装链表" class="headerlink" title="封装链表"></a>封装链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	int val;</span><br><span class="line">	Node *pNext;</span><br><span class="line">	Node(int v)&#123;</span><br><span class="line">		val = v;</span><br><span class="line">		pNext = nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class CMyList&#123;</span><br><span class="line">private:</span><br><span class="line">	Node* m_pHead;</span><br><span class="line">	Node* m_pEnd;</span><br><span class="line">	int m_nSize;</span><br><span class="line">public:</span><br><span class="line">	CMyList()&#123;</span><br><span class="line">		m_pHead = nullptr;</span><br><span class="line">		m_pEnd = nullptr;</span><br><span class="line">		m_nSize = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	~CMyList()&#123;</span><br><span class="line">		//遍历链表回收节点空间</span><br><span class="line">		Node* pTemp = nullptr;//用于标记要删除的结点</span><br><span class="line">		while(m_pHead)&#123;</span><br><span class="line">			pTemp = m_pHead;</span><br><span class="line">			m_pHead = m_pHead-&gt;m_pNext;</span><br><span class="line">			</span><br><span class="line">			//删除标记的</span><br><span class="line">			delete pTemp;</span><br><span class="line">			pTemp = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	//尾添加</span><br><span class="line">	void PushBack(int v)&#123;</span><br><span class="line">		//new一个结点</span><br><span class="line">		Node* pNode = new Node(v);</span><br><span class="line">		if(m_pHead)&#123;//空链表</span><br><span class="line">			m_pEnd-&gt;pNext = pNode;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			m_pHead = pNode;</span><br><span class="line">		&#125;</span><br><span class="line">		m_pEnd = pNode;</span><br><span class="line">		m_nSize++;</span><br><span class="line">	&#125;</span><br><span class="line">	//头删除</span><br><span class="line">	</span><br><span class="line">	//查看链表</span><br><span class="line">	</span><br><span class="line">	//获取长度</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//Node *pNode = new Node(10);</span><br><span class="line">	//cout&lt;&lt;pNode-&gt;val&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	CMyList mylist;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h3><h5 id="栈区局部对象"><a href="#栈区局部对象" class="headerlink" title="栈区局部对象"></a>栈区局部对象</h5><blockquote>
<p>遇到函数的返回或者}声明周期结束，自动回收</p>
<p>如果是new出来的对象需要去手动delete回收</p>
</blockquote>
<h5 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h5><blockquote>
<p>生命周期：程序开始创建，程序退出（销毁）被回收</p>
<p>作用域：整个应用程序，可以跨文件去使用</p>
<p>extern  变量名</p>
</blockquote>
<h5 id="静态全局"><a href="#静态全局" class="headerlink" title="静态全局"></a>静态全局</h5><blockquote>
<p>生命周期：程序开始创建，程序退出（销毁）被回收</p>
<p>作用域：只能在当前文件中使用，具有文件作用域</p>
</blockquote>
<h5 id="静态局部"><a href="#静态局部" class="headerlink" title="静态局部"></a>静态局部</h5><blockquote>
<p>生命周期：第一次调用包含这个对象的函数呗调用执行定义对象的代码，直到程序退出结束</p>
</blockquote>
<h5 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h5><blockquote>
<p>临时（匿名）对象，生命周期仅限于当前行，遇到；结束</p>
</blockquote>
<h4 id="探索类成员"><a href="#探索类成员" class="headerlink" title="探索类成员"></a>探索类成员</h4><h5 id="类成员属性"><a href="#类成员属性" class="headerlink" title="类成员属性"></a>类成员属性</h5><p>非静态类成员属性，属于对象，在定义对象时才存在，定义多个对象存在多份，之间互不影响</p>
<p>类成员函数：属于这个类的，不属于对象（存在与否不依赖对象定义与否），在编译期就存在了，只有一份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class CTest&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CTest tst;//空类申请的对象大小占1个字节：标识当前对真实存在于内存中</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CTest&#123;</span><br><span class="line">	int m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CTest tst;//大小占4个字节：创建对象时类成员被自动分配空间</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CTest&#123;</span><br><span class="line">	int m_a;</span><br><span class="line">	double m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CTest tst;//大小占16个字节：int占4字节，double占8字节，内存对齐所以是16</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h5><p>this指针：当前类对象的指针，类中【非静态成员函数】的参数列表中，默认编译器加的一个隐藏的参数，在参数列表中的第一个参数，指向了调用该函数的对象</p>
<p>作用：连接对象和类成员之间的桥梁</p>
<p>静态成员函数  与普通成员函数的区别：</p>
<blockquote>
<p>静态成员函数没有隐藏的this指针参数</p>
<p>不能使用普通的成员（成员属性+成员函数），只能使用静态成员</p>
</blockquote>
<p>静态成员属性：不属于对象，属于类的，只有一份，多个对象之间共享这个静态成员，在编译期就存在了，不依赖对象的存在而存在</p>
<p>在类外进行初始化：类型   类名：：变量名   &#x3D;   初始化值。</p>
<p>在没有对象的情况下，可以通过【类名::】调用，也可以通过对象调用</p>
<h5 id="编译错误：无法解析的外部符号"><a href="#编译错误：无法解析的外部符号" class="headerlink" title="编译错误：无法解析的外部符号"></a>编译错误：无法解析的外部符号</h5><p>有声明无定义</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class CTest&#123;</span><br><span class="line">public:</span><br><span class="line">	const int m_a;</span><br><span class="line">	mutable int m_b;	//关键字：mutable   在常函数中，允许修改变量的值</span><br><span class="line">	//初始化参数列表，真正初始化类成员的地方，const成员的初始化必须在初始化参数列表初始化，</span><br><span class="line">	//普通的成员也可以初始化，多个成员初始化用逗号分隔</span><br><span class="line">	//初始化成员的顺序，是成员在类中声明的先后顺序</span><br><span class="line">	CTest():m_a(10)&#123;</span><br><span class="line">		//m_a = 10;	严格来说，赋值操作</span><br><span class="line">		m_b = 20;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//常函数:参数列表后加const修饰,const修饰的是this指针</span><br><span class="line">	//常函数不能【随便】修改类成员变量</span><br><span class="line">	void show(/*    const CTest * const this   */)const&#123;</span><br><span class="line">		cout&lt;&lt;m_a&lt;&lt;endl;</span><br><span class="line">		this-&gt;m_b = 90;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	const int a = 10;	//定义了就要初始化，之后不能修改</span><br><span class="line">	int b = 20;</span><br><span class="line">	</span><br><span class="line">	const int * p1 = &amp;a ; 	//常量指针，const修饰的是*p</span><br><span class="line">	//*p = 30; 	不能通过当前这个指针去修改指向的空间的值</span><br><span class="line">	</span><br><span class="line">	int * const p2 = &amp;b;//指针常量，const修饰的是p指针</span><br><span class="line">	*p2 = 30;//通过指针修改指向空间里的值</span><br><span class="line">	//p2 = &amp;a;	修改指针的指向，非法</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译期运行期"><a href="#编译期运行期" class="headerlink" title="编译期运行期"></a>编译期运行期</h4><p>编译期：</p>
<blockquote>
<p>源程序交给编译器编译、生成的过程，最终得到可执行文件</p>
<p>访问修饰符、成员的作用域</p>
</blockquote>
<p>运行期：</p>
<blockquote>
<p>定义、实例化</p>
</blockquote>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>关键字：内联</p>
<p>优点：程序执行效率提高了，空间换时间</p>
<p>缺点：内存会增大</p>
<p>内联函数：代码少，逻辑简单</p>
<p>建议性关键字：递归函数即使加上inline，编译器也不会认为是内联函数</p>
<h4 id="类之间的横向关系"><a href="#类之间的横向关系" class="headerlink" title="类之间的横向关系"></a>类之间的横向关系</h4><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p>部分与整体，包含与被包含，有生命周期约束关系</p>
<h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>完成某个功能【必须】用到被依赖的对象，一般当做工具对待，没有有生命周期约束关系</p>
<h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><p>可有可无的平等的关系，没有有生命周期约束关系</p>
<h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><p>被聚合的对象组合起来（容器），统一去管理，有生命周期约束关系 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">class CHand&#123;</span><br><span class="line">public:</span><br><span class="line">	void move()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;小手挥舞&quot;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CComputer&#123;</span><br><span class="line">public:</span><br><span class="line">	void Compile()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;正在生成可执行程序&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CFriend&#123;</span><br><span class="line">public:</span><br><span class="line">	void play()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;我的朋友正在玩耍&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CPeople&#123;</span><br><span class="line">public:</span><br><span class="line">	CHand m_hand;</span><br><span class="line">	CFriend *m_pFri;</span><br><span class="line">	</span><br><span class="line">	CPeople()&#123;</span><br><span class="line">		m_pFri = nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void clap()&#123;</span><br><span class="line">		m_hand.move();</span><br><span class="line">		cout&lt;&lt;&quot;发出阵阵响声&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void program(CCoomputer* pComp)&#123;</span><br><span class="line">		if(pComp)&#123;</span><br><span class="line">			m_hand.move();</span><br><span class="line">			cout&lt;&lt;&quot;噼里啪啦，敲击键盘，输入一行行代码&quot;&lt;&lt;endl;</span><br><span class="line">			pComp-&gt;Compile();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void playwangzhe()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;准备打王者&quot;&lt;&lt;endl;</span><br><span class="line">		if(m_pFri)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;走啊开黑去&quot;&lt;&lt;endl;</span><br><span class="line">			m_pFri-&gt;play();</span><br><span class="line">			cout&lt;&lt;&quot;成功拿下五杀&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			cout&lt;&lt;&quot;自己匹配&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CFamily&#123;</span><br><span class="line">public:</span><br><span class="line">	CPeople* peoArr[10];//加指针可以动态申请，在构造函数中new的CPeople对象是自定义的</span><br><span class="line">						//不加指针是是固定的10个对象</span><br><span class="line">	CFamily()&#123;</span><br><span class="line">		for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">			peoArr[i] = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line">		peoArr[0] = new CPeople;</span><br><span class="line">		peoArr[1] = new CPeople;</span><br><span class="line">		peoArr[2] = new CPeople;</span><br><span class="line">	&#125;</span><br><span class="line">	~CFamily()&#123;</span><br><span class="line">		for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">			if(peoArr[i])&#123;</span><br><span class="line">				delete peoArr[i];</span><br><span class="line">				peoArr[i] = nullptr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">public:</span><br><span class="line">	void AllPeopleProgram(CCpmputer* pComp)&#123;</span><br><span class="line">		for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">			if(peoArr[i])&#123;</span><br><span class="line">				cout&lt;&lt;&quot;第&quot;&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;endl;</span><br><span class="line">				peoArr[i]-&gt;program(pComp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//组合、复合</span><br><span class="line">	CPeople peo;</span><br><span class="line">	peo.m_hand.move();</span><br><span class="line">	</span><br><span class="line">	//依赖</span><br><span class="line">	CPeople peo;</span><br><span class="line">	CComputer *pComp = new CComputer;</span><br><span class="line">	peo.program(pComp);</span><br><span class="line">	</span><br><span class="line">	delete pComp;</span><br><span class="line">	pComp = nullptr;</span><br><span class="line">	</span><br><span class="line">	//关联</span><br><span class="line">	CPeople peo;</span><br><span class="line">	peo.playwangzhe();</span><br><span class="line">	</span><br><span class="line">	CFriend fri;</span><br><span class="line">	peo.m_pFri = &amp;fri;</span><br><span class="line">	peo.playwangzhe();</span><br><span class="line">	</span><br><span class="line">	//聚合</span><br><span class="line">	CFamily fam;</span><br><span class="line">	CComputer *pComp = new CComputer;</span><br><span class="line">	fam.AllPeopleProgram(pComp);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1670512441877.png" alt="1670512441877"></p>
<h4 id="类之间的纵向关系：继承"><a href="#类之间的纵向关系：继承" class="headerlink" title="类之间的纵向关系：继承"></a>类之间的纵向关系：继承</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//父类（基类）</span><br><span class="line">class CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_fa;</span><br><span class="line">	int m_money;</span><br><span class="line">	</span><br><span class="line">	/*CFather()&#123;</span><br><span class="line">		m_fa = 30;</span><br><span class="line">		m_money = 100;</span><br><span class="line">	&#125;*/</span><br><span class="line">	CFather(int a,int b)&#123;</span><br><span class="line">		m_fa = a;</span><br><span class="line">		m_money = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CFather2&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_fa;</span><br><span class="line">	int m_money;</span><br><span class="line">	</span><br><span class="line">	/*CFather2()&#123;</span><br><span class="line">		m_fa = 30;</span><br><span class="line">		m_money = 100;</span><br><span class="line">	&#125;*/</span><br><span class="line">	CFather2(int a,int b)&#123;</span><br><span class="line">		m_fa = a;</span><br><span class="line">		m_money = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//子类（派生类）:子类可以使用父类成员</span><br><span class="line">//定义子类对象，构造顺序  父类-&gt;子类，父类的默认无参构造可以被自动调用</span><br><span class="line">//父类没有无参构造时，在子类的的初始化参数列表中，手动调用父类带参数的构造函数</span><br><span class="line">//子类对象  生命周期结束时，调用析构顺序  子类-&gt;父类</span><br><span class="line">class CSon: public CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_son;</span><br><span class="line">	int m_money;</span><br><span class="line">	CFather fa;</span><br><span class="line">	</span><br><span class="line">	CSon():CFather(100,101),fa(111,222)&#123;</span><br><span class="line">		m_son = 40;</span><br><span class="line">		m_money = 500;</span><br><span class="line">	&#125;</span><br><span class="line">	~CSon()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;~~~~~Cson&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void show()&#123;</span><br><span class="line">		cout&lt;&lt;m_fa&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;m_son&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//CSon son;	//定义子类对象</span><br><span class="line">	//son.m_son = 10;</span><br><span class="line">	//son.fa = 20;</span><br><span class="line">	</span><br><span class="line">	//son.show();</span><br><span class="line">	</span><br><span class="line">	CSon son;</span><br><span class="line">	//子类和父类有同名的成员，使用类名::进行区分</span><br><span class="line">	cout&lt;&lt;son.m_money&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;son.CFather::m_money&lt;&lt;endl;</span><br><span class="line">	//定义子类对象，包含父类成员，内存分布，先父类成员，再子类成员</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h5><p>将一些功能相似的类的公共成员，单独抽离出来，形成一个类，这个类就是父类，子类继承父类，包含了这些公共的成员，提高了程序代码的复用性、扩展性、后期更容易维护</p>
<h5 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h5><p>继承方式：描述了父类成员在子类中表现的属性</p>
<p>public：共有继承：</p>
<p>父类			   子类</p>
<p>public			public</p>
<p>protected		protected</p>
<p>private			不可访问</p>
<p>protected：保护继承</p>
<p>父类			   子类</p>
<p>public			protected</p>
<p>protected		protected</p>
<p>private			不可访问</p>
<p>private：私有继承</p>
<p>父类			   子类</p>
<p>public			private</p>
<p>protected		private</p>
<p>private			不可访问</p>
<h5 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h5><p>父类与子类有同名的成员，是允许的，默认调用子类</p>
<h5 id="类成员函数指针"><a href="#类成员函数指针" class="headerlink" title="类成员函数指针"></a>类成员函数指针</h5><p>在继承下，允许未经转换，父类的指针指向子类的对象</p>
<p>好处：统一多种类型，提高复用性、扩展性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	void cost(int a)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CFather::cost&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CSon: public CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	void eat()&#123;</span><br><span class="line">		cout&lt;&lt;CSon::eat&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类成员函数指针：::*C 整体运算符，不可分开，定义类成员函数指针</span><br><span class="line">typedef void (CSon::*P_FUN1)();</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	CSon son;</span><br><span class="line">	CSon *pSon = new CSon;</span><br><span class="line">	</span><br><span class="line">	PFUN1 p_fun1 = &amp;CSon::eat;</span><br><span class="line">	</span><br><span class="line">	(son.*p_fun1)();`//.* , -&gt;*  整体运算符，通过对象调用函数指针指向的函数</span><br><span class="line">	(pSon-&gt;*p_fun1)();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="父类指针要使用子类的成员"><a href="#父类指针要使用子类的成员" class="headerlink" title="父类指针要使用子类的成员"></a>父类指针要使用子类的成员</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	void cost(int a)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CFather::cost&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CSon: public CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	void eat()&#123;</span><br><span class="line">		cout&lt;&lt;CSon::eat&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void show(CFather * fa)&#123;</span><br><span class="line">	fa-&gt;cost();</span><br><span class="line">	</span><br><span class="line">	//正常情况下，函数参数传入的是父类的指针，所以只能调用父类的函数</span><br><span class="line">	//那么怎么调用子类的函数呢  这就要用到【函数指针】</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//类成员函数指针：::*C 整体运算符，不可分开，定义类成员函数指针</span><br><span class="line">typedef void (CFather::*P_FUN)();</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CFather * pFa = new CSon;</span><br><span class="line">	</span><br><span class="line">	P_FUN p_fun = (p_FUN)&amp;CSon::show;</span><br><span class="line">	(pFa-&gt;*p_fun)();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class CCalculate&#123;</span><br><span class="line">public:</span><br><span class="line">	CCalculate()&#123;</span><br><span class="line">		p_fun[add] = &amp;CCalculate::Add;</span><br><span class="line">		p_fun[sub] = &amp;CCalculate::Sub;</span><br><span class="line">		p_fun[mul] = &amp;CCalculate::Mul;</span><br><span class="line">		p_fun[div] = &amp;CCalculate::Div;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	enum cal_symbol&#123;//计算标识</span><br><span class="line">		add = 0,</span><br><span class="line">		sub,</span><br><span class="line">		mul,</span><br><span class="line">		div</span><br><span class="line">	&#125;;</span><br><span class="line">private:</span><br><span class="line">	int (CCalculate::*p_fun[4])(int ,int );</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	int Add(int a,int b)&#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	int Sub(int a,int b)&#123;</span><br><span class="line">		return a-b;</span><br><span class="line">	&#125;</span><br><span class="line">	int Mul(int a,int b)&#123;</span><br><span class="line">		return a*b;</span><br><span class="line">	&#125;</span><br><span class="line">	int Div(int a,int b)&#123;</span><br><span class="line">		return a/b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">public:</span><br><span class="line">	int fun_calculate(cal_symbol sym,int a,int b)&#123;</span><br><span class="line">		return (this-&gt;*p_fun[sym])(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CCalculate cal;</span><br><span class="line">	int res = cal.fun_calculate(CCalculate::add,10,20);</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态：相同的行为方式导致了不同的行为结果，同一行语句展现了多种不同的表现形态，多态性</p>
<p>在继承下，父类的指针可以指向任何继承于该类的子类，多种子类具有多种形态由父类的指针进行统一管理</p>
<p>父类的指针具有多种形态</p>
<h5 id="多态形成条件："><a href="#多态形成条件：" class="headerlink" title="多态形成条件："></a>多态形成条件：</h5><blockquote>
<p>1.有继承关系，存在父类-子类</p>
<p>2.用父类的指针指向子类的对象</p>
<p>3.父类中存在<strong>虚函数</strong>，子类<strong>重写</strong>父类的虚函数</p>
</blockquote>
<p>virtual：虚函数的关键字</p>
<p>重写：子类定义了和父类一模一样（函数名、参数列表、返回值）的虚函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	void show_fa()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;show_fa&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void show()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CFather::show_&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CSon:public CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void show()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CSon::show_&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CFather *p_fa = new CSon;</span><br><span class="line">	p_fa-&gt;show_fa();</span><br><span class="line">	</span><br><span class="line">	p_fa-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">_vfptr：属于对象的，（虚函数指针）类型  void**(二级指针)指向了一个数组（虚函数列表）,当类中存在任意虚函数时，定义对象会在内存空间的【前面】多分配指针的空间（即vfptr的空间），</span><br><span class="line">执行构造函数，在初始化参数列表中进行初始化，指向了__vftable</span><br><span class="line">多个对象会存在多份_vfptr，指向了同一个__vftable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__vftable:虚函数列表，数组的每个元素是指针，指向虚函数的指针，属于类，在编译期自动创建</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CTest&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void show()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;virtual show&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	virtual void play()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;virtual play&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;sizeof(CTest)&lt;&lt;endl;	//4</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用虚函数的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到对象内存空间的_vfptr，通过_vfptr找到虚函数列表，定位虚函数列表中的函数指针，通过指针调用具体的虚函数</span><br></pre></td></tr></table></figure>

<p>虚函数和普通函数的区别</p>
<blockquote>
<p>1.虚函数背后的调用流程不同，虚函数调用效率比普通函数低</p>
<p>2.使用场景不同，虚函数实现多态，普通函数不能实现多态</p>
</blockquote>
<h5 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h5><p>继承下：虚函数指针指向了 创建对象的类的虚函数列表，子类不但继承了父类的成员</p>
<p>还继承了父类的虚函数列表，子类会检查是否有重写父类的虚函数，如果有会将父类的虚函数地址替换掉</p>
<p>这个动作叫覆盖，如果没有，会保留父类的虚函数，如果子类单独有自己的虚函数，会在虚函数列表结尾依次添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void show()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CFather::show_son&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CSon:public CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void show()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CSon::show_son&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CFather *p_fa = new CSon;</span><br><span class="line">	p_fa-&gt;show_fa();</span><br><span class="line">	</span><br><span class="line">	p_fa-&gt;show_son();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造析构顺序"><a href="#构造析构顺序" class="headerlink" title="构造析构顺序"></a>构造析构顺序</h5><p>调用类析构取决于指针的类型</p>
<p>虚析构函数：为了避免内存泄漏，当子类中会有指针成员变量时会用到</p>
<p>虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，防止内存泄漏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	CFather()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CFther&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual ~CFather()&#123;	//虚析构，发生了多态</span><br><span class="line">		cout&lt;&lt;&quot;~~~~CFather&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CSon:public CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	CSon()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CSon&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~CSon()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;CSon&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void show(CFather *p_fa)</span><br><span class="line">&#123;</span><br><span class="line">	delete p_fa;//调用类取决于指针的类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CFather *p_fa = new CSon;</span><br><span class="line">	show(p_fa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多态的缺点"><a href="#多态的缺点" class="headerlink" title="多态的缺点"></a>多态的缺点</h5><blockquote>
<p>1.空间问题：虚函数指针在每个对象中都会存在一份，虚函数列表每个类存在一份</p>
<p>2.效率问题</p>
<p>3.安全性问题</p>
</blockquote>
<h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//抽象类：包含纯虚函数的类称为抽象类，不能定义对象</span><br><span class="line">class CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void show() = 0;//纯虚函数,只声明，不用实现，最终的子类一定要定义实现纯虚函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//具体类</span><br><span class="line">class CSon:public CFather&#123;</span><br><span class="line">public:</span><br><span class="line">	void show()override&#123;	//override：要求当前这个函数一定是重写父类的虚函数</span><br><span class="line">		cout&lt;&lt;&quot;CSon::show&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="程序生成过程"><a href="#程序生成过程" class="headerlink" title="程序生成过程"></a>程序生成过程</h3><p>生成过程</p>
<blockquote>
<p>1.预处理：.i文件</p>
<p>头文件的展开</p>
<p>宏的替换</p>
<p>预处理指令解析  #define   ，#if     #ifdef      #else   #elif   #endif</p>
<p>去掉注释</p>
<p>2.编译：预处理后的文件  生成汇编文件  .asm（汇编代码）</p>
<p>词法解析、语法解析、语义分析、优化</p>
<p>3.汇编：汇编文件进一步处理 ，生成目标机器指令（二进制文件.obj）</p>
<p>4.链接：将多个目标文件（库文件）链接生成可执行程序（.exe，.out）</p>
</blockquote>
<h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//替换作用</span><br><span class="line">#define AA 10</span><br><span class="line"></span><br><span class="line">/*  反斜杠\:连接当前行和下一行，最后一行一般不加\ ，后面不要有任何字符（空格、tab、注释）   */</span><br><span class="line">#define BB for(int i=0;i&lt;AA;i++)&#123;\</span><br><span class="line">	cout&lt;&lt;i&lt;&lt;endl;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//宏可以带参数：替换作用，不会做表达式的计算和求解</span><br><span class="line">#define CC(NUM) for(int i=0;i&lt;NUM;i++)&#123;\</span><br><span class="line">	cout&lt;&lt;i&lt;&lt;endl;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  ## 拼接</span><br><span class="line">#define DD()\</span><br><span class="line">	int a##b = 20;</span><br><span class="line">	</span><br><span class="line">//#：将参数转成字符串，相当于加双引号</span><br><span class="line">#define FF(PARAM)\</span><br><span class="line">	cout&lt;&lt;#PARAM&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">//#@：转成字符，相当于加单引号</span><br><span class="line">#define GG(PARAM)\</span><br><span class="line">	char a = #@PARAM;</span><br></pre></td></tr></table></figure>

<h4 id="operator重载"><a href="#operator重载" class="headerlink" title="operator重载"></a>operator重载</h4><p>重载操作符operator：在程序中与到这个符号，通过调用当前重载操作符函数来行使操作符的功能</p>
<p>一般有返回值，为了和后序的操作符继续操作</p>
<p>匹配操作符 根据 重载操作符函数的参数的类型、顺序、数量</p>
<p>分  类内、类外重载</p>
<p>类内重载：this，作为类成员函数的第一个参数，通过当前类对象去调用，一般在操作符的左边，可以手动显式的调用参数</p>
<p>类外：注意参数列表的顺序，必须包含自定义类型（类、结构体），有可能和类内重载的函数有冲突</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class CTest2&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_b;</span><br><span class="line">	CTest2()&#123;</span><br><span class="line">		m_b=5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CTest&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_a;</span><br><span class="line">	CTest()&#123;</span><br><span class="line">		m_a = 10;</span><br><span class="line">	&#125;</span><br><span class="line">	int operator+(/* CTest * const this */int a)&#123;//先指向类的对象，然后是参数，使用时要严格按照这</span><br><span class="line">												//定义的顺序,类内定义的重载操作符函数顺序不能改变</span><br><span class="line">		return this-&gt;m_a+a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int operator+=(int a)&#123;</span><br><span class="line">		return m_a+=a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int operator-(CTest2 &amp;tst2)&#123;</span><br><span class="line">		return m_a - tst2.m_b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int operator =(int a)&#123;</span><br><span class="line">		m_a = a;</span><br><span class="line">		return m_a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int operator++()&#123;//默认为左++</span><br><span class="line">		return ++m_a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int operator++(int)&#123;//右++,参数没有任何意义，就是为了区分左++，还是右++</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//-------------------------类外</span><br><span class="line">int operator+(int a,CTest &amp;tst)&#123;</span><br><span class="line">	return a + tst.m_a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int operator+(int a,int b)&#123;</span><br><span class="line">	//对于这种基本类型的重载有内置规则，不要自己定义</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;os,CTest &amp;tst)&#123;</span><br><span class="line">	os&lt;&lt;tst.m_a;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; operator&lt;&lt;(istream &amp;is,CTest &amp;tst)&#123;</span><br><span class="line">	is&gt;&gt;tst.m_a;</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CTest tst;</span><br><span class="line">	CTest tst2;</span><br><span class="line">	cout&lt;&lt;tst2+(tst+20)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><blockquote>
<p>对于同一个操作符，指定不同的参数、顺序、数量，都有可能产生不同的含义</p>
<p>参数的类型、顺序、数量都有一定的约束</p>
<p>重载操作符函数 参数不能有默认值，不能改变操作符的使用规则，原来双目对应两个操作数</p>
<p>不能改变操作符的优先级    和    结合性</p>
<p>有些操作符  只能在类内重载：operator&#x3D;，-&gt;，[]，()</p>
<p>不能重载的操作符【sizeof】、【?：】，【：：】【.】</p>
<p>不能创建新的操作符</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class CTest&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_a;</span><br><span class="line">	CTest()&#123;</span><br><span class="line">		m_a = 10;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int operator*(int a)&#123;//乘法</span><br><span class="line">		return m_a*a;</span><br><span class="line">	&#125;</span><br><span class="line">	int operator*()&#123;//间接引用</span><br><span class="line">		return m_a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CTest tst;</span><br><span class="line">	*tst;		//tst.m_a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class CTest&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_a;</span><br><span class="line">	int *m_p;</span><br><span class="line">	CTest()&#123;</span><br><span class="line">		m_a=10;</span><br><span class="line">		m_p = nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	int operator+(int a)&#123;//重载操作符</span><br><span class="line">		return m_a+a;</span><br><span class="line">	&#125;</span><br><span class="line">	operator int()&#123;//重载int类型,允许和重载操作符同时存在，但优先级低于重载操作符</span><br><span class="line">		cout&lt;&lt;&quot;operator int&quot;&lt;&lt;endl;</span><br><span class="line">		return this-&gt;m_a;</span><br><span class="line">	&#125;</span><br><span class="line">	operator bool()&#123;</span><br><span class="line">		cout&lt;&lt;&quot;operator bool&quot;&lt;&lt;endl;</span><br><span class="line">		return m_p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int operator+(int a,CTest &amp;tst)&#123;</span><br><span class="line">	cout&lt;&lt;&quot;operator+&quot;&lt;&lt;endl;</span><br><span class="line">	return tst.m_a +a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CTest tst;</span><br><span class="line">	10+tst;//想让tst这个对象能像int类型一样去使用就需要重载类型</span><br><span class="line">	//--------------</span><br><span class="line">	</span><br><span class="line">	if(tst.m_p)&#123;</span><br><span class="line">		cout&lt;&lt;*tst.m_p&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(tst)&#123;</span><br><span class="line">		cout&lt;&lt;tst.m_p&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1670832832306.png" alt="1670832832306"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1670832877588.png" alt="1670832877588"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1670832935365.png" alt="1670832935365"></p>
<h3 id="list-map"><a href="#list-map" class="headerlink" title="list-map"></a>list-map</h3><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>iteator  迭代器：遍历容器（list）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;algorithm&gt;	//该头文件包含了查找、排序等很多方法</span><br><span class="line"></span><br><span class="line">voif show(int v)&#123;</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;&quot;   &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	list&lt;int&gt; lst;		//定义链表</span><br><span class="line">	lst.push_back(1);</span><br><span class="line">	lst.push_back(2);</span><br><span class="line">	lst.push_back(3);</span><br><span class="line">	</span><br><span class="line">	lst.push_front(3);		//头添加</span><br><span class="line">	lst.push_front(2);</span><br><span class="line">	lst.push_front(1);</span><br><span class="line">	</span><br><span class="line">	list&lt;int&gt;::iterator ite;		//定义迭代器</span><br><span class="line">	ite =  lst.begin();			//返回头结点迭代器</span><br><span class="line">	</span><br><span class="line">	while(ite!=lst.end())&#123;		//end()  尾结点迭代器</span><br><span class="line">		cout&lt;&lt;*ite&lt;&lt;&quot;   &quot;&lt;&lt;endl;</span><br><span class="line">		ite++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	lst.pop_back();//尾删除</span><br><span class="line">	lst.pop_front();//头删除</span><br><span class="line">	</span><br><span class="line">	for(int val:lst)&#123;		//增强for循环</span><br><span class="line">		cout&lt;&lt;val&lt;&lt;&quot;   &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//返回头尾结点里的值</span><br><span class="line">	cout&lt;&lt;lst.front()&lt;&lt;&quot;   &quot;&lt;&lt;lst.back()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;&quot;链表的长度：&quot;&lt;&lt;lst.size()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//判断链表是否为空</span><br><span class="line">	if(lst.empty())&#123;</span><br><span class="line">		cout&lt;&lt;&quot;is empty&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;not is empty&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//--------------------------------</span><br><span class="line">	//在链表中间插入结点</span><br><span class="line">	ite = ++lst.begin();</span><br><span class="line">	list&lt;int &gt;::iterator ite2 = lst.insert(ite,10);//在迭代器指向的结点之前插入，返回插入的结点的													//迭代器</span><br><span class="line">	cout&lt;&lt;*ite2&lt;&lt;endl;</span><br><span class="line">	for(int val:lst)&#123;		//增强for循环</span><br><span class="line">		cout&lt;&lt;val&lt;&lt;&quot;   &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//-------------------------</span><br><span class="line">	//删除链表中间的结点</span><br><span class="line">	ite = ++lst.begin();</span><br><span class="line">	//删除  迭代器指向结点，该迭代器将失效（可以接返回值）</span><br><span class="line">	list&lt;int &gt;::iterator ite3 = lst.erase(ite);//在迭代器指向的结点之前插入，返回插入的结点的													//迭代器</span><br><span class="line">	cout&lt;&lt;*ite3&lt;&lt;endl;		//返回删除节点的后一个结点的迭代器</span><br><span class="line">	for(int val:lst)&#123;		//增强for循环</span><br><span class="line">		cout&lt;&lt;val&lt;&lt;&quot;   &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//------------------------------</span><br><span class="line">	//遍历函数</span><br><span class="line">	::for_each(lst.begin(),lst.end(),&amp;show);</span><br><span class="line">	</span><br><span class="line">	//--------------------------------</span><br><span class="line">	//输出头结点和尾结点</span><br><span class="line">	cout&lt;&lt;*lst.begin()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;*(--lst.end())&lt;&lt;endl;//ite.end()指向的是一个无效地址，前一位才是真正的有效的尾结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map：映射表    key -value键值对</p>
<p>排序规则:根据键值自动排序，要求键值不能重复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;map&gt;</span><br><span class="line"></span><br><span class="line">void show(pair&lt;int,string&gt; pr)&#123;</span><br><span class="line">	cout&lt;&lt;pr.first&lt;&lt;&quot;   &quot;&lt;&lt;pr.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//键值，实值</span><br><span class="line">	map&lt;int,string&gt;  mm;</span><br><span class="line">	</span><br><span class="line">	mm[2] = &quot;asd&quot;;</span><br><span class="line">	mm[1] = &quot;lklkskld&quot;;</span><br><span class="line">	mm[3] = &quot;ocwk&quot;;</span><br><span class="line">	</span><br><span class="line">	//插入结点</span><br><span class="line">	pair&lt;int,string&gt; pr(4,&quot;oire&quot;);	//创建键值对</span><br><span class="line">	mm.insert(pr);</span><br><span class="line">	</span><br><span class="line">	//遍历</span><br><span class="line">	map&lt;int,string&gt;::iterator ite = mm.begin();</span><br><span class="line">	while(ite != mm.end())&#123;</span><br><span class="line">		cout&lt;&lt;(*ite).first&lt;&lt;&quot;   &quot;&lt;&lt;ite-&gt;second&lt;&lt;endl;</span><br><span class="line">		ite++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//--------------------------</span><br><span class="line">	//删除键值对</span><br><span class="line">	ite = ++mm.begin();</span><br><span class="line">	mm.erase(ite);</span><br><span class="line">	cout&lt;&lt;ite-&gt;first&lt;&lt;&quot;   &quot;&lt;&lt;ite-&gt;second&lt;&lt;endl;</span><br><span class="line">	while(ite != mm.end())&#123;</span><br><span class="line">		cout&lt;&lt;(*ite).first&lt;&lt;&quot;   &quot;&lt;&lt;ite-&gt;second&lt;&lt;endl;</span><br><span class="line">		ite++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//---------------------------------</span><br><span class="line">	cout&lt;&lt;mm.size()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;mm.empty()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//------------------------------------</span><br><span class="line">	//遍历1</span><br><span class="line">	for(pair&lt;int,string&gt; prr:mm)&#123;</span><br><span class="line">		cout&lt;&lt;prr.first&lt;&lt;&quot;  &quot;&lt;&lt;prr.second&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	//遍历2</span><br><span class="line">	for_each(mm.begin(),mm.end(),&amp;show);cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	mm[3] = &quot;safohnev&quot;;//键值已经存在，修改实值</span><br><span class="line">	</span><br><span class="line">	//--------------------------------</span><br><span class="line">	//插入成功返回true,失败返回false</span><br><span class="line">	pair&lt; map&lt;int,string&gt;::iterator , bool&gt; ret =  mm.insert(pair&lt;int,string&gt;(3,&quot;123&quot;));</span><br><span class="line">	if(ret.second)&#123;//判断插入成功还是失败</span><br><span class="line">		cout&lt;&lt;&quot;插入成功&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;ret.first-&gt;first&lt;&lt;&quot;   &quot;&lt;&lt;ret.second-&gt;second&lt;&lt;endl;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;插入失败&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//---------------------</span><br><span class="line">	//按照key值查找</span><br><span class="line">	ite = mm.find(5);</span><br><span class="line">	if(ite!=mm.end())&#123;</span><br><span class="line">		cout&lt;&lt;ite-&gt;first&lt;&lt;&quot;  &quot;&lt;&lt;ite-&gt;second&lt;&lt;endl;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;没找到&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;mm.count(7)&lt;&lt;endl;//按照key统计个数（可用于判断键值是否存在）</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>空类中编译器会给提供一个默认的拷贝构造函数，参数为当前类对象的引用，函数体代码不为空，参数中对象甲的成员给this甲的成员一一初始化</p>
<p>一旦我们手动重构拷贝构造函数，编译器就不会提供默认的了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class CTest&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_a;</span><br><span class="line">	int *m_p;</span><br><span class="line">public:</span><br><span class="line">	CTest()&#123;</span><br><span class="line">		m_a = 100;</span><br><span class="line">		m_p = new int(20);</span><br><span class="line">	&#125;</span><br><span class="line">	CTest(const CTest &amp; tst)&#123;</span><br><span class="line">		this-&gt;m_a = tst.m_a;</span><br><span class="line">		if(tst.m_p)&#123;//实现深拷贝</span><br><span class="line">			this-&gt;m_p = new int(*tst.m_p);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			this-&gt;m_p = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~CTest()&#123;</span><br><span class="line">		if(m_p)&#123;</span><br><span class="line">			delete m_p;</span><br><span class="line">			m_p = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CTest tst1;</span><br><span class="line">	CTest tst2(tst1);//调用拷贝构造函数</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="浅拷贝问题"><a href="#浅拷贝问题" class="headerlink" title="浅拷贝问题"></a>浅拷贝问题</h4><p>编译器默认给提供拷贝构造，是一个浅拷贝</p>
<blockquote>
<p>1.当类中有指针成员且new了空间，会导致同一块空间被回收多次，程序崩溃</p>
<p>2.当类中有指针成员且new了空间，当用一个对象修改指针指向空间的值，其他对象使用的是修改之后的值，导致程序逻辑错误</p>
</blockquote>
<p>解决浅拷贝问题</p>
<blockquote>
<p>1.需要手动重构拷贝构造函数，实现一个深拷贝（为里面的指针成员单独开辟一块空间，并将指针里的值传递过来</p>
<p>2.避免浅拷贝的发生，函数参数尽量使用引用或指针</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-平淡的西瓜" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/01/31/%E5%B9%B3%E6%B7%A1%E7%9A%84%E8%A5%BF%E7%93%9C/" class="article-date">
      <time datetime="2023-01-31T02:47:53.000Z" itemprop="datePublished">2023-01-31</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/%E5%B9%B3%E6%B7%A1%E7%9A%84%E8%A5%BF%E7%93%9C/">平淡的西瓜</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/26/hello-world/" class="article-date">
      <time datetime="2022-09-26T07:31:36.822Z" itemprop="datePublished">2022-09-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2023 蔡胖子
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>