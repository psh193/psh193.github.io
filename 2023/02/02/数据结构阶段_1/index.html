<!DOCTYPE html>
<html lang="en">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="蔡胖子" />



<meta name="description" content="[TOC] 时间复杂度：为了解决问题，代码的总执行次数 运算：  1.舍弃掉计算结果中的常数项 2.多项式级别的运算，只保留最大项 3.如果当前的算法在 的资源消耗内即可完成。复杂度为O(1)  经验性结论： 1.单纯的顺序结构或选择结构，时间复杂度都是O(1) 2.一个简单的循环结构一般情况下时间复杂度是O(n) 3.一般情况下，两层 循环嵌套，时间复杂度是O(n^2) 4.采用二分的分治法，时">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构笔记">
<meta property="og:url" content="http://example.com/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/index.html">
<meta property="og:site_name" content="蔡胖子">
<meta property="og:description" content="[TOC] 时间复杂度：为了解决问题，代码的总执行次数 运算：  1.舍弃掉计算结果中的常数项 2.多项式级别的运算，只保留最大项 3.如果当前的算法在 的资源消耗内即可完成。复杂度为O(1)  经验性结论： 1.单纯的顺序结构或选择结构，时间复杂度都是O(1) 2.一个简单的循环结构一般情况下时间复杂度是O(n) 3.一般情况下，两层 循环嵌套，时间复杂度是O(n^2) 4.采用二分的分治法，时">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658213184731.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658212623728.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658214129313.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658815809784.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658815907537.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658821706891.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668600031375.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668600976682.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668601548436.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668770833339.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671346305079.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674543867540.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671351850651.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674559930857.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674561559858.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669030359455.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668169187719.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668165014035.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668165498658.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668168217604.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669373013840.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669376074829.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669376074912.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669378935451.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669631235050.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669632962420.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669633762419.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669720112896.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669720990171.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669722186568.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ebceaf5850d24e98ab98fcb443e0a775.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/be8b84f80a3a4decbb8f3f360828a855.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a106294aec474249b5868beffd82f112.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/bb5cf62d3bde4e40839fcdad4d692575.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671264272302.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674642041271.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674632474001.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674821731882.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674820003348.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893373496.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893407903.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893428956.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674906000237.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674908927263.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674907940748.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674983264886.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675164219988.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675321702785.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675337723859.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675344373357.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675347696332.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675214291252.png">
<meta property="article:published_time" content="2023-02-02T14:33:55.000Z">
<meta property="article:modified_time" content="2023-02-02T14:36:59.428Z">
<meta property="article:author" content="蔡胖子">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658213184731.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="蔡胖子" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">




<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>数据结构笔记 | 蔡胖子</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/caicai.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:2195361512@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="/psh193" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" href="/qq_52464789" title="CSDN"></a>
                            
                                <a class="fa QQ" href="/2195361512" title="QQ"></a>
                            
                                <a class="fa 微信" href="/pshlpjswaxx" title="微信"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/caicai.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:2195361512@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="/psh193" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="/qq_52464789" title="CSDN"></a>
                            
                                <a class="fa QQ" target="_blank" href="/2195361512" title="QQ"></a>
                            
                                <a class="fa 微信" target="_blank" href="/pshlpjswaxx" title="微信"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap"><article id="post-数据结构阶段_1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/" class="article-date">
      <time datetime="2023-02-02T14:33:55.000Z" itemprop="datePublished">2023-02-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数据结构笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>[TOC]</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>：为了解决问题，代码的总执行次数</p>
<p>运算：</p>
<blockquote>
<p>1.舍弃掉计算结果中的常数项</p>
<p>2.多项式级别的运算，只保留最大项</p>
<p>3.如果当前的算法在</p>
<p>的资源消耗内即可完成。复杂度为O(1)</p>
</blockquote>
<h4 id="经验性结论："><a href="#经验性结论：" class="headerlink" title="经验性结论："></a>经验性结论：</h4><blockquote>
<p>1.单纯的顺序结构或选择结构，时间复杂度都是O(1)</p>
<p>2.一个简单的循环结构一般情况下时间复杂度是O(n)</p>
<p>3.一般情况下，两层 循环嵌套，时间复杂度是O(n^2)</p>
<p>4.采用二分的分治法，时间复杂度是log2(n)</p>
<p>5.会采用分治、递归、动态规划等算法用空间换取时间效率</p>
<p>6.两个顺序执行的循环，时间消耗取二者里的大值O(max(m,n))</p>
</blockquote>
<p>简单的循环结构的特殊情况下：</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658213184731.png" alt="1658213184731"></p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>：为了解决问题额外消耗的空间</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658212623728.png" alt="1658212623728"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658214129313.png" alt="1658214129313"></p>
<p>结构</p>
<h4 id="线性结构："><a href="#线性结构：" class="headerlink" title="线性结构："></a>线性结构：</h4><p>一对一结构</p>
<p>链式存储（链表）：</p>
<p>顺序存储（数组）：</p>
<h5 id="数组：空间连续，类型相同"><a href="#数组：空间连续，类型相同" class="headerlink" title="数组：空间连续，类型相同"></a>数组：空间连续，类型相同</h5><blockquote>
<p>1.基于索引的查询速度快，O(1)</p>
<p>2.对无序数组的数值搜索，O(n)</p>
<p>3.对于有序数组的数值搜索，O(log2(n))</p>
<p>4.在数组空间足够的前提下：</p>
<p>尾添加：O(1)    尾删除：O(1)</p>
<p>头添加、头删除、中间添加、中间删除，O(n)</p>
<p>空间不够：</p>
<p>添加：添加元素需要进行空间申请，及原有数据的拷贝，O(n)</p>
<p>删除：尾删除O(1)，中间删除、头删除：O(n)</p>
</blockquote>
<p>对一个地址进行加减就是偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">*(&amp;a + 1) = ? //得到的是乱码</span><br><span class="line">//&amp;a得到的是整个数组的地址，虽然整个数组的首地址跟首元素的首地址值是一样的，但是表达的意义是不一样的</span><br><span class="line">//对地址进行加减是对地址进行偏移量</span><br><span class="line">//所以&amp;a + 1就是偏移一个数组这么大，指针取不到，因为已经超过了数组的范围，所以得到的是乱码</span><br></pre></td></tr></table></figure>

<p>例题：一个有n个元素的数组，每个元素的值范围在0~n-1之间。检测数据是否重复出现，若重复出现，则当前组数据时坏数据</p>
<h5 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h5><blockquote>
<p>1.存储方式：数组时顺序存储，链表是链式存储</p>
<p>2.内存分配方式：数组静态分配，链表动态分配</p>
<p>3.存取方式：数组元素直接存取，链表元素要遍历链表</p>
<p>4.插入和删除方式：数组需要移动组内元素，链表不需要移动</p>
</blockquote>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><blockquote>
<p>1.链表搜索，O(n)</p>
<p>2.链表添加：</p>
<p>头添加、头删除：O(1)，数据按照添加顺序倒序</p>
<p>中间添加、删除、尾添加、尾删除：O(n)</p>
<p>ps：最常用的是尾添加，头添加会出现逆序的情况</p>
</blockquote>
<h5 id="单链表倒置："><a href="#单链表倒置：" class="headerlink" title="单链表倒置："></a>单链表倒置：</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658815809784.png" alt="1658815809784"></p>
<blockquote>
<p>1.头插法：建立三个指针，用指针1指向空，指针2和3分别指向A和B，断开A和B之间的指针，   让B指向A，然后将三个指针分别向后移动一位。时间复杂度O(n),空间复杂度O(1)</p>
<p>2.栈：入栈再出栈。时间复杂度：O(n),空间复杂度O(n)</p>
<p>3.暴力解法：遍历链表找到E，再遍历链表找到D,让E指向D，依次遍历。时间复杂度：O(n^2),空间复杂度O(1)</p>
</blockquote>
<h5 id="链表重置："><a href="#链表重置：" class="headerlink" title="链表重置："></a>链表重置：</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658815907537.png" alt="1658815907537"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//分三个步骤</span><br><span class="line">//1.找到链表的中间结点</span><br><span class="line">//2.由中间结点为分隔点，将后半链表倒置</span><br><span class="line">//3.在第一条链表的基础上，在每一个结点的后面都插入第二条链表的一个结点</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1658821706891.png" alt="1658821706891"></p>
<blockquote>
<p>1.head tail</p>
<p>2.处理</p>
<p>（1）比较L1，L2</p>
<p>（2）小的尾添加到newlist</p>
<p>（3）继续（1）（2）</p>
<p>（4）将有剩余的list添加到newList</p>
</blockquote>
<h5 id="单链表相交问题"><a href="#单链表相交问题" class="headerlink" title="单链表相交问题"></a>单链表相交问题</h5><p>方法：</p>
<blockquote>
<p>1.判断末尾结点是否相同</p>
<p>2.将两条链表入栈，判断出栈结点是否相同，当出栈结点不同时，那么下一个出栈的结点就是交点</p>
<p>3.数学方法：遍历，让长的那条链表先走完两条链表长度的差值，然后一起走同时比较</p>
</blockquote>
<h5 id="循环链表的特性"><a href="#循环链表的特性" class="headerlink" title="循环链表的特性"></a>循环链表的特性</h5><blockquote>
<p>从环上任意一点出发均能遍历整个链表</p>
</blockquote>
<h5 id="判断单链表是否有环，如果有环的话，找到环的入口节点"><a href="#判断单链表是否有环，如果有环的话，找到环的入口节点" class="headerlink" title="判断单链表是否有环，如果有环的话，找到环的入口节点"></a>判断单链表是否有环，如果有环的话，找到环的入口节点</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668600031375.png" alt="1668600031375"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668600976682.png" alt="1668600976682"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668601548436.png" alt="1668601548436"></p>
<blockquote>
<p>快慢指针，慢指针一次走一步，快指针一次走两步，快慢指针一定会在环上相遇</p>
<p>（1）断开：在快慢指针相遇的结点断开，就变成了单链表找相交结点问题</p>
<p>（2）倍数：假设两个指针在c点相遇，那么满指针走了a+b，快指针走了a+b+k(b+c)（假设快指针在还上走了k圈），两者相等得出a&#x3D;c+(k-1)(b+c)，让慢指针回到头结点，此时快慢指针都走一步，走c那么长，此时快指针走到B点也就是入口节点，二者继续走相遇的点就是入口结点</p>
<p>（3）环长：两个指针在环上相遇，一个指针不动，让另一个指针在环上走一圈记录长度就是环长x，然后两个指针回到起始结点，二号指针先走x步，两个指针再一起走，相遇的点就是入口结点</p>
</blockquote>
<h5 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h5><blockquote>
<p>1.在原结点后面复制一个新的结点</p>
<p>2.复制结点的随机指针指向原结点随机指针的下一个</p>
<p>3.分离原结点和复制后的结点链表</p>
</blockquote>
<h4 id="哈希表HashTable"><a href="#哈希表HashTable" class="headerlink" title="哈希表HashTable"></a>哈希表HashTable</h4><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668770833339.png" alt="1668770833339"></p>
<blockquote>
<p>1.定散列函数：</p>
<p>求整取余&#x2F;留存取余：P &#x3D; key % M。将数据通过取余分成不同的组用数组存起来，此时数组是指针数组</p>
<p>2.定解决哈希冲突的办法</p>
<p>开放地址法：（1）线性探测：发生冲突后依次查看当前地址后面有没有空位，有空位则将冲突元素放在空位</p>
<p>​						（2）二次探测：以一个不断变化的步长寻找有没有空位</p>
<p>拉链法：发生冲突的组内元素用链表连接起来，并将单链表的头结点存到对应的单元中</p>
</blockquote>
<p>哈希表的创建</p>
<blockquote>
<p>1.定义结构体：数据，next</p>
<p>2.定义结构体类型指针数组，将数组赋空值</p>
<p>3.当前数据取余m值，将当前数据添加到对应组中去（头插）</p>
</blockquote>
<p>哈希表的弊端</p>
<blockquote>
<p>1.空间消耗大</p>
<p>2.需要一次把所有数据都加载进来</p>
</blockquote>
<h4 id="回溯法（BackTracking）"><a href="#回溯法（BackTracking）" class="headerlink" title="回溯法（BackTracking）"></a>回溯法（BackTracking）</h4><p>回溯法，又叫试探法，是一种寻找<strong>最优解</strong>的<strong>暴力搜寻法。</strong>但是，由于暴力，回溯法的**时*间复杂度较高***，因此在比较一些数字较大的问题时，比如最短路径问题等，运行时间一般比较长。 </p>
<p>在1、2、3、4中找到长度为2的集合，可以以1或2或3为开头</p>
<p>以1位开头，待选为2、3、4，首先选择2，组成集合【1，2】，符合要求，然后放弃2，再选择3，组成【1,3】，符合要求，然后放弃3，再选择4，组成【1,4】，符合要求，然后放弃4。</p>
<p>以1为开头的选择已经耗尽，然后放弃1，选择2，待选为3、4。。。。这样循环下去</p>
<p>回溯法纵向是一个递归的过程，横向是一个循环的过程</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671346305079.png" alt="1671346305079"></p>
<h5 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h5><blockquote>
<p>1.组合问题（无序）</p>
<p>2.分割问题（字符串分割成子串）</p>
<p>3.子集问题（求一个数组的全部子集）</p>
<p>4.排列问题（有序）</p>
<p>5.棋盘问题、迷宫问题</p>
</blockquote>
<h5 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">用传出参数或全局变量收集结果，而不是用返回值</span><br><span class="line">//一定要分成横纵两个方面思考回溯</span><br><span class="line">void backtracking(参数) &#123;//根据数据的不同选择的参数类型也不同</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;//注意i=0,i=start的区别</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归  注意(i)和(i++)的区别  后面会懂</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h5><p>1.得到所有排列（需要存储空间存储结果）</p>
<p>2.打印所有排列</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674543867540.png" alt="1674543867540"></p>
<p>如果需要保存结果第一步需要申请空间保存</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671351850651.png" alt="1671351850651"></p>
<p>交换法&#x2F;标记法</p>
<p>交换法：从集合中选择一个元素，剩下的元素进行全排列；选择的元素与第一个元素进行交换，得到所有全排列后要还原，回到原始状态</p>
<p>标记法：需要开辟一个新空间，将选择的元素标记存入新空间，接下来从未标记的元素中进行选择，得到排列结果后要撤销标记</p>
<h5 id="全排列代码"><a href="#全排列代码" class="headerlink" title="全排列代码"></a>全排列代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> 1#include&lt;stdio.h&gt;</span><br><span class="line"> 2 </span><br><span class="line"> 3 void Arrange(int arr[],int nLen,int start)</span><br><span class="line"> 4 &#123;</span><br><span class="line"> 5     if(start == nLen)</span><br><span class="line"> 6     &#123;</span><br><span class="line"> 7         int i;</span><br><span class="line"> 8         for(i=0; i&lt;nLen; i++)</span><br><span class="line"> 9         &#123;</span><br><span class="line">10             printf(&quot;%d&quot;,arr[i]);</span><br><span class="line">11         &#125;</span><br><span class="line">12         printf(&quot;\n&quot;);</span><br><span class="line">13         return ;</span><br><span class="line">14     &#125;</span><br><span class="line">15 </span><br><span class="line">16     int i;</span><br><span class="line">17     int temp;</span><br><span class="line">18     for(i=start; i&lt;nLen; i++)</span><br><span class="line">19     &#123;</span><br><span class="line">20         temp = arr[i];</span><br><span class="line">21         arr[i] = arr[start];</span><br><span class="line">22         arr[start] = temp;</span><br><span class="line">23                                                                                                                                                                                   </span><br><span class="line">24         Arrange(arr,nLen,start+1);</span><br><span class="line">25 </span><br><span class="line">26         temp = arr[i];</span><br><span class="line">27         arr[i] = arr[start];</span><br><span class="line">28         arr[start] = temp;</span><br><span class="line">29     &#125;</span><br><span class="line">30 &#125;</span><br><span class="line">31 </span><br><span class="line">32 int main()</span><br><span class="line">33 &#123;</span><br><span class="line">34     int arr[] = &#123;1,2,3&#125;;</span><br><span class="line">35     Arrange(arr,3,0);</span><br><span class="line">36     return 0;</span><br><span class="line">37 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h4><p>题目描述：</p>
<p> 请实现一个函数用来匹配包括’.‘和’<em>‘的正则表达式。模式中的字符’.‘表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。 例如：模式串“aab”,匹配串<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674559930857.png" alt="1674559930857"></p>
<p>解题思路：</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674561559858.png" alt="1674561559858"></p>
<p>首先我们应从模式字符串里进行匹配，并看下一位是否含有*，如果有的话：</p>
<p>判断对应位置的字符是否相等，如果不相等，则模式字符串移动两位（消去），继续匹配<br>如果相等（出现.也算相等)，则可以消去模式字符，也可以不消去，继续递归向后匹配，此处用到回溯（如果*前是0次，则模式串不动，匹配串向后移动两位；如果星号前是1次，则模式串向后移动一位，匹配串向后移动两位；如果星号前是多次，则模式串++，匹配串不动）</p>
<p>如果没有的话两个字符串位置对照进行比较:</p>
<p>如果不相等则匹配不成功（模式字符串里有.算做相等的情况）</p>
<p>如果相等则模式串和匹配串都向后移一位</p>
<h4 id="跳跃列表：SkipList"><a href="#跳跃列表：SkipList" class="headerlink" title="跳跃列表：SkipList"></a>跳跃列表：SkipList</h4><p>基于有序链表：</p>
<p>log2n（增删查）</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669030359455.png" alt="1669030359455"></p>
<p>跳跃列表插入</p>
<blockquote>
<p>1.申请空间表格（指针数组），保存插入数据各层的前一个节点是什么，列表有几层就申请相应层数的空间</p>
<p>2.找到对应插入数据的每层前一个元素是什么并填入表格</p>
<p>3.随机判断每层节点是否存在，如果L1层存在再判断L2是否存在，如果L1层不存在，L2层就不做处理了</p>
<p>4.将生成的节点放入列表中，完成每层节点的连接</p>
</blockquote>
<h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>当前问题能拆解成更小的子问题，子问题除数据规模以外，解决问题的方法与当前问题完全相同，并有明确的终止条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//函数返回值 名字（参数）</span><br><span class="line">//&#123;</span><br><span class="line">	//终点</span><br><span class="line">	//递归主体</span><br><span class="line">//&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h5><p>题意说明<br>一只青蛙可以一次跳 1 级台阶或一次跳 2 级台阶,例如:跳上第一级台阶只有一种跳法:直接跳 1 级即可。跳上两级台阶,有两种跳法: 每次跳 1 级,跳两次; 或者一次跳 2 级.问要跳上第 n 级台阶有多少种跳法?</p>
<p>解题思路<br>我们设台阶数位N;<br>当N&#x3D;1时，当然只有1种跳法；<br>当N&#x3D;2时，青蛙可以跳2次1层和跳1次2层；<br>当N&#x3D;3时，当有3层台阶时，青蛙可以选择先跳1层，剩下2层台阶，所以此时就是有2层台阶时的跳法，有2种；当青蛙选择第一次跳2层台阶时，剩下1层台阶，此时有1层台阶时的跳法，所以3层台阶时的方法是：2层台阶的方法 + 1层台阶的方法。<br>当N&#x3D;4时，具体跳法为: 1、先跳1层 若先跳1层，则剩下3层，接下来就是3层台阶的跳法。 2、先跳2层 若先跳2层，则剩下2层，接下俩就是2层台阶的跳法，所以4层台阶的方法为：3层台阶的方法+2层台阶的方法。</p>
<p>以此类推，当N&#x3D;n时，n层台阶的方法为: n-1层台阶的方法+ n-2 层台阶的方法。</p>
<p>青蛙跳台阶问题：n级台阶第一步跳一节，还剩n-1阶，第一步跳两节还剩n-2阶</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668169187719.png" alt="1668169187719"></p>
<h5 id="斐波那契递归写法："><a href="#斐波那契递归写法：" class="headerlink" title="斐波那契递归写法："></a>斐波那契递归写法：</h5><p>当n超过50时计算时间非常长</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668165014035.png" alt="1668165014035">原因是每个点展开都是一次函数调用，将要调用2的50次方-1的函数，时间消耗大</p>
<p>斐波那契循环写法：</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668165498658.png" alt="1668165498658"></p>
<p>需要三个变量，从3开始算，上一次f(i-1)的值就是下一次f(i-2)的值，上一次f(i)的值就是下一次f(i-1)的值</p>
<p>斐波那契数学方法：</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1668168217604.png" alt="1668168217604"></p>
<h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><blockquote>
<p>1.问题难度随着数据规模缩小而降低（降低）</p>
<p>2.当前问题可拆分成多个解决方法完全相同的小问题（可拆分）</p>
<p>3.子问题的解可合并（可合并）</p>
<p>4.子问题的解相互独立（独立）</p>
</blockquote>
<h5 id="二分查找（折半查找）Binary-Chop：前提：对有序数组进行查找"><a href="#二分查找（折半查找）Binary-Chop：前提：对有序数组进行查找" class="headerlink" title="二分查找（折半查找）Binary Chop：前提：对有序数组进行查找"></a>二分查找（折半查找）Binary Chop：前提：对有序数组进行查找</h5><blockquote>
<p>1.找到中间结点</p>
<p>2.比较</p>
<p>（1）&#x3D;&#x3D;成功返回</p>
<p>（2）Mid &lt; target（右半部分）</p>
<p>（3）Mid &gt; target（左半部分）</p>
</blockquote>
<p>栈（stack）：</p>
<p>堆：需要new获得当前放的什么内容，由程序员决定</p>
<p>字符常量</p>
<p>全局&#x2F;静态：都在一个区域</p>
<p>区别</p>
<blockquote>
<p>1.全局变量可以跨文件引用，静态变量只能局部引用</p>
<p>2.默认初始化为0</p>
<p>3.静态变量赋初值只会执行一次，会在其作用域内保存其值</p>
</blockquote>
<p>代码</p>
<p>堆和栈的区别：</p>
<blockquote>
<ol>
<li></li>
</ol>
<p>2.生命周期不一样</p>
<p>3.生长方向不一样，栈区从高地址向低地址分配</p>
<p>4.堆区不连续，栈区连续，堆区通过链表存放，每查找一个数据需要遍历一遍，效率低</p>
<p>5.只有堆区会产生内部碎片</p>
</blockquote>
<p>例题：如何将n个有序链表合并成一个有序的</p>
<h4 id="栈（stack）：（数据结构栈）FIFO"><a href="#栈（stack）：（数据结构栈）FIFO" class="headerlink" title="栈（stack）：（数据结构栈）FIFO"></a>栈（stack）：（数据结构栈）FIFO</h4><p>push</p>
<blockquote>
<p>1.new下一个新top</p>
<p>2.新Top指向原Top</p>
</blockquote>
<p>pop</p>
<blockquote>
<p>1.原Top &#x3D; 原Top的下一个</p>
<p>2.将原top拿走</p>
</blockquote>
<p>定义：先进后出</p>
<h4 id="队列（FIFO）"><a href="#队列（FIFO）" class="headerlink" title="队列（FIFO）"></a>队列（FIFO）</h4><h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><p>两个栈实现队列（先进先出，push、pop）</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669373013840.png" alt="1669373013840"></p>
<blockquote>
<p>1.s1入栈，s2出栈</p>
<p>2.push：s2非空，将s2中的数据移至s1，再将数据入栈s1</p>
<p>3.pop：如果s2中存在要pop的数据，直接从s2pop，如果数据不在s2中，将s1中数据移至s2，从s2pop</p>
</blockquote>
<p>两个队列实现栈（先进先出，Push、Pop）</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669376074829.png" alt="1669376074829"><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669376074912.png" alt="1669376074912"></p>
<blockquote>
<p>1.Push：将新来的数据放到非空队列中</p>
<p>2.Pop：找到非空队列，将非空队列中的处尾元素以外的所有数据放到另一个队列中，然后弹出尾元素</p>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669378935451.png" alt="1669378935451"></p>
<p>s1和s2的区别</p>
<blockquote>
<p>1.s1-&gt;字符常量区-&gt;只读，s2-&gt;栈区-&gt;可读可写</p>
<p>2.*s1不能被赋值，因为在字符常量区，只读不可写</p>
<p>*s2能被赋值，可以修改</p>
<p>3.s1是指针，可以做左值，被赋值</p>
<p>s2是数组，不可以作为左值，不鞥能被赋值</p>
<p>4.s1是指针，指向的字符串第一个字符的地址，所以sizeof(s1) &#x3D; 4</p>
<p>sizeof(s2) &#x3D; 6（字符串长度为5.末尾还有个换行符\0）</p>
</blockquote>
<p>s1和s2相同点</p>
<blockquote>
<p>1.strlen &#x3D; 5</p>
<p>2.作为形参使用时完全相同</p>
</blockquote>
<h5 id="字符串空格替换"><a href="#字符串空格替换" class="headerlink" title="字符串空格替换"></a>字符串空格替换</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669631235050.png" alt="1669631235050"></p>
<p>方法</p>
<blockquote>
<p>1.遍历，遇到空格替换成123，需要额外的空间</p>
<p>2.先拆分，后拼接，需要额外的空间</p>
<p>3.后-&gt;前</p>
<p>数组扩充到空格数量的一定倍数，然后定义i,J分别指向新旧数组尾，然后逆遍历判断，不是空格就赋值，是空格的话就在数组后面插入123</p>
</blockquote>
<h5 id="字符串倒置"><a href="#字符串倒置" class="headerlink" title="字符串倒置"></a>字符串倒置</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669632962420.png" alt="1669632962420"></p>
<blockquote>
<p>1.拆成串，单词倒置</p>
<p>2.整个reverse，再将单词reverse</p>
<p>3.在空格处拆分字符串，重新拼接</p>
</blockquote>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669633762419.png" alt="1669633762419"></p>
<blockquote>
<p>1.reverse： 先整个翻转，然后再以e和f分为两部分单独翻转</p>
<p>2.queue： 从倒数第k个开始进队列，到字符串结束再从首位置开始进队列，完整进一遍队列，出队</p>
</blockquote>
<h5 id="寻找字符"><a href="#寻找字符" class="headerlink" title="寻找字符"></a>寻找字符</h5><p>在字符串中找第一个只出现一次的字符</p>
<blockquote>
<p>1.暴力：每个字符都跟后序的字符比较，如果不相同就是第一次只出现一次的字符</p>
<p>2.哈希</p>
</blockquote>
<h5 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669720112896.png" alt="1669720112896"></p>
<p>next数组记录主串子串匹配的最大长度</p>
<p>next:每个字符与前面字符比较，a前面无字符与之匹配，所以next值是0，b前面以为next值是0，所以要和第一位比较，不相同，所以b的next值也是0，c同理，第四位a前面的next值是0，所以与第一位相比较，相同所以next值是1，第五位b前面next值是1，所以与标志位为1的字符相比较，也就是第二个字符，相同，则next值是2，同理第六位c，第七位d前面的next值是3，所以要与第四位字符相比较，不相同，但是因为前面字符没有比较过，所以假设b在第四位，第四位前面的next值是0，所以重新与第一位比较，不相同，则为0,。。。</p>
<p>kmp：主串不回退，匹配串回溯</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669720990171.png" alt="1669720990171"></p>
<p>匹配：两个指针分别指向两个串的第一位，字符相同则向后走，字符不相同时，子串的指针回退到前一位next值的标志位，如果还不相同则继续回退，如果子串指针已经回退下标位为0的位置还不相同，则主串向后走一位，继续重新匹配，如果主串指针走到最后说明匹配失败，如果子串指针走到最后说明匹配成功，此时子串指针走到空，主串指针走到子串字符的下一位，用主串指针的标志位减掉子串长度就是子串在主串中第一次出现的位置</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1669722186568.png" alt="1669722186568"></p>
<h5 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h5><p>Sunday：在一个字符串中找另一个字符串首次出现的地址</p>
<p>算法过程：</p>
<p>首先将匹配字符串与主字符串的开头对其，进行一个一个的比较字符串是否相等，如果相等则同时向后移动，直到第一个不相等的字符。如上图所示，第一个不相等的字符为主字符串中的a对应匹配字符串中的d。现在我们知道主字符串和匹配字符串此时是不匹配的，那么我们知道从主字符串和匹配字符串对齐位置处开始，往后数匹配字符串的长度（这里是10）个字符，此时对应的字符串一定和匹配字符串是不匹配的，如下图所示：<br> <img src="https://img-blog.csdnimg.cn/ebceaf5850d24e98ab98fcb443e0a775.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p>
<p>如上图所示，上面用虚线框柱的主字符串中的子字符串一定与匹配字符串不匹配。由于在此处时主字符串和匹配字符串不匹配，因此我们可以直接略过这个位置，看虚线框后面的一个字符，然后查找该字符在匹配字符串中从后往前数第一次出现的位置，并将这两个字符对其，重新将主字符串和匹配字符串进行比较，如下图所示：<br> <img src="https://img-blog.csdnimg.cn/be8b84f80a3a4decbb8f3f360828a855.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p>
<p>如上图所示，重新将两个字符串对其，即将这里的d字符对其，然后重新从匹配字符串的开头进行匹配两个字符串。匹配的第一个字符为主字符串的a与匹配字符串的c，显然不相等，因此，同样看从主字符串匹配开始处数匹配字符串长度个单位，这个长度之后的字符为a，因此在匹配字符串中从后往前查找a第一次出现的位置，将两个a对齐，即重复上一个步骤，如下图所示：<br> <img src="https://img-blog.csdnimg.cn/a106294aec474249b5868beffd82f112.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p>
<p> Sunday匹配算法的大致过程就是这样，只要当前有字符不匹配，那么从匹配开始处数匹配字符串长度个字符，这些个字符肯定不匹配，既然这些一定不匹配，那么我们就直接看匹配字符串长度的下一个字符，然后在匹配字符串中查找该字符从后往前，第一次出现该字符的位置，然后将这两个字符对其 </p>
<p> 虚线框后的字符<code>g</code>在匹配字符串中并未出现，因此我们直接将匹配字符串于<code>g</code>后的下一个字符对齐，如下图所示： </p>
<p> <img src="https://img-blog.csdnimg.cn/bb5cf62d3bde4e40839fcdad4d692575.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnLlJlbW92ZSgp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p>
<p> 在此种情况下，将主串中的<code>I</code>与匹配串中的<code>c</code>进行对齐，重新开始匹配。 </p>
<p> Sunday算法的实现过程中，其时间耗费大多是在查找虚线框后的这个字符在匹配字符串中的位置时所需的花费。如果我们能减少查找字符的时间花费，那么我们就能大大减少Sunday算法的时间复杂度。 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1671264272302.png" alt="1671264272302"></p>
<p>建立一个next数组，以每个字符为索引值（因为字符对于计算机来说是一串数字，是可以被当做索引值的），初始化每个数组中的值为-1，从前往后遍历匹配串，将每个字符的下标值记录到数组中，如果遇到重复的字符，直接用后面字符的下标值覆盖掉前面的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include&lt;stdio.h&gt;</span><br><span class="line"> 2 #include&lt;stdlib.h&gt;</span><br><span class="line"> 3 #include&lt;string.h&gt;</span><br><span class="line"> 4 </span><br><span class="line"> 5 int Sunday(const char *src,const char *match)</span><br><span class="line"> 6 &#123;</span><br><span class="line"> 7     if(src == NULL || match == NULL)return -1;</span><br><span class="line"> 8 </span><br><span class="line"> 9     //get next array</span><br><span class="line">10     int *pNext = NULL;</span><br><span class="line">11     pNext = (int*)malloc(sizeof(int)*256);</span><br><span class="line">12     memset(pNext,-1,sizeof(int)*256);</span><br><span class="line">13 </span><br><span class="line">14     int i;</span><br><span class="line">15     for(i=0; i&lt;strlen(match); i++)</span><br><span class="line">16     &#123;</span><br><span class="line">17         pNext[match[i]] = i;</span><br><span class="line">18     &#125;</span><br><span class="line">19 </span><br><span class="line">20     //pipei</span><br><span class="line">21     i=0;</span><br><span class="line">22     int j=0;</span><br><span class="line">23     int k=0;</span><br><span class="line">24     while(i&lt;strlen(src) &amp;&amp; j&lt;strlen(match))</span><br><span class="line">25     &#123;</span><br><span class="line">26         if(src[i] == match[j])</span><br><span class="line">27         &#123;</span><br><span class="line">28             i++;</span><br><span class="line">29             j++;</span><br><span class="line">30         &#125;</span><br><span class="line">31 </span><br><span class="line">32         else                                                                                                                                                                      </span><br><span class="line">33         &#123;</span><br><span class="line">34             if(k+strlen(match) &lt; strlen(src))</span><br><span class="line">35             &#123;</span><br><span class="line">36                 i = k+strlen(match) - pNext[src[k+strlen(match)]];</span><br><span class="line">37                 k = i;</span><br><span class="line">38                 j = 0;</span><br><span class="line">39             &#125;</span><br><span class="line">40             else</span><br><span class="line">41             &#123;</span><br><span class="line">42                 return -1;</span><br><span class="line">43             &#125;</span><br><span class="line">44         &#125;</span><br><span class="line">45     &#125;</span><br><span class="line">47     if(j == strlen(match))</span><br><span class="line">48     &#123;</span><br><span class="line">49         return k;</span><br><span class="line">50     &#125;</span><br><span class="line">51     else</span><br><span class="line">52     &#123;</span><br><span class="line">53         return -1;</span><br><span class="line">54     &#125;</span><br><span class="line">55 </span><br><span class="line">56 &#125;</span><br><span class="line">57 </span><br><span class="line">58 </span><br><span class="line">59 </span><br><span class="line">60 int main()</span><br><span class="line">61 &#123;</span><br><span class="line">62     int Index = Sunday(&quot;swofnvjfiakdiaabcabcjfger&quot;,&quot;abcabc&quot;);</span><br><span class="line">63     printf(&quot;%d\n&quot;,Index);</span><br><span class="line">64     return 0;</span><br><span class="line">65 &#125;                   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p>结点之间有分支，具有层次关系</p>
<p>树的定义：树是n个结点的有限集。（树的定义是一个递归的定义）</p>
<p>n &#x3D; 0为空树</p>
<p>有且仅有一个特定的结点称为根结点</p>
<p>（根结点：非空树中无前驱结点的结点）</p>
<p>其余称为根的子树</p>
<p>结点的度：结点拥有的子树数。</p>
<p>树的度：树内各结点的度的最大值</p>
<p>终端结点（叶子）：度&#x3D;0</p>
<p>非终端结点（分支结点）：度 !&#x3D; 0</p>
<p>内部结点：根结点以外的分支结点</p>
<p>兄弟结点：结点有共同的双亲</p>
<p>结点的祖先：从根到该结点所经分支上的所有结点</p>
<p>树的深度：树中结点的最大层次</p>
<p>有序树：树中结点的各子树从左至右有次序</p>
<p>森林：是m棵互不相交的树的集合</p>
<p>注：对于中间结点，高度和深度不是一个概念，高度是从下往上看，深度是从上往下看</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树：由一个根结点及两棵互不相交的分别称为这个根的左子树和右子树的二叉树组成</p>
<p>特殊二叉树：（在顺序存储方式下可以复原）</p>
<h5 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h5><p>1、一个有k层的二叉树总的结点个数最多有2^k-1个</p>
<p>2、一个有k层的二叉树总的叶子结点最多有2^(k-1)个</p>
<p>3、对于任何一棵二叉树T,如果其叶子数为n0，度为2的结点数n2，则n0 &#x3D; n2 + 1。</p>
<p>性质3说明：</p>
<p>叶子的度为0为n0，度为2的结点为n2，一个二叉树</p>
<p>从下往上看，每个结点都有一条边去连接双亲，所以总边数是n-1</p>
<p>(根结点无双亲);</p>
<p>从上往下看总边数&#x3D;n2<em>2 + n1</em>1 + n0;</p>
<p>n-1 &#x3D; n2<em>2 + n1</em>1 + n0，n &#x3D; n2<em>2 + n1</em>1 + n0 +1，总结点数n &#x3D; n2 + n1 + n0</p>
<p>所以n0 &#x3D; n2 + 1</p>
<p>4、具有n个结点的完全二叉树的深度为floor(log2(n)) + 1</p>
<p>5、如果结点的编号是i，那么她的双亲编号是i&#x2F;2；她的左孩子结点是2i，右孩子是2i+1</p>
<p>将一棵完全二叉树从上到下从左到右从一开始编号，编号为i的结点如果满足2i&lt;&#x3D;n，则编号为i的结点有左孩子，如果满足2i+1&lt;&#x3D;n，则该结点有右孩子</p>
<p>父亲结点的编号范围是1~n&#x2F;2</p>
<p>如果是从0开始编号，那么有左孩子：2i+1&lt;n，右孩子：21+2&lt;n，父亲编号范围：0~n&#x2F;2-1。</p>
<h5 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h5><p>一个深度为k且有2^k-1个结点的二叉树</p>
<p>特点：</p>
<p>1、每层结点数都达到最大</p>
<p>2、叶子结点全部在底层</p>
<p>编号规则：从根结点开始，自上而下，自左到右</p>
<h5 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h5><p>深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号1~n的结点一一对应时，称为完全二叉树</p>
<p>注：在满二叉树中，从最后一个结点开始，<strong>连续</strong>去掉任意个结点，即是一棵完全二叉树</p>
<p>特点：</p>
<blockquote>
<p>每个结点最多有两个孩子</p>
<p>子树有左右之分，次序不能颠倒</p>
<p>可以是空集</p>
</blockquote>
<h5 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h5><blockquote>
<p>值</p>
<p>左子结点</p>
<p>右子结点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void CreateBiTree(BinaryTree **pTree)</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line"></span><br><span class="line">    if(num == 0)return;</span><br><span class="line"> </span><br><span class="line">    //jiedian tainjia</span><br><span class="line">    *pTree = (BinaryTree*)malloc(sizeof(BinaryTree));</span><br><span class="line">    (*pTree)-&gt;Value = num;</span><br><span class="line">    (*pTree)-&gt;pLeft = NULL;</span><br><span class="line">    (*pTree)-&gt;pRight = NULL;</span><br><span class="line"></span><br><span class="line">    CreateBiTree(&amp;(*pTree)-&gt;pLeft);</span><br><span class="line">    CreateBiTree(&amp;(*pTree)-&gt;pRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>深度遍历</p>
<blockquote>
<p>1.前序：根、左、右。</p>
<p>2.中序：左、根、右。</p>
<p>3.后序：左、右、根。</p>
</blockquote>
<h6 id="递归遍历："><a href="#递归遍历：" class="headerlink" title="递归遍历："></a>递归遍历：</h6><p>先序算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status PreOrderTraverse(BiTree T)&#123;</span><br><span class="line">	if(T == NULL)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		//访问根结点</span><br><span class="line">		//visit(T)</span><br><span class="line">		cout&lt;&lt;T-&gt;data;</span><br><span class="line">		//递归遍历左子树 </span><br><span class="line">		PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">		//递归遍历右子树</span><br><span class="line">		PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status InOrderTraverse(BiTree T)&#123;</span><br><span class="line">	if(T == NULL)return 1;</span><br><span class="line">	else&#123;</span><br><span class="line">		//递归遍历左子树</span><br><span class="line">		InOrderTraverse(T-&gt;lchild);</span><br><span class="line">		//访问根结点</span><br><span class="line">		//visit(T)</span><br><span class="line">		cout&lt;&lt;T-&gt;data;</span><br><span class="line">		//递归遍历右子树</span><br><span class="line">		InOrderTraverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status PostOrderTraverse(BiTree T)&#123;</span><br><span class="line">	if(T == NULL)return 1;</span><br><span class="line">	else&#123;</span><br><span class="line">		//递归遍历左子树</span><br><span class="line">		PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">		//递归遍历右子树</span><br><span class="line">		PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">		//访问根结点</span><br><span class="line">		//visit(T)</span><br><span class="line">		cout&lt;&lt;T-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h6><p>先序遍历</p>
<p>1、申请栈保存非空节点</p>
<p>2、遍历</p>
<p>结点非空，入栈，打印保存结点，找左孩子结点，当结点为空时结束</p>
<p>结束后弹出结点</p>
<p>处理右侧结点，如果当前结点非空，打印保存下来，找当前结点的左侧结点，步骤同上</p>
<p>没有待处理数据的时候停止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">46 void PreOrderTraversal(BinaryTree* pTree)</span><br><span class="line">47 &#123;</span><br><span class="line">48     if(pTree == NULL)return ;</span><br><span class="line">49 </span><br><span class="line">50     stack&lt;BinaryTree*&gt; s;</span><br><span class="line">51 </span><br><span class="line">52     while(1)</span><br><span class="line">53     &#123;</span><br><span class="line">54         while(pTree)</span><br><span class="line">55         &#123;</span><br><span class="line">56             //打印</span><br><span class="line">57             cout&lt;&lt;pTree-&gt;Value&lt;&lt;&quot; &quot;;</span><br><span class="line">58             //入站</span><br><span class="line">59             s.push(pTree);</span><br><span class="line">60 </span><br><span class="line">61             //左</span><br><span class="line">62             pTree = pTree-&gt;pLeft;</span><br><span class="line">63         &#125;</span><br><span class="line">64         if(s.empty())break;</span><br><span class="line">65 </span><br><span class="line">66         pTree = s.top();</span><br><span class="line">67         s.pop();</span><br><span class="line">68 </span><br><span class="line">69         pTree = pTree-&gt;pRight;</span><br><span class="line">70     &#125;</span><br><span class="line">71 </span><br><span class="line">72 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中序遍历</p>
<p>1、申请栈空间</p>
<p>2、遍历</p>
<p>结点非空，保存起来入栈，找到左子节点，当结点为空时结束</p>
<p>结束时，弹出，打印</p>
<p>处理右子结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> 75 void InOrderTraversal(BinaryTree* pTree)</span><br><span class="line"> 76 &#123;</span><br><span class="line"> 77     if(pTree == NULL)return ;</span><br><span class="line"> 78 </span><br><span class="line"> 79     stack&lt;BinaryTree*&gt; s;</span><br><span class="line"> 80 </span><br><span class="line"> 81     while(1)</span><br><span class="line"> 82     &#123;</span><br><span class="line"> 83         while(pTree)</span><br><span class="line"> 84         &#123;</span><br><span class="line"> 85             //入站</span><br><span class="line"> 86             s.push(pTree);</span><br><span class="line"> 87 </span><br><span class="line"> 88             //左</span><br><span class="line"> 89             pTree = pTree-&gt;pLeft;</span><br><span class="line"> 90         &#125;</span><br><span class="line"> 91         if(s.empty())break;</span><br><span class="line"> 92 </span><br><span class="line"> 93         pTree = s.top();</span><br><span class="line"> 94 </span><br><span class="line"> 95         //打印</span><br><span class="line"> 96         cout&lt;&lt;pTree-&gt;Value&lt;&lt;&quot; &quot;;</span><br><span class="line"> 97 </span><br><span class="line"> 98         s.pop();</span><br><span class="line"> 99 </span><br><span class="line">100         pTree = pTree-&gt;pRight;</span><br><span class="line">101     &#125;</span><br><span class="line">102 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后序遍历</p>
<p>1、申请栈空间</p>
<p>2、遍历</p>
<p>结点非空，保存结点入栈，找左子节点</p>
<p>栈顶元素是否有右子结点</p>
<p>（1）如果有，未处理，处理</p>
<p>（2）如果有，已经处理过&#x2F;没有，则弹出，打印</p>
<p>判断右子结点是否被处理过：栈顶元素的右子结点是否等于上次打印结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">104 void LastOrderTraversal(BinaryTree* pTree)</span><br><span class="line">105 &#123;</span><br><span class="line">106     if(pTree == NULL)return ;</span><br><span class="line">107 </span><br><span class="line">108     stack&lt;BinaryTree*&gt; s;</span><br><span class="line">109 </span><br><span class="line">110     BinaryTree* pMark = NULL;</span><br><span class="line">111 </span><br><span class="line">112     while(1)</span><br><span class="line">113     &#123;</span><br><span class="line">114         while(pTree)</span><br><span class="line">115         &#123;</span><br><span class="line">116             //保存</span><br><span class="line">117             s.push(pTree);</span><br><span class="line">118             //左</span><br><span class="line">119             pTree = pTree-&gt;pLeft;</span><br><span class="line">120         &#125;</span><br><span class="line">121 </span><br><span class="line">122         if(s.empty())break;</span><br><span class="line">123 </span><br><span class="line">124         if(s.top()-&gt;pRight == pMark || s.top()-&gt;pRight == NULL)</span><br><span class="line">125         &#123;</span><br><span class="line">126             //弹出</span><br><span class="line">127             pMark = s.top();</span><br><span class="line">128             s.pop();                                                                                                                                                              </span><br><span class="line">129             //打印</span><br><span class="line">130             cout&lt;&lt;pMark-&gt;Value&lt;&lt;&quot; &quot;;</span><br><span class="line">131         &#125;</span><br><span class="line">132         else</span><br><span class="line">133         &#123;</span><br><span class="line">134             pTree = s.top()-&gt;pRight;</span><br><span class="line">135         &#125;</span><br><span class="line">136     &#125;</span><br><span class="line">137 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="广度遍历"><a href="#广度遍历" class="headerlink" title="广度遍历"></a>广度遍历</h6><blockquote>
<p>层序：按照从上到下从左到右依次遍历</p>
</blockquote>
<p>层序遍历</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674642041271.png" alt="1674642041271"></p>
<p>如果按照每层从左到右的遍历逻辑，这棵二叉树的层序遍历序列就是 [ 1 , 4 , 2 , 7 , 20 , 5 ] </p>
<p> 同一层中的节点自左向右遍历是通过队列实现的： 先将根结点1入队，然后让1出队，处理根结点，然后将它的左孩子4和右孩子2依次放入队列，然后让4出队，处理结点4的同时将结点4的左孩子7和右孩子20入队，然后让结点2出队，处理结点2的同时让结点2的左孩子5入队，所有结点处理完成即队列为空时结束</p>
<p>这样就实现了层序依次遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">45 void LevelTraversal(BinaryTree *pTree)</span><br><span class="line">46 &#123;</span><br><span class="line">47     if(pTree == NULL)return;</span><br><span class="line">48 </span><br><span class="line">49     //队列</span><br><span class="line">50     queue&lt;BinaryTree*&gt; q;</span><br><span class="line">51 </span><br><span class="line">52     //根节点入队</span><br><span class="line">53     q.push(pTree);</span><br><span class="line">54 </span><br><span class="line">55     //遍历</span><br><span class="line">56     while(!q.empty())</span><br><span class="line">57     &#123;</span><br><span class="line">58         pTree = q.front();</span><br><span class="line">59         q.pop();</span><br><span class="line">60 </span><br><span class="line">61         cout&lt;&lt;pTree-&gt;Value&lt;&lt;&quot; &quot;;</span><br><span class="line">62 </span><br><span class="line">63         //非空左右孩子节点入队</span><br><span class="line">64         if(pTree-&gt;pLeft != NULL)</span><br><span class="line">65         &#123;</span><br><span class="line">66             q.push(pTree-&gt;pLeft);</span><br><span class="line">67         &#125;</span><br><span class="line">68         if(pTree-&gt;pRight != NULL)</span><br><span class="line">69         &#123;</span><br><span class="line">70             q.push(pTree-&gt;pRight);</span><br><span class="line">71         &#125;</span><br><span class="line">72     &#125;</span><br><span class="line">73 </span><br><span class="line">74 &#125;</span><br></pre></td></tr></table></figure>

<p>根据二叉数的前序和中序或者后序和中序能构造出二叉数</p>
<h4 id="完全二叉树的创建"><a href="#完全二叉树的创建" class="headerlink" title="完全二叉树的创建"></a>完全二叉树的创建</h4><p>先把数据放入一个结构体数组中，然后进行数据的关联（找到左右子树）</p>
<p>从0开始编号，根据性质，左子树的结点编号是2i+1，2i+2，父亲结点的编号是0~n&#x2F;2-1.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	BinaryTree *CreateCBT(int arr[],int nLength)</span><br><span class="line">102 &#123;</span><br><span class="line">103     if(arr == NULL || nLength &lt;=0) return ;</span><br><span class="line">104 </span><br><span class="line">105     //空间申请</span><br><span class="line">106     BinaryTree *pCBT = NULL;</span><br><span class="line">107     pCBT = (BinaryTree*)malloc(sizeof(BinaryTree)*nLength);</span><br><span class="line">108 </span><br><span class="line">109     //赋值</span><br><span class="line">110     int i;</span><br><span class="line">111     for(i=0; i&lt;nLength; i++)</span><br><span class="line">112     &#123;</span><br><span class="line">113         pCBT[i].Value = arr[i];</span><br><span class="line">114         pCBT[i].pLeft = NULL;</span><br><span class="line">115         pCBT[i].pRight = NULL;</span><br><span class="line">116     &#125;</span><br><span class="line">117 </span><br><span class="line">118     //父子关系关联</span><br><span class="line">119     for(i=0; i&lt;nLength/2; i++)</span><br><span class="line">120     &#123;</span><br><span class="line">121         if(2*i+1 &lt;= nLength -1)</span><br><span class="line">122         &#123;</span><br><span class="line">123             pCBT[i].pLeft = &amp;pCBT[2*i+1];</span><br><span class="line">124         &#125;</span><br><span class="line">125 </span><br><span class="line">126         if(2*i+2 &lt;= nLength-1)</span><br><span class="line">127         &#123;</span><br><span class="line">128             pCBT[i].pRight = &amp;pCBT[2*i+2];</span><br><span class="line">129         &#125;</span><br><span class="line">130     &#125;</span><br><span class="line">131     return pCBT;</span><br><span class="line">132 </span><br><span class="line">133 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="二叉搜索树-x2F-排序二叉树（BST）"><a href="#二叉搜索树-x2F-排序二叉树（BST）" class="headerlink" title="二叉搜索树&#x2F;排序二叉树（BST）"></a>二叉搜索树&#x2F;排序二叉树（BST）</h4><p>定义：树中的任意一个父亲结点的值都比整棵左子树大，都比整棵右子树小</p>
<p>搜索速度变慢的情况：当子树都在一边，退化成链表，平均分配搜索的优势没有了，增删的优势也没有了</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674632474001.png" alt="1674632474001"></p>
<h5 id="构建排序二叉树"><a href="#构建排序二叉树" class="headerlink" title="构建排序二叉树"></a>构建排序二叉树</h5><p>1、如果是空树，则添加的结点就是根</p>
<p>2、如果树是非空，遍历</p>
<p>和当前的根结点进行比较，如果当前节点比父亲大，去右子树处理，如果比父亲小，去左子树处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">26 void AddNode(BinaryTree **pTree ,int nNum)</span><br><span class="line">27 &#123;</span><br><span class="line">28     //数值放入节点</span><br><span class="line">29     BinaryTree* pTemp = NULL;</span><br><span class="line">30     pTemp = (BinaryTree*)malloc(sizeof(BinaryTree));</span><br><span class="line">31     pTemp-&gt;Value = nNum;</span><br><span class="line">32     pTemp-&gt;pLeft = NULL;</span><br><span class="line">33     pTemp-&gt;pRight = NULL;</span><br><span class="line">34 </span><br><span class="line">35     //放入树中</span><br><span class="line">36     if(*pTree == NULL)</span><br><span class="line">37     &#123;</span><br><span class="line">38         *pTree = pTemp;</span><br><span class="line">39         return;</span><br><span class="line">40     &#125;</span><br><span class="line">41     </span><br><span class="line">42     BinaryTree* pNode = *pTree;</span><br><span class="line">43 </span><br><span class="line">44     while(pNode)</span><br><span class="line">45     &#123;</span><br><span class="line">46         if(pNode-&gt;Value &gt; nNum)</span><br><span class="line">47         &#123;</span><br><span class="line">48             if(pNode-&gt;pLeft == NULL)</span><br><span class="line">49             &#123;</span><br><span class="line">50                 pNode-&gt;pLeft = pTemp;</span><br><span class="line">51                 return;</span><br><span class="line">52             &#125;</span><br><span class="line">53             //向左走</span><br><span class="line">54             pNode = pNode-&gt;pLeft;</span><br><span class="line">55         &#125;</span><br><span class="line">56 </span><br><span class="line">57         else if(pNode-&gt;Value &lt; nNum)</span><br><span class="line">58         &#123;</span><br><span class="line">59             if(pNode-&gt;pRight == NULL)</span><br><span class="line">60             &#123;</span><br><span class="line">61                 pNode-&gt;pRight = pTemp;</span><br><span class="line">62                 return ;</span><br><span class="line">63             &#125;</span><br><span class="line">64             //向右走</span><br><span class="line">65             pNode = pNode-&gt;pRight;</span><br><span class="line">66         &#125;</span><br><span class="line">67         </span><br><span class="line">68         else</span><br><span class="line">69         &#123;</span><br><span class="line">70             printf(&quot;data error\n&quot;);</span><br><span class="line">71             free(pTemp);</span><br><span class="line">72             pTemp = NULL;</span><br><span class="line">73             return;</span><br><span class="line">74         &#125;</span><br><span class="line">75     &#125;</span><br><span class="line">76 &#125;</span><br><span class="line">77 </span><br><span class="line">78 BinaryTree* CreateBST()</span><br><span class="line">79 &#123;</span><br><span class="line">80     int nNum;</span><br><span class="line">81     int nLen;</span><br><span class="line">82     int i;</span><br><span class="line">83 </span><br><span class="line">84     BinaryTree* pTree = NULL;</span><br><span class="line">85     printf(&quot;请输入节点个数\n&quot;);</span><br><span class="line">86     scanf(&quot;%d\n&quot;,&amp;nLen);</span><br><span class="line">87 </span><br><span class="line">88     for(i=0;i&lt;nLen;i++)</span><br><span class="line">89     &#123;</span><br><span class="line">90         scanf(&quot;%d&quot;,&amp;nNum);</span><br><span class="line">91 </span><br><span class="line">92         //节点添加</span><br><span class="line">93         AddNode(&amp;pTree,nNum);</span><br><span class="line">94     &#125;</span><br><span class="line">95     return pTree;</span><br><span class="line">96 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="排序二叉树的删除"><a href="#排序二叉树的删除" class="headerlink" title="排序二叉树的删除"></a>排序二叉树的删除</h5><p>分三种情况</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674821731882.png" alt="1674821731882"></p>
<h6 id="第一种情况：删除叶子结点。比如：2-5-9-12"><a href="#第一种情况：删除叶子结点。比如：2-5-9-12" class="headerlink" title="第一种情况：删除叶子结点。比如：2,5,9,12."></a>第一种情况：删除叶子结点。比如：2,5,9,12.</h6><p>(1) 需求先去找到要删除的结点 targetNode。</p>
<p>(2) 找到 targetNode 的 父结点 parent。</p>
<p>(3) 确定 targetNode 是 parent 的左子结点还是右子结点。</p>
<p>(4) 根据前面的情况来对应删除。</p>
<p>左子结点 parent.left &#x3D; null</p>
<p>右子结点 parent.right &#x3D; null</p>
<h6 id="第二种情况：删除只有一棵子树的结点。比如：1"><a href="#第二种情况：删除只有一棵子树的结点。比如：1" class="headerlink" title="第二种情况：删除只有一棵子树的结点。比如：1"></a>第二种情况：删除只有一棵子树的结点。比如：1</h6><p>(1) 需求先去找到要删除的结点 targetNode。</p>
<p>(2) 找到 targetNode 的 父结点 parent。</p>
<p>(3) 确定 targetNode 的子结点是左子结点还是右子结点。</p>
<p>(4) targetNode 是 parent 的左子结点还是右子结点。</p>
<p>(5) 如果 targetNode 有左子结点</p>
<p>a 如果 targetNode 是 parent 的左子结点</p>
<p>parent.left &#x3D; targetNode.left;</p>
<p>b 如果 targetNode 是 parent 的右子结点</p>
<p>parent.right &#x3D; targetNode.left;</p>
<p>(6) 如果 targetNode 有右子结点</p>
<p>a 如果 targetNode 是 parent 的左子结点</p>
<p>parent.left &#x3D; targetNode.right;</p>
<p>b 如果 targetNode 是 parent 的右子结点</p>
<p>parent.right &#x3D; targetNode.right</p>
<h6 id="第三种情况：删除有两棵子树的结点。比如：7-3-10。"><a href="#第三种情况：删除有两棵子树的结点。比如：7-3-10。" class="headerlink" title="第三种情况：删除有两棵子树的结点。比如：7,3,10。"></a>第三种情况：删除有两棵子树的结点。比如：7,3,10。</h6><p>(1) 需求先去找到要删除的结点 targetNode。</p>
<p>(2) 找到 targetNode 的 父结点 parent。</p>
<p>(3) 从 targetNode 的右子树找到最小的结点。</p>
<p>(4) 用一个临时变量， 将最小结点的值保存到 temp</p>
<p>(5) 删除该最小结点</p>
<p>(6) targetNode.value &#x3D; temp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> 98 void Search(BinaryTree* pTree,int nNum,BinaryTree **pDel,BinaryTree **pFather)</span><br><span class="line"> 99 &#123;</span><br><span class="line">100     while(pTree)</span><br><span class="line">101     &#123;   </span><br><span class="line">102         if(pTree-&gt;Value == nNum)</span><br><span class="line">103         &#123;   </span><br><span class="line">104             *pDel = pTree;</span><br><span class="line">105             return;</span><br><span class="line">106         &#125;</span><br><span class="line">107         else if(pTree-&gt;Value &gt; nNum)</span><br><span class="line">108         &#123;   </span><br><span class="line">109             //左侧</span><br><span class="line">110             *pFather = pTree;</span><br><span class="line">111             pTree = pTree-&gt;pLeft;</span><br><span class="line">112         &#125;</span><br><span class="line">113         else</span><br><span class="line">114         &#123;   </span><br><span class="line">115             //右侧</span><br><span class="line">116             *pFather = pTree;</span><br><span class="line">117             pTree = pTree-&gt;pRight;</span><br><span class="line">118         &#125;</span><br><span class="line">119     &#125;</span><br><span class="line">120     *pFather = NULL;</span><br><span class="line">121 &#125;</span><br><span class="line">123 void DelNode(BinaryTree **pTree,int nNum)</span><br><span class="line">124 &#123;</span><br><span class="line">125     //查找</span><br><span class="line">126     BinaryTree* pDel = NULL;</span><br><span class="line">127     BinaryTree* pFather = NULL;</span><br><span class="line">128 </span><br><span class="line">129     Search(*pTree,nNum,&amp;pDel,&amp;pFather);</span><br><span class="line">130 </span><br><span class="line">131     //未找到</span><br><span class="line">132     if(pDel == NULL)return ;</span><br><span class="line">133 </span><br><span class="line">134     //两个孩子</span><br><span class="line">135     BinaryTree* pMark = NULL;</span><br><span class="line">136     if(pDel-&gt;pLeft != NULL &amp;&amp; pDel-&gt;pRight != NULL)</span><br><span class="line">137     &#123;</span><br><span class="line">138         pMark = pDel;</span><br><span class="line">139 </span><br><span class="line">140         //左子树的最右值</span><br><span class="line">141         pFather = pDel;</span><br><span class="line">142         pDel = pDel-&gt;pLeft;</span><br><span class="line">143 </span><br><span class="line">144         while(pDel-&gt;pRight != NULL)</span><br><span class="line">145         &#123;</span><br><span class="line">146             pFather = pDel;</span><br><span class="line">147             pDel = pDel-&gt;pRight;</span><br><span class="line">148         &#125;</span><br><span class="line">149 </span><br><span class="line">150         //值覆盖</span><br><span class="line">151         pMark-&gt;Value = pDel-&gt;Value;</span><br><span class="line">152     &#125;</span><br><span class="line">153 </span><br><span class="line">154     //0个孩子或1个孩子</span><br><span class="line">155     //换根</span><br><span class="line">156     if(pFather == NULL)</span><br><span class="line">157     &#123;</span><br><span class="line">158         *pTree = pDel-&gt;pLeft ? pDel-&gt;pLeft : pDel-&gt;pRight;</span><br><span class="line">159         free(pDel);</span><br><span class="line">160         return;</span><br><span class="line">161     &#125;</span><br><span class="line">162     else</span><br><span class="line">163     &#123;</span><br><span class="line">164         if(pDel == pFather-&gt;pLeft)</span><br><span class="line">165         &#123;</span><br><span class="line">166             pFather-&gt;pLeft = pDel-&gt;pLeft ? pDel-&gt;pLeft : pDel-&gt;pRight;</span><br><span class="line">167         &#125;</span><br><span class="line">168         else</span><br><span class="line">169         &#123;</span><br><span class="line">170             pFather-&gt;pRight = pDel-&gt;pLeft ? pDel-&gt;pLeft : pDel-&gt;pRight;     </span><br><span class="line">171         &#125;</span><br><span class="line">172     &#125;</span><br><span class="line">173 </span><br><span class="line">174 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="如何将一棵排序二叉树转变为有序的双向链表"><a href="#如何将一棵排序二叉树转变为有序的双向链表" class="headerlink" title="如何将一棵排序二叉树转变为有序的双向链表"></a>如何将一棵排序二叉树转变为有序的双向链表</h5><p>以中序遍历的方式遍历BST，在遍历的时候把当前结点以尾添加的形式添加到双向链表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">176 void BSTToList(BinaryTree* pTree,BinaryTree** pHead,BinaryTree** pTail)</span><br><span class="line">177 &#123;</span><br><span class="line">178     if(pTree == NULL)return;</span><br><span class="line">179 </span><br><span class="line">180     //左子树</span><br><span class="line">181     BSTToList(pTree-&gt;pLeft,pHead,pTail);</span><br><span class="line">182 </span><br><span class="line">183     //处理节点</span><br><span class="line">184     if(*pHead == NULL)</span><br><span class="line">185     &#123;</span><br><span class="line">186         *pHead = pTree;                                                                                                                                                           </span><br><span class="line">187     &#125;</span><br><span class="line">188     else</span><br><span class="line">189     &#123;</span><br><span class="line">190         (*pTail)-&gt;pRight = pTree;</span><br><span class="line">191         pTree-&gt;pLeft = *pTail;</span><br><span class="line">192     &#125;</span><br><span class="line">193     *pTail = pTree;</span><br><span class="line">194 </span><br><span class="line">195     //右子树</span><br><span class="line">196     BSTToList(pTree-&gt;pRight,pHead,pTail);</span><br><span class="line">197 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="平衡二叉树-x2F-平衡二叉搜索树（AVL树）"><a href="#平衡二叉树-x2F-平衡二叉搜索树（AVL树）" class="headerlink" title="平衡二叉树&#x2F;平衡二叉搜索树（AVL树）"></a>平衡二叉树&#x2F;平衡二叉搜索树（AVL树）</h4><p>定义：在二叉搜索树的前提下，保证任意一个结点的左右子树的高度差不超过1</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674820003348.png" alt="1674820003348"></p>
<h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><p>右旋：指将根节点的左侧往右拉，原先的左子节点变成新的父节点，并把多余的右子节点出让，给已经降级的根节点当左子节点 </p>
<p>二叉树调整的时候都是从下往上的顺序，所以先动节点5</p>
<p> （1）原先的根节点为7，左子节点4有个右子节点5 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893373496.png" alt="1674893373496"></p>
<p> （2）暂且不看右子节点5，先将二叉树右旋，新的父节点为4 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893407903.png" alt="1674893407903"></p>
<p> （3）再将原右子节点5，作为已降级的7的左子节点即可 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674893428956.png" alt="1674893428956"></p>
<p>当节点7有父亲节点时，除了上述处理外，结点4的父亲是原来结点7的父亲，最多动四个结点，三对父子关系</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674906000237.png" alt="1674906000237"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">52 void RightRotate(BinaryTree *pNode)</span><br><span class="line">53 &#123;</span><br><span class="line">54     if(pNode == NULL || pNode-&gt;pLeft == NULL)return;</span><br><span class="line">55 </span><br><span class="line">56     BinaryTree *pMark = pNode-&gt;pLeft;</span><br><span class="line">57 </span><br><span class="line">58     //三个孩子的关系</span><br><span class="line">59     pNode-&gt;pLeft = pMark-&gt;pRight;</span><br><span class="line">60     pMark-&gt;pRight = pNode;</span><br><span class="line">61 </span><br><span class="line">62     if(pNode-&gt;pFather != NULL)</span><br><span class="line">63     &#123;</span><br><span class="line">64         if(pNode == pNode-&gt;pFather-&gt;pLeft)</span><br><span class="line">65         &#123;</span><br><span class="line">66             pNode-&gt;pFather-&gt;pLeft = pMark;</span><br><span class="line">67         &#125;</span><br><span class="line">68         else</span><br><span class="line">69         &#123;</span><br><span class="line">70             pNode-&gt;pFather-&gt;pRight = pMark;</span><br><span class="line">71         &#125;</span><br><span class="line">72     &#125;</span><br><span class="line">73     else</span><br><span class="line">74     &#123;</span><br><span class="line">75         pTree = pMark;</span><br><span class="line">76     &#125;</span><br><span class="line">77 </span><br><span class="line">78     //三个父亲的关系</span><br><span class="line">79     if(pNode-&gt;pLeft != NULL)</span><br><span class="line">80     &#123;</span><br><span class="line">81         pNode-&gt;pLeft-&gt;pFather = pNode;</span><br><span class="line">82     &#125;</span><br><span class="line">83 </span><br><span class="line">84     pMark-&gt;pFather = pNode-&gt;pFather;</span><br><span class="line">85     pNode-&gt;pFather = pMark;</span><br><span class="line">86 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="旋转的情况"><a href="#旋转的情况" class="headerlink" title="旋转的情况"></a>旋转的情况</h5><p> 左子树高：右旋；右子树高：左旋； </p>
<p>右旋：左的左引起的不平衡</p>
<p>左旋：右的右引起的不平衡</p>
<p>左右旋：左的右引起的不平衡</p>
<p>右左旋：右的左引起的不平衡</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674908927263.png" alt="1674908927263"></p>
<h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><p> 左旋：指将根节点的右侧往左拉，原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点 </p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674907940748.png" alt="1674907940748"></p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p> 红黑树是一种自平衡的二叉查找树，是一种高效的查找树。 </p>
<p>红黑树的特性</p>
<blockquote>
<p>1、每个节点的颜色，要么是黑色，要么是红色</p>
<p>2、根节点必须是黑色的</p>
<p>3、认为终端节点是黑色的，称之为黑哨兵</p>
<p>4、树中不允许两个红结点为父子关系</p>
<p>5、从任意节点向下出发，所能到达的各个终端节点的各条路径上，黑节点的数目必须是完全相同的</p>
</blockquote>
<p>红黑树的增加、删除、查找的时间消耗都是log(2n)</p>
<p>因为红黑树的五条性质，红黑树上路径的长度不会超过另一条路径的两倍</p>
<h5 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h5><p>插入时：插入的结点一定是红色的，如果为黑色，会破坏第五条规则</p>
<ul>
<li><p>如果插入的结点是根节点，将颜色改为黑色</p>
</li>
<li><p>插入的结点的父结点是黑色的，则插入完成</p>
</li>
<li><p>插入的结点的父结点是红色的，则需要修复，且继续向上调整，直到为根或满足规则</p>
<p>如果叔叔节点是红色的，父亲-&gt;黑色，叔叔-&gt;黑色，爷爷-&gt;红色，爷爷为新的操作节点，重新调整</p>
<p>如果叔叔节点时黑色的，</p>
<p>父亲是爷爷的左侧，当前结点是父亲的右侧，让父亲作为新的当前节点，以当前节点为旋转点左旋 </p>
<p>父亲是爷爷的左侧，当前结点是父亲的左侧，父亲-&gt;黑色，爷爷-&gt;红色，以爷爷为旋转点右旋，如果平衡则结束</p>
<p>父亲是爷爷的右侧，当前节点是父亲的左侧，让父亲作为新的调整节点，以新的调整节点为旋转点右旋</p>
<p>父亲是爷爷的右侧，当前结点是父亲的右侧，父亲-&gt;黑色，爷爷-&gt;红色，以爷爷为旋转点左旋，如果平衡则结束</p>
</li>
<li><p>如果根修改之后为红色，一定要改过来，改为黑色</p>
</li>
</ul>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1674983264886.png" alt="1674983264886"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675164219988.png" alt="1675164219988"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"> 89 RBT *GetFather(RBT *pTree,int nNum)</span><br><span class="line"> 90 &#123;</span><br><span class="line"> 91     while(pTree)</span><br><span class="line"> 92     &#123;   </span><br><span class="line"> 93         if(pTree-&gt;Value &gt; nNum)</span><br><span class="line"> 94         &#123;   </span><br><span class="line"> 95             //左侧</span><br><span class="line"> 96             if(pTree-&gt;pLeft == NULL)return pTree;</span><br><span class="line"> 97             pTree = pTree-&gt;pLeft;</span><br><span class="line"> 98         &#125;</span><br><span class="line"> 99         else if(pTree-&gt;Value &lt; nNum)</span><br><span class="line">100         &#123;   </span><br><span class="line">101             //右侧</span><br><span class="line">102             if(pTree-&gt;pRight == NULL)return pTree;</span><br><span class="line">103             pTree = pTree-&gt;pRight;</span><br><span class="line">104         &#125;</span><br><span class="line">105         else</span><br><span class="line">106         &#123;   </span><br><span class="line">107             printf(&quot;data error\n&quot;);</span><br><span class="line">108             exit(1);</span><br><span class="line">109         &#125;</span><br><span class="line">110     &#125;</span><br><span class="line">111     return NULL;</span><br><span class="line">112 &#125;</span><br><span class="line">113 </span><br><span class="line">114 RBT *GetUncle(RBT *pFather)</span><br><span class="line">115 &#123;</span><br><span class="line">116     if(pFather == pFather-&gt;pFather-&gt;pLeft)</span><br><span class="line">117     &#123;</span><br><span class="line">118         return pFather-&gt;pFather-&gt;pRight;</span><br><span class="line">119     &#125;</span><br><span class="line">120     else</span><br><span class="line">121     &#123;</span><br><span class="line">122         return pFather-&gt;pFather-&gt;pLeft;</span><br><span class="line">123     &#125;</span><br><span class="line">124 &#125;</span><br><span class="line">126 void AddNode(int nNum)</span><br><span class="line">127 &#123;</span><br><span class="line">128     RBT *pTemp = NULL;</span><br><span class="line">129     pTemp = (RBT*)malloc(sizeof(RBT));</span><br><span class="line">130     pTemp-&gt;Value = nNum;</span><br><span class="line">131     pTemp-&gt;Color = RED;</span><br><span class="line">132     pTemp-&gt;pLeft = NULL;</span><br><span class="line">133     pTemp-&gt;pRight = NULL;</span><br><span class="line">134     pTemp-&gt;pFather = NULL;</span><br><span class="line">135 </span><br><span class="line">136     //找到父亲节点</span><br><span class="line">137     RBT *pNode = NULL;</span><br><span class="line">138     pNode = GetFather(pRBT,nNum);</span><br><span class="line">139     pTemp-&gt;pFather = pNode;</span><br><span class="line">140 </span><br><span class="line">141     //空树</span><br><span class="line">142     if(pNode == NULL)</span><br><span class="line">143     &#123;</span><br><span class="line">144         pRBT = pTemp;</span><br><span class="line">145         pRBT-&gt;Color = BLACK;</span><br><span class="line">146         return ;</span><br><span class="line">147     &#125;</span><br><span class="line">148 </span><br><span class="line">149     //非空树</span><br><span class="line">150     //连接</span><br><span class="line">151     if(nNum &lt; pNode-&gt;Value)</span><br><span class="line">152     &#123;</span><br><span class="line">153         pNode-&gt;pLeft = pTemp;</span><br><span class="line">154     &#125;</span><br><span class="line">155     else</span><br><span class="line">156     &#123;</span><br><span class="line">157         pNode-&gt;pRight = pTemp;</span><br><span class="line">158     &#125;</span><br><span class="line">159 </span><br><span class="line">160     //父亲黑</span><br><span class="line">161     if(pNode-&gt;Color == BLACK)</span><br><span class="line">162     &#123;</span><br><span class="line">163         return ;</span><br><span class="line">164     &#125;</span><br><span class="line">165                                                                                                                                                                                   </span><br><span class="line">166     //父亲红</span><br><span class="line">167     RBT *pGrandFather = NULL;</span><br><span class="line">168     RBT *pUncle = NULL;</span><br><span class="line">169 </span><br><span class="line">170     while(pNode-&gt;Color == RED)</span><br><span class="line">171     &#123;</span><br><span class="line">172         pGrandFather = pNode-&gt;pFather;</span><br><span class="line">173         pUncle = GetUncle(pNode);</span><br><span class="line">174 </span><br><span class="line">175         //叔叔红</span><br><span class="line">176         if(pUncle-&gt;Color == RED &amp;&amp; pUncle != NULL)</span><br><span class="line">177         &#123;</span><br><span class="line">178             pNode-&gt;Color = BLACK;</span><br><span class="line">179             pUncle-&gt;Color = BLACK;</span><br><span class="line">180             pGrandFather-&gt;Color = RED;</span><br><span class="line">181 </span><br><span class="line">182             pTemp = pGrandFather;</span><br><span class="line">183             pNode = pTemp-&gt;pFather;</span><br><span class="line">184 </span><br><span class="line">185             //根</span><br><span class="line">186             if(pNode == NULL)</span><br><span class="line">187             &#123;</span><br><span class="line">188                 pTemp-&gt;Color = BLACK;</span><br><span class="line">189                 break;</span><br><span class="line">190             &#125;</span><br><span class="line">191             continue;</span><br><span class="line">192         &#125;</span><br><span class="line">193 </span><br><span class="line">194         //叔叔黑</span><br><span class="line">195         if(pUncle-&gt;Color == BLACK || pUncle == NULL)</span><br><span class="line">196         &#123;</span><br><span class="line">197             //父亲是爷爷的左侧</span><br><span class="line">198             if(pNode == pGrandFather-&gt;pLeft)</span><br><span class="line">199             &#123;</span><br><span class="line">200                 //当前节点是父亲的左侧</span><br><span class="line">201                 if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">202                 &#123;</span><br><span class="line">203                     pNode-&gt;Color = BLACK;</span><br><span class="line">204                     pGrandFather-&gt;Color = RED;</span><br><span class="line">205                     RightRotate(pGrandFather);</span><br><span class="line">206                     break;</span><br><span class="line">207                 &#125;</span><br><span class="line">208                 //当前节点是父亲的右侧</span><br><span class="line">209                 if(pTemp == pNode-&gt;pRight)</span><br><span class="line">210                 &#123;</span><br><span class="line">211                     pTemp = pNode;</span><br><span class="line">212                     LeftRotate(pTemp);</span><br><span class="line">213 </span><br><span class="line">214                     //更新父亲</span><br><span class="line">215                     pNode = pTemp-&gt;pFather;</span><br><span class="line">216                 &#125;</span><br><span class="line">217             &#125;</span><br><span class="line">218 </span><br><span class="line">219             //父亲是爷爷的右侧</span><br><span class="line">220             if(pNode == pGrandFather-&gt;pRight)</span><br><span class="line">221             &#123;</span><br><span class="line">222                 //当前节点是父亲的右侧</span><br><span class="line">223                 if(pTemp == pNode-&gt;pRight)</span><br><span class="line">224                 &#123;</span><br><span class="line">225                     pNode-&gt;Color = BLACK;</span><br><span class="line">226                     pGrandFather-&gt;Color = RED;</span><br><span class="line">227                     LeftRotate(pGrandFather);</span><br><span class="line">228                     break;</span><br><span class="line">229                 &#125;</span><br><span class="line">230 </span><br><span class="line">231                 //当前节点是父亲的左侧</span><br><span class="line">232                 if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">233                 &#123;</span><br><span class="line">234                     pTemp = pNode;</span><br><span class="line">235                     RightRotate(pTemp);</span><br><span class="line">236 </span><br><span class="line">237                     //更新父亲</span><br><span class="line">238                     pNode = pTemp-&gt;pFather;</span><br><span class="line">239                 &#125;</span><br><span class="line">240             &#125;</span><br><span class="line">241         &#125;</span><br><span class="line">242     &#125;</span><br><span class="line">243 </span><br><span class="line">244 &#125;</span><br><span class="line">245 </span><br><span class="line">246 void CreateRBT()</span><br><span class="line">247 &#123;</span><br><span class="line">248     int nLen;</span><br><span class="line">249     int nNum;</span><br><span class="line">250     scanf(&quot;%d&quot;,&amp;nLen);</span><br><span class="line">251 </span><br><span class="line">252     int i;</span><br><span class="line">253     for(i=0; i&lt;nLen; i++)</span><br><span class="line">254         &#123;</span><br><span class="line">255             scanf(&quot;%d&quot;,&amp;nNum);</span><br><span class="line">256             AddNode(nNum);</span><br><span class="line">257         &#125;</span><br><span class="line">258 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h5><p>真正被删除的结点的颜色</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675321702785.png" alt="1675321702785"></p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675337723859.png" alt="1675337723859"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">RBT *FindNode(RBT *pTree,int nNum)</span><br><span class="line">&#123;</span><br><span class="line">	while(pTree)</span><br><span class="line">	&#123;</span><br><span class="line">		if(pTree-&gt;nValue == nNum)</span><br><span class="line">		&#123;</span><br><span class="line">			return pTree;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(pTree-&gt;nValue &gt; nNum)</span><br><span class="line">		&#123;</span><br><span class="line">			pTree = pTree-&gt;pLeft;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pTree = pTree-&gt;pRight;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DelNode(int nNum)</span><br><span class="line">&#123;</span><br><span class="line">	//查找</span><br><span class="line">	RBT *pTemp = NULL;</span><br><span class="line">	pTemp = FindNode(pRBT,nNum);</span><br><span class="line"></span><br><span class="line">	if(pTemp == NULL)return;</span><br><span class="line">	</span><br><span class="line">	RBT *pMark = NULL;</span><br><span class="line">	//孩子情况分析</span><br><span class="line">	if(pTemp-&gt;pLeft != NULL &amp;&amp; pTemp-&gt;pRight != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		pMark = pTemp;</span><br><span class="line">		pTemp = pTemp-&gt;pLeft;</span><br><span class="line">		while(pTemp-&gt;pRight != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			pTemp = pTemp-&gt;pRight;</span><br><span class="line">		&#125;</span><br><span class="line">		pMark-&gt;nValue = pTemp-&gt;nValue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//颜色情况讨论</span><br><span class="line">	RBT *pNode = pTemp-&gt;pFather;</span><br><span class="line"></span><br><span class="line">	//1.根</span><br><span class="line">	if(pNode == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		//无子</span><br><span class="line">		if(pTemp-&gt;pLeft == NULL &amp;&amp; pTemp-&gt;pRight == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			free(pTemp);</span><br><span class="line">			pTemp = NULL;</span><br><span class="line">			pRBT = NULL;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		//有一个红子</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pRBT = pTemp-&gt;pLeft ? pTemp-&gt;pLeft : pTemp-&gt;pRight;</span><br><span class="line">			pRBT-&gt;nColor = BLACK;</span><br><span class="line">			pRBT-&gt;pFather = NULL;</span><br><span class="line"></span><br><span class="line">			free(pTemp);</span><br><span class="line">			pTemp = NULL;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.非根</span><br><span class="line">	//2.1节点红</span><br><span class="line">	if(pTemp-&gt;nColor == RED)</span><br><span class="line">	&#123;</span><br><span class="line">		if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pLeft = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pRight = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		free(pTemp);</span><br><span class="line">		pTemp = NULL;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//2.2节点黑色且有一个红子</span><br><span class="line">	if(pTemp-&gt;nColor == BLACK &amp;&amp; (pTemp-&gt;pLeft != NULL || pTemp-&gt;pRight != NULL))</span><br><span class="line">	&#123;</span><br><span class="line">		if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pLeft = pTemp-&gt;pLeft ? pTemp-&gt;pLeft : pTemp-&gt;pRight;</span><br><span class="line">			pNode-&gt;pLeft-&gt;nColor = BLACK;</span><br><span class="line">			pNode-&gt;pLeft-&gt;pFather = pNode;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pRight = pTemp-&gt;pLeft ? pTemp-&gt;pLeft : pTemp-&gt;pRight;</span><br><span class="line">			pNode-&gt;pRight-&gt;nColor = BLACK;</span><br><span class="line">			pNode-&gt;pRight-&gt;pFather = pNode;</span><br><span class="line">		&#125;</span><br><span class="line">		free(pTemp);</span><br><span class="line">		pTemp = NULL;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//节点黑色且无子</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		RBT *pBrother = GetUncle(pTemp);</span><br><span class="line"></span><br><span class="line">		//删除</span><br><span class="line">		if(pTemp == pNode-&gt;pLeft)</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pLeft = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			pNode-&gt;pRight = NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		free(pTemp);</span><br><span class="line">		pTemp = NULL;</span><br><span class="line">		</span><br><span class="line">		//调整</span><br><span class="line">		while(1)</span><br><span class="line">		&#123;</span><br><span class="line">			//兄弟是红色</span><br><span class="line">			if(pBrother-&gt;nColor == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				pNode-&gt;nColor = RED;</span><br><span class="line">				pBrother-&gt;nColor = BLACK;</span><br><span class="line"></span><br><span class="line">				if(pBrother == pNode-&gt;pRight)</span><br><span class="line">				&#123;</span><br><span class="line">					LeftRotate(pNode);</span><br><span class="line">					pBrother = pNode-&gt;pRight;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					RightRotate(pNode);</span><br><span class="line">					pBrother = pNode-&gt;pLeft;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//兄弟是黑色</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				//两个侄子全黑</span><br><span class="line">				if((pBrother-&gt;pLeft == NULL &amp;&amp; pBrother-&gt;pRight == NULL)||</span><br><span class="line">					((pBrother-&gt;pLeft != NULL &amp;&amp; pBrother-&gt;pLeft-&gt;nColor == BLACK) &amp;&amp;</span><br><span class="line">					(pBrother-&gt;pRight != NULL &amp;&amp; pBrother-&gt;pRight-&gt;nColor == BLACK)))</span><br><span class="line">				&#123;</span><br><span class="line">					//父亲为红色</span><br><span class="line">					if(pNode-&gt;nColor == RED)</span><br><span class="line">					&#123;</span><br><span class="line">						pNode-&gt;nColor = BLACK;</span><br><span class="line">						pBrother-&gt;nColor = RED;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					//父为黑色</span><br><span class="line">					else</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = RED;</span><br><span class="line">						pTemp = pNode;</span><br><span class="line">						pNode = pTemp-&gt;pFather;</span><br><span class="line"></span><br><span class="line">						if(pNode == NULL)</span><br><span class="line">						&#123;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						pBrother = GetUncle(pTemp);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				//左侄子红 右侄子黑</span><br><span class="line">				else if((pBrother-&gt;pLeft != NULL &amp;&amp; pBrother-&gt;pLeft-&gt;nColor == RED)&amp;&amp;</span><br><span class="line">					(pBrother-&gt;pRight == NULL || pBrother-&gt;pRight-&gt;nColor == BLACK))</span><br><span class="line">				&#123;</span><br><span class="line">					//兄弟在父亲的右侧</span><br><span class="line">					if(pBrother == pNode-&gt;pRight)</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = RED;</span><br><span class="line">						pBrother-&gt;pLeft-&gt;nColor = BLACK;</span><br><span class="line">						RightRotate(pBrother);</span><br><span class="line">						pBrother = pNode-&gt;pRight;</span><br><span class="line">					&#125;</span><br><span class="line">					//兄弟在父亲的左侧</span><br><span class="line">					else</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = pNode-&gt;nColor;</span><br><span class="line">						pNode-&gt;nColor = BLACK;</span><br><span class="line">						pBrother-&gt;pLeft-&gt;nColor = BLACK;</span><br><span class="line">						RightRotate(pNode);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				//右侄子为红色</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					//兄弟在父亲左侧</span><br><span class="line">					if(pBrother == pNode-&gt;pLeft)</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = RED;</span><br><span class="line">						pBrother-&gt;pRight-&gt;nColor = BLACK;</span><br><span class="line">						LeftRotate(pBrother);</span><br><span class="line">						pBrother = pNode-&gt;pLeft;</span><br><span class="line">					&#125;</span><br><span class="line">					//兄弟在父亲的右侧</span><br><span class="line">					else</span><br><span class="line">					&#123;</span><br><span class="line">						pBrother-&gt;nColor = pNode-&gt;nColor;</span><br><span class="line">						pNode-&gt;nColor = BLACK;</span><br><span class="line">						pBrother-&gt;pRight-&gt;nColor = BLACK;</span><br><span class="line">						LeftRotate(pNode);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>红黑树的增删查的时间复杂度都是log2n</p>
<p>红黑树的应用：进程管理，内存管理，epoll模型</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>适合作为索引的结构搜索速度必须要快，有三种结构：哈希表，RBT，B+树</p>
<p>哈希表的弊端：空间固定，适合处理数据量比较少的数据</p>
<p>RBT：搜索速度快，适合频繁增删，适合处理数量不确定的数据，非常适合在内存中使用</p>
<p>B+树：适合多路的平衡搜索树。层高低，适合用于磁盘里，进行磁盘的寻址。</p>
<p>MYSQL中的索引的实现就是应用B+树</p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>m阶</p>
<p>所有的节点都是key-value结构</p>
<h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><blockquote>
<p>1.每个节点最多有m-1个关键字</p>
<p>2.根节点最少可以有一个关键字</p>
<p>3.每个节点最少有ceil(m&#x2F;2)-1个关键字</p>
<p>4.每个节点的关键字都按照从小到大的顺序排列，每个关键字的左子树的所有关键字都小于它，右子树的关键字都大于它</p>
<p>5.所有叶子节点都位于同一层</p>
</blockquote>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675344373357.png" alt="1675344373357"></p>
<h5 id="B-Tree插入"><a href="#B-Tree插入" class="headerlink" title="B-Tree插入"></a>B-Tree插入</h5><p>插入：（键值对：记录）</p>
<p>如果要插入的记录已经存在，用需要插入的value替换旧的value</p>
<p>如果要插入的记录不在</p>
<blockquote>
<p>1.根据要插入的key，找到叶子节点并插入</p>
<p>2.判断节点关键字的个数是否小于m-1，</p>
<p>小于，操作结束；</p>
<p>大于，当前节点发生裂变，以中间节点为中心，分裂成左右两部分，中间关键字上升至父节点中，这个关键字的左子树指向分裂后的左半部分，右子树指向分裂后的右半部分</p>
<p>父亲结点作为新的操作结点重新讨论</p>
</blockquote>
<h5 id="B-Tree删除"><a href="#B-Tree删除" class="headerlink" title="B-Tree删除"></a>B-Tree删除</h5><blockquote>
<p>1.当前被删除关键字key在非叶子结点，则采取替换方式，用后继key覆盖要删除的key（最后要删除的关键字一定在叶子节点）</p>
<p>2.删除之后，当前节点的关键字个数大于ceil(m&#x2F;2)-1，则结束</p>
<p>3.删除之后，当前节点的关键字个数不大于ceil(m&#x2F;2)-1，看兄弟节点的个数是否大于ceil(m&#x2F;2)-1</p>
<p>大于：将父亲节点内的关键字下移至当前节点，兄弟节点的关键字上移至父亲节点</p>
<p>等于：父亲节点的一个key下移，与当前节点以及当前节点的兄弟节点合并成一个新节点</p>
</blockquote>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B-Tree无法进行范围搜索</p>
<p>B+Tree：多路平衡搜索树</p>
<blockquote>
<p>1.B+树包含两种类型的节点：内部节点（索引节点），叶子节点</p>
<p>只有叶子节点才包含真正的数据内容，剩下的节点里只有关键字（根结点可以是内部节点也可以是叶子节点）</p>
<p>2.B+树与B树不同于内部节点不保存数据，只适用于与索引，所有记录都保存在叶子节点</p>
<p>3.M阶B+节点内最多有m-1个关键字</p>
<p>4.关键字值在节点内部，按照从小到大的顺序排列，对于一个内部节点，左子树的所有key均小于它，右子树的key均大于它</p>
<p>5.每个叶子节点都存有指向相邻叶子节点的指针，叶子节点本身依关键字的大小从小到大顺序链接</p>
</blockquote>
<h5 id="B-树插入"><a href="#B-树插入" class="headerlink" title="B+树插入"></a>B+树插入</h5><blockquote>
<p>1.空树，创建一个叶子节点，把记录放入其中，此时这个叶子节点也是根结点</p>
<p>2.根据key值可以找到对应的叶子节点进行插入，判断当前结点的关键字个数</p>
<p>小于等于m-1，插入结束</p>
<p>大于m-1，分裂，左叶子节点包含前m&#x2F;2个记录，右叶子节点包含剩余的记录</p>
<p>第m&#x2F;2+1个记录的key进位到父亲结点中</p>
<p>3.如果父亲结点满足关键字的个数小于等于m-1，结束</p>
<p>若不满足，裂变</p>
</blockquote>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675347696332.png" alt="1675347696332"></p>
<h3 id="冒泡排序：BubbleSort"><a href="#冒泡排序：BubbleSort" class="headerlink" title="冒泡排序：BubbleSort"></a>冒泡排序：BubbleSort</h3><p>核心思想：相邻两个元素进行大小比较，如果前一个比后一个大，交换</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675214291252.png" alt="1675214291252"></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/">数据结构笔记</a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage"></a></p>
        <p><span>Created:</span>2023-02-02, 22:33:55</p>
        <p><span>Updated:</span>2023-02-02, 22:36:59</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/" title="数据结构笔记">http://example.com/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/</a>
            <span class="copy-path" data-clipboard-text="From http://example.com/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/　　By " title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/">
                    C++11新特性
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2023/01/31/hexo%E4%BD%BF%E7%94%A8/">
                    hexo使用
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E9%AA%8C%E6%80%A7%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">经验性结论：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">线性结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%9A%E7%A9%BA%E9%97%B4%E8%BF%9E%E7%BB%AD%EF%BC%8C%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%90%8C"><span class="toc-number">4.1.</span> <span class="toc-text">数组：空间连续，类型相同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">数组和链表的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E7%BD%AE%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">单链表倒置：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E9%87%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">链表重置：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">合并链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">单链表相交问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">5.5.</span> <span class="toc-text">循环链表的特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E7%8E%AF%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%89%BE%E5%88%B0%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><span class="toc-number">5.6.</span> <span class="toc-text">判断单链表是否有环，如果有环的话，找到环的入口节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">5.7.</span> <span class="toc-text">复杂链表的复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8HashTable"><span class="toc-number">6.</span> <span class="toc-text">哈希表HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%88BackTracking%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">回溯法（BackTracking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">回溯法解决的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">7.2.</span> <span class="toc-text">回溯算法模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">7.3.</span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E4%BB%A3%E7%A0%81"><span class="toc-number">7.4.</span> <span class="toc-text">全排列代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">8.</span> <span class="toc-text">正则表达式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8%EF%BC%9ASkipList"><span class="toc-number">9.</span> <span class="toc-text">跳跃列表：SkipList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">递归：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">10.1.</span> <span class="toc-text">青蛙跳台阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%EF%BC%9A"><span class="toc-number">10.2.</span> <span class="toc-text">斐波那契递归写法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">分治法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%89Binary-Chop%EF%BC%9A%E5%89%8D%E6%8F%90%EF%BC%9A%E5%AF%B9%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E6%9F%A5%E6%89%BE"><span class="toc-number">11.1.</span> <span class="toc-text">二分查找（折半查找）Binary Chop：前提：对有序数组进行查找</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%EF%BC%88stack%EF%BC%89%EF%BC%9A%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%EF%BC%89FIFO"><span class="toc-number">12.</span> <span class="toc-text">栈（stack）：（数据结构栈）FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">队列（FIFO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">14.</span> <span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">15.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2"><span class="toc-number">15.1.</span> <span class="toc-text">字符串空格替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%92%E7%BD%AE"><span class="toc-number">15.2.</span> <span class="toc-text">字符串倒置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%AD%97%E7%AC%A6"><span class="toc-number">15.3.</span> <span class="toc-text">寻找字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kmp"><span class="toc-number">15.4.</span> <span class="toc-text">kmp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sunday"><span class="toc-number">15.5.</span> <span class="toc-text">Sunday</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">树形结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">满二叉树：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">完全二叉树：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.</span> <span class="toc-text">二叉树的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">递归遍历：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">非递归遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.3.</span> <span class="toc-text">广度遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">完全二叉树的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-x2F-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">二叉搜索树&#x2F;排序二叉树（BST）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">构建排序二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">3.2.</span> <span class="toc-text">排序二叉树的删除</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E3%80%82%E6%AF%94%E5%A6%82%EF%BC%9A2-5-9-12"><span class="toc-number">3.2.1.</span> <span class="toc-text">第一种情况：删除叶子结点。比如：2,5,9,12.</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%88%A0%E9%99%A4%E5%8F%AA%E6%9C%89%E4%B8%80%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E3%80%82%E6%AF%94%E5%A6%82%EF%BC%9A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">第二种情况：删除只有一棵子树的结点。比如：1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%88%A0%E9%99%A4%E6%9C%89%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E3%80%82%E6%AF%94%E5%A6%82%EF%BC%9A7-3-10%E3%80%82"><span class="toc-number">3.2.3.</span> <span class="toc-text">第三种情况：删除有两棵子树的结点。比如：7,3,10。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E6%A3%B5%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%89%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">如何将一棵排序二叉树转变为有序的双向链表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-x2F-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">平衡二叉树&#x2F;平衡二叉搜索树（AVL树）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B"><span class="toc-number">4.1.</span> <span class="toc-text">右旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.2.</span> <span class="toc-text">旋转的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B"><span class="toc-number">4.3.</span> <span class="toc-text">左旋</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">5.1.</span> <span class="toc-text">红黑树的插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">5.2.</span> <span class="toc-text">红黑树的删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">6.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Tree"><span class="toc-number">7.</span> <span class="toc-text">B-Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E5%88%B6"><span class="toc-number">7.1.</span> <span class="toc-text">限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree%E6%8F%92%E5%85%A5"><span class="toc-number">7.2.</span> <span class="toc-text">B-Tree插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree%E5%88%A0%E9%99%A4"><span class="toc-number">7.3.</span> <span class="toc-text">B-Tree删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">8.</span> <span class="toc-text">B+Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E6%8F%92%E5%85%A5"><span class="toc-number">8.1.</span> <span class="toc-text">B+树插入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9ABubbleSort"><span class="toc-number"></span> <span class="toc-text">冒泡排序：BubbleSort</span></a>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide"  title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"数据结构笔记　| 蔡胖子　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/" title="Pre: C++11新特性">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2023/01/31/hexo%E4%BD%BF%E7%94%A8/" title="Next: hexo使用">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/">C++11新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/">数据结构笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/31/hexo%E4%BD%BF%E7%94%A8/">hexo使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/31/%E5%B9%B3%E6%B7%A1%E7%9A%84%E8%A5%BF%E7%93%9C/">平淡的西瓜</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/31/C++%E7%AC%94%E8%AE%B0/">C++笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/26/hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2023 蔡胖子
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>