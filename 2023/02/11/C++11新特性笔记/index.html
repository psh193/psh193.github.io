<!DOCTYPE html>
<html lang="en">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="蔡胖子" />



<meta name="description" content="[TOC] 一、什么是C++11C++11是对C++语言的扩展和修正，不仅包含核心语言的新技能，而且扩展了C++的标准程序库STL，并入了大部分的C++TR1程序库。 C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进 IDE1、QT Creator  新建一个纯C++的项目，在项目文件配置：CONFIG +&#x3D; c++11 2、">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11新特性">
<meta property="og:url" content="http://example.com/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="蔡胖子">
<meta property="og:description" content="[TOC] 一、什么是C++11C++11是对C++语言的扩展和修正，不仅包含核心语言的新技能，而且扩展了C++的标准程序库STL，并入了大部分的C++TR1程序库。 C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进 IDE1、QT Creator  新建一个纯C++的项目，在项目文件配置：CONFIG +&#x3D; c++11 2、">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675929655329.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675997770566.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675997814764.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675997888090.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675999454074.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676015519947.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676015704535.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676015834401.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676016293690.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676019157830.png">
<meta property="og:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676036165671.png">
<meta property="article:published_time" content="2023-02-11T08:03:53.000Z">
<meta property="article:modified_time" content="2023-02-11T08:03:15.903Z">
<meta property="article:author" content="蔡胖子">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675929655329.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="蔡胖子" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">




<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>C++11新特性 | 蔡胖子</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/caicai.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:2195361512@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="/psh193" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" href="/qq_52464789" title="CSDN"></a>
                            
                                <a class="fa QQ" href="/2195361512" title="QQ"></a>
                            
                                <a class="fa 微信" href="/pshlpjswaxx" title="微信"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/caicai.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:2195361512@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="/psh193" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="/qq_52464789" title="CSDN"></a>
                            
                                <a class="fa QQ" target="_blank" href="/2195361512" title="QQ"></a>
                            
                                <a class="fa 微信" target="_blank" href="/pshlpjswaxx" title="微信"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap"><article id="post-C++11新特性笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/" class="article-date">
      <time datetime="2023-02-11T08:03:53.000Z" itemprop="datePublished">2023-02-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++11新特性
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>[TOC]</p>
<h2 id="一、什么是C-11"><a href="#一、什么是C-11" class="headerlink" title="一、什么是C++11"></a>一、什么是C++11</h2><p>C++11是对C++语言的扩展和修正，不仅包含核心语言的新技能，而且扩展了C++的标准程序库STL，并入了大部分的C++TR1程序库。</p>
<p>C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进</p>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>1、QT Creator  新建一个纯C++的项目，在项目文件配置：CONFIG +&#x3D; c++11</p>
<p>2、终端，g++  xxx.cpp  -std&#x3D;c++11</p>
<h2 id="二、类型推导"><a href="#二、类型推导" class="headerlink" title="二、类型推导"></a>二、类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><h4 id="在C中"><a href="#在C中" class="headerlink" title="在C中"></a>在C中</h4><p>auto修饰局部变量，局部变量也叫auto变量，自动变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    auto int a;</span><br><span class="line">&#125;</span><br><span class="line">//二者是等价的</span><br><span class="line">//加不加auto，在这个作用域下都是局部变量</span><br><span class="line">//自动变量：因为是在栈区，自动分配空间，同时自动维护</span><br></pre></td></tr></table></figure>

<h4 id="在C-11中"><a href="#在C-11中" class="headerlink" title="在C++11中"></a>在C++11中</h4><p>根据用户初始化内容自动推导类型</p>
<p> 注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">double foo()</span><br><span class="line">&#123;</span><br><span class="line">	return 1.1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Test</span><br><span class="line">&#123;</span><br><span class="line">	int a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(vector&lt;int&gt; &amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">	for(auto i = tmp.begin();i!=tmp.end()l++i)</span><br><span class="line">		//......</span><br><span class="line">	//循环中不需要写变量类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 1;//需要先声明变量类型然后内存分配空间</span><br><span class="line">	auto b = 1;//使用auto，根据赋值自动推导类型，b的类型就是int，不需要				//再声明类型</span><br><span class="line">	auto c = foo();//c的类型就是double</span><br><span class="line">	</span><br><span class="line">	auto p = &amp;n;//&amp;n 的结果是一个 int* 类型的指针，所以推导出变量 p 的类型是 int*。</span><br><span class="line">	auto url = &quot;http://c.biancheng.net/cplus/&quot;;</span><br><span class="line">	//由双引号&quot;&quot;包围起来的字符串是 const char* 类型，所以推导出变量 url 的类型是 const 	//char*，也即一个常量指针。</span><br><span class="line">	</span><br><span class="line">	Test str = &#123;0&#125;;</span><br><span class="line">	auto d = str;//d的类型就是struct Test</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让用户写代码更加简洁，更加方便</p>
<h4 id="auto高级用法"><a href="#auto高级用法" class="headerlink" title="auto高级用法"></a>auto高级用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int  x = 0;</span><br><span class="line">auto *p1 = &amp;x;   //p1 为 int *，auto 推导为 int</span><br><span class="line">auto  p2 = &amp;x;   //p2 为 int*，auto 推导为 int*</span><br><span class="line">auto &amp;r1  = x;   //r1 为 int&amp;，auto 推导为 int</span><br><span class="line">auto r2 = r1;    //r2 为  int，auto 推导为 int</span><br></pre></td></tr></table></figure>

<ul>
<li>第 2 行代码中，p1 为 int* 类型，也即 auto * 为 int *，所以 auto 被推导成了 int 类型。</li>
<li>第 3 行代码中，auto 被推导为 int* 类型，前边的例子也已经演示过了。</li>
<li>第 4 行代码中，r1 为 int &amp; 类型，auto 被推导为 int 类型。</li>
<li>第 5 行代码是需要重点说明的，r1 本来是 int&amp; 类型，但是 auto 却被推导为 int 类型，这表明当<code>=</code>右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int  x = 0;</span><br><span class="line">const  auto n = x;  //n 为 const int ，auto 被推导为 int</span><br><span class="line">auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）</span><br><span class="line">const auto &amp;r1 = x;  //r1 为 const int&amp; 类型，auto 被推导为 int</span><br><span class="line">auto &amp;r2 = r1;  //r1 为 const int&amp; 类型，auto 被推导为 const int 类型</span><br></pre></td></tr></table></figure>

<ul>
<li>当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</li>
<li>当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li>
</ul>
<h4 id="auto易错点"><a href="#auto易错点" class="headerlink" title="auto易错点"></a>auto易错点</h4><blockquote>
<p>1、定义变量时，必须初始化（根据初始化的类型推导类型）</p>
<p>2、vs2013不支持函数形参是auto变量，qt是可以的</p>
<p>3、auto变量不能作为自定义类型的成员变量， 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。 </p>
<p>4、不能是auto数组</p>
<p>5、模板实例化类型不能是auto类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//2.</span><br><span class="line">void func(auto a)//</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.</span><br><span class="line">struct Test</span><br><span class="line">&#123;</span><br><span class="line">	int a;</span><br><span class="line">	auto b = 10;//初始化后也不可以</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//1.</span><br><span class="line">	auto a;</span><br><span class="line">	a = 10;//这种定义方式是错误的</span><br><span class="line">	</span><br><span class="line">	//4.</span><br><span class="line">	auto b[3] = &#123;1,2,3&#125;;</span><br><span class="line">	</span><br><span class="line">	//5.</span><br><span class="line">	vector&lt;int&gt; a;//正确</span><br><span class="line">	vector&lt;auto&gt; b = &#123;1&#125;;//错误,即使是有初始化也是不可以的</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>根据已经定义类型的变量，获取这个类型，可以继续用这个类型定义变量</p>
<p> decltype 是“declare type”的缩写，译为“声明类型”。 </p>
<h4 id="decltype推导规则"><a href="#decltype推导规则" class="headerlink" title="decltype推导规则"></a>decltype推导规则</h4><ul>
<li><p>如果 exp 是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</p>
</li>
<li><p>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</p>
</li>
<li><p>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</p>
</li>
<li><p>&#96;&#96;&#96;<br>&#x2F;&#x2F;加法表达式<br>int n &#x3D; 0, m &#x3D; 0;<br>decltype(n + m) c &#x3D; 0;  &#x2F;&#x2F;n+m 得到一个右值，符合推导规则一，所以推导结果为 int<br>decltype(n &#x3D; n + m) d &#x3D; c;  &#x2F;&#x2F;n&#x3D;n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注： 左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>#include<typeinfo> &#x2F;&#x2F;typeid</p>
<p>int main()<br>{<br>    int i;<br>    decltype(i) j &#x3D; 0;<br>    cout&lt;&lt;typeid(j).name()&lt;&lt;endl;&#x2F;&#x2F;int</p>
<pre><code>float a;
double b;
decltype(a+b) c;
cout&lt;&lt;typeid(c).name()&lt;&lt;endl;//double

//配合类型模板使用
vector&lt;int&gt; tmp;
decltype(tmp.begin()) k;
for(k=tmp.begin();k!=tmp.end();++k)
&#123;
    //......
&#125;

enum &#123;Ok,Error&#125; flag;//匿名类型的枚举变量
                    //由于是匿名的类型所以只能使用一次
decltype(flag) flag2;//但是用decltype获取之后还可以再次定义
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> `T::iterator`并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</span><br><span class="line"></span><br><span class="line">要想解决这个问题，在之前的 C++98/03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写： </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>template <typename T><br>class Base {<br>public:<br>    void func(T&amp; container) {<br>        m_it &#x3D; container.begin();<br>    }<br>private:<br>    decltype(T().begin()) m_it;  &#x2F;&#x2F;注意这里<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### auto和decltype的区别</span><br><span class="line"></span><br><span class="line">1、语法格式的区别</span><br><span class="line"></span><br><span class="line">auto根据=右边的初始值推导出变量的类型，要求必须初始化</span><br><span class="line"></span><br><span class="line">decltype根据exp表达式推导出变量的类型，跟=右边的value没关系，不要求初始化</span><br><span class="line"></span><br><span class="line">2、对cv限定符的处理</span><br><span class="line"></span><br><span class="line">「cv 限定符」是 const 和 volatile 关键字的统称：</span><br><span class="line"></span><br><span class="line">- const 关键字用来表示数据是只读的，也就是不能被修改；</span><br><span class="line">- volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取。</span><br><span class="line"></span><br><span class="line">auto：如果表达式的类型不是指针或引用，会直接把cv限定符抛弃</span><br><span class="line"></span><br><span class="line">​			如果表达式的类型是指针或引用，将保留cv限定符</span><br><span class="line"></span><br><span class="line">decltype：不会去掉表达式的const属性</span><br><span class="line"></span><br><span class="line">3、对引用的处理</span><br><span class="line"></span><br><span class="line">auto会抛弃引用类型</span><br><span class="line"></span><br><span class="line">decltype会保留引用类型</span><br><span class="line"></span><br><span class="line">### 追踪返回类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;传统写法，必须要确定参数类型，才能确定返回类型<br>int func1(int a,int b)<br>{<br>    return a+b;<br>}</p>
<p>auto func2(int a,int b)-&gt; int<br>{<br>    return a+b;<br>}</p>
<p>&#x2F;&#x2F;根据decltype获取运算后的类型然后返回<br>auto func3(int a,double b)-&gt; decltype(a+b)<br>{<br>    retrurn a+b;<br>}</p>
<p>&#x2F;&#x2F;配合模板来使用<br>&#x2F;&#x2F;不用确定参数的类型<br>template&lt;class T1,class T2&gt;<br>auto mul(const T1 &amp;t1,const T2 &amp;t2)-&gt; decltype(t1<em>t2)<br>{<br>    return t1</em>t2;<br>    &#x2F;&#x2F;两者相乘结果是什么类型返回值就是什么类型<br>}</p>
<p>int main()<br>{<br>    int a&#x3D;10;<br>    double b &#x3D; 11.1;<br>    auto c &#x3D; func3(10,11.1);<br>    cout&lt;&lt;”c&#x3D;”&lt;&lt;c&lt;&lt;endl;&#x2F;&#x2F;21.1</p>
<pre><code>auto i = 10;
auto j = 11.2;
auto k = mul(i,j);
cout&lt;&lt;&quot;k=&quot;&lt;&lt;k&lt;&lt;endl;//112
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 三、易用性的改进</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### </span><br><span class="line"></span><br><span class="line">### tuple元组</span><br><span class="line"></span><br><span class="line">tuple是一个固定大小的不同类型值的集合</span><br><span class="line"></span><br><span class="line">tuple一种类模板</span><br><span class="line"></span><br><span class="line">tuple特点：实例化的对象可以存储任意数量、任意类型的数据。</span><br><span class="line"></span><br><span class="line">应用场景：当需要存储多个不同类型的数据；当函数需要返回多个数据时，可以将这些数据存储到tuple中，函数只需要返回一个tuple对象即可</span><br><span class="line"></span><br><span class="line">#### tuple对象的创建</span><br><span class="line"></span><br><span class="line">tuple本质是一个以刻板参数定义的类模板，定义在&lt;tuple&gt;头文件并位与std命名空间中，因此想要使用，要引入一下代码</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">#include &lt;tuple&gt;</span><br><span class="line">using std::tuple;</span><br></pre></td></tr></table></figure>

<p>实例化tuple模板类对象方法：1.借助该类的构造函数。2.借助make_tuple()函数。</p>
<h5 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h5><p>tuple模板类有很多构造函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line">constexpr <span class="title function_">tuple</span><span class="params">()</span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line">tuple (<span class="type">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line">tuple (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line">template &lt;class... UTypes&gt;</span><br><span class="line">    tuple (<span class="type">const</span> tuple&lt;UTypes...&gt;&amp; tpl); <span class="comment">//左值方式</span></span><br><span class="line">template &lt;class... UTypes&gt;</span><br><span class="line">    tuple (tuple&lt;UTypes...&gt;&amp;&amp; tpl);      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line">explicit <span class="title function_">tuple</span> <span class="params">(<span class="type">const</span> Types&amp;... elems)</span>;  <span class="comment">//左值方式</span></span><br><span class="line">template &lt;class... UTypes&gt;</span><br><span class="line">    explicit <span class="title function_">tuple</span> <span class="params">(UTypes&amp;&amp;... elems)</span>;  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将<span class="built_in">pair</span>对象转换为tuple对象</span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="keyword">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line">    tuple (<span class="type">const</span> <span class="built_in">pair</span>&lt;U1,U2&gt;&amp; pr);       <span class="comment">//左值方式</span></span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="keyword">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line">    tuple (<span class="built_in">pair</span>&lt;U1,U2&gt;&amp;&amp; pr);            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure>

<p>举个栗子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        <span class="comment">// std::tuple</span></span></span><br><span class="line">using <span class="built_in">std</span>::tuple;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">second</span><span class="params">(first)</span>;                     <span class="comment">// 2)   second&#123;&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">third</span><span class="params">(<span class="built_in">std</span>::make_tuple(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>))</span>;   <span class="comment">// 3)   third&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="type">long</span>, <span class="type">char</span>&gt; <span class="title function_">fourth</span><span class="params">(third)</span>;                    <span class="comment">// 4)的左值方式, fourth&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">fifth</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span>;                    <span class="comment">// 5)的右值方式, fifth&#123;10.&#x27;a&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">sixth</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>))</span>;    <span class="comment">// 6)的右值方式, sixth&#123;30,&#x27;&#x27;c&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="make-tuple-函数"><a href="#make-tuple-函数" class="headerlink" title="make_tuple()函数"></a>make_tuple()函数</h5><p>该函数的功能是创建一个tuple右值对象（或临时对象）。</p>
<p>tuple的使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::make_tuple (<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = <span class="built_in">std</span>::make_tuple (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br></pre></td></tr></table></figure>

<p>分别创建了两个对象，first，second</p>
<h4 id="tuple常用函数"><a href="#tuple常用函数" class="headerlink" title="tuple常用函数"></a>tuple常用函数</h4><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675929655329.png" alt="1675929655329"></p>
<p>tuple模板类对赋值运算符&#x3D;进行了重载，使得同类型的tuple对象可以直接赋值。</p>
<p>此外，tuple模板类还重载&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D;这几个比较运算符，同类型的tuple对象可以相互比较（逐个比较各个元素）</p>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 &#x27;x&#x27;</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">mytuple</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span>;</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    size = <span class="built_in">std</span>::tuple_size&lt;decltype(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_tuple(<span class="string">&quot;test&quot;</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mystr = nullptr;</span><br><span class="line">    <span class="type">double</span> mydou;</span><br><span class="line">    <span class="type">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    <span class="built_in">std</span>::tie(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = <span class="built_in">std</span>::tuple_cat(mytuple, bar);</span><br><span class="line">    size = <span class="built_in">std</span>::tuple_size&lt;decltype(mycat)&gt;::value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; size &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">10 x</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="类内成员初始化"><a href="#类内成员初始化" class="headerlink" title="类内成员初始化"></a>类内成员初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统初始化，根据构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	A(<span class="type">int</span> i): a(i)<span class="comment">//参数列表初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		a = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新特性可以直接给类内成员初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	<span class="type">int</span> data&#123;<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="type">int</span> data2 = <span class="number">1</span>;</span><br><span class="line">	A tmp&#123;<span class="number">10</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> name&#123;<span class="string">&quot;mike&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	B obj;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;obj.data&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;obj.data2&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;obj.tmp.a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//10</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;obj.name&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//mike</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">tmp</span> =</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;mike&quot;</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b = &#123;<span class="number">1</span>&#125;;<span class="comment">//ok，列表初始化 </span></span><br><span class="line">	<span class="type">int</span> c&#123;<span class="number">2</span>&#125;;<span class="comment">//ok，列表初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//传统</span></span><br><span class="line">	<span class="type">int</span> arr[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//列表初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span>* a = new <span class="type">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="type">double</span> b = <span class="type">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line">    <span class="type">int</span>* arr = new <span class="type">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值123。</span></span><br><span class="line"><span class="comment">     b则是对匿名对象使用列表初始化后，再进行拷贝初始化。</span></span><br><span class="line"><span class="comment">     arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 列表初始化还可以直接使用在函数的返回值上： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="C中的类型收窄"><a href="#C中的类型收窄" class="headerlink" title="C中的类型收窄"></a>C中的类型收窄</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 1024;</span><br><span class="line">	char b = a;//OK，数据丢失，类型收窄</span><br><span class="line">	printf(&quot;b = %d\n&quot;,b);//0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表初始化防止类型收窄"><a href="#列表初始化防止类型收窄" class="headerlink" title="列表初始化防止类型收窄"></a>列表初始化防止类型收窄</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 1024;</span><br><span class="line">	char b = &#123;a&#125;;//错误，从int转换到char需要收缩转换</span><br><span class="line">	//有些编译器是可以允许通过的，但是数据丢失</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>前提是范围是确定的，否则无法使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void func(int a[])</span><br><span class="line">&#123;</span><br><span class="line">	//形参中的数组不是数组，是指针变量，无法确定元素个数，范围是不确定的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">	int n = sizeof(a)/sizeof(*a);//元素个数</span><br><span class="line">	</span><br><span class="line">	//1、</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int tmp = a[i];</span><br><span class="line">		cout&lt;&lt;tmp&lt;&lt;&quot;,&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//基于范围的for循环</span><br><span class="line">	for(int tmp:a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;tmp&lt;&lt;&quot;,&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//2、引用可以更改元素内容</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int &amp;tmp = a[i];</span><br><span class="line">		tmp = 2 * tmp;</span><br><span class="line">		cout&lt;&lt;tmp&lt;&lt;&quot;,&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//基于范围的for循环</span><br><span class="line">	for(int &amp;tmp:a)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = 2 * tmp;</span><br><span class="line">		cout&lt;&lt;tmp&lt;&lt;&quot;,&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h3><p>传统断言</p>
<p>在运行时检查条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	bool flag = false;</span><br><span class="line">	</span><br><span class="line">	//运行时，检查条件，如果条件为真，往下执行，如果条件为假，中断，提示错误</span><br><span class="line">	//assert(flag == true);//条件为假，程序中断</span><br><span class="line">	assert(flag == false);//条件为真，往下执行</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;&quot;hello C++\n&quot;;</span><br><span class="line">	</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 11 新增了关键字static_assert,可用于在编译阶段对断言进行测试。</p>
<p>静态断言的好处：</p>
<blockquote>
<p>1.更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</p>
<p>2.减少运行时开销，静态断言是编译期检测的，减少了运行时的开销</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//static_assert(常量表达式条件，&quot;提示的字符串&quot;)</span><br><span class="line">	</span><br><span class="line">	//检测系统是否是32位</span><br><span class="line">	static_assert(sizeof(void *) == 4,&quot;64位系统不支持&quot;);</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;&quot;hello C++\n&quot;;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="noexcept修饰符"><a href="#noexcept修饰符" class="headerlink" title="noexcept修饰符"></a>noexcept修饰符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void func01()</span><br><span class="line">&#123;</span><br><span class="line">	throw 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个函数不能抛出任何异常</span><br><span class="line">void func02() throw()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个函数不能抛出任何异常</span><br><span class="line">//noexcept vs2013 不支持，换在qt下测试</span><br><span class="line">void func03() noexcept</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>NULL是一个宏，整型数字，代表整数0</p>
<p>nullptr关键字，代表空指针，只能给指针赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void func(int a)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;__LINE__&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(int *a)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;__LINE__&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int * p = NULL;</span><br><span class="line">	int *p2 = 0;</span><br><span class="line">	</span><br><span class="line">	func(nullptr);//3</span><br><span class="line">	</span><br><span class="line">	//nullptr只能给指针赋值</span><br><span class="line">	p = NULL;</span><br><span class="line">	p2 = nullptr;</span><br><span class="line">	if(p == p2)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;equal\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//不能给一个普通整型变量赋值给nullptr</span><br><span class="line">	int tmp = nullptr;//错误：无法从nullptr转换为int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><h4 id="传统枚举局限性"><a href="#传统枚举局限性" class="headerlink" title="传统枚举局限性"></a>传统枚举局限性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	enum Status &#123;Ok,Error&#125;;</span><br><span class="line">	enum Status2 &#123;Ok,Error&#125;;</span><br><span class="line">	//错误：Ok重定义</span><br><span class="line">	</span><br><span class="line">	Status flag = Ok;</span><br><span class="line">	//1.在这个作用域里是一个共享的变量,再定义就会重名</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;sizeof(Ok)&lt;&lt;endl;//4</span><br><span class="line">	//2.不能指定枚举成员的指定类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="强类型枚举-1"><a href="#强类型枚举-1" class="headerlink" title="强类型枚举"></a>强类型枚举</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//强类型枚举，enum后面加上class或struct修饰</span><br><span class="line">	enum class Status &#123;Ok,Error&#125;;</span><br><span class="line">	enum struct Status2 &#123;Ok,Error&#125;;</span><br><span class="line">	</span><br><span class="line">	//Status flag = Ok;//error：必须加上枚举类型的作用域</span><br><span class="line">	Status flag = Status::Ok;</span><br><span class="line">	</span><br><span class="line">	enum struct Status3:char &#123;Ok,Error&#125;;</span><br><span class="line">	cout&lt;&lt;sizeof(Status::Ok)&lt;&lt;endl;//1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.不会出现重定义的情况</p>
<p>2.赋值的时候必须加上枚举类型的作用域进行强制转换</p>
<p>3.强类型枚举，可以指定成员变量的类型</p>
</blockquote>
<h3 id="常量表达式（vs2013-不支持）"><a href="#常量表达式（vs2013-不支持）" class="headerlink" title="常量表达式（vs2013 不支持）"></a>常量表达式（vs2013 不支持）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int GetNum()</span><br><span class="line">&#123;</span><br><span class="line">	return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int GetNum2()</span><br><span class="line">&#123;</span><br><span class="line">	return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constexpr int GetNum3()</span><br><span class="line">&#123;</span><br><span class="line">//常量表达式，发生在编译阶段</span><br><span class="line">	return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//error：枚举成员初始化，必须是整形常量</span><br><span class="line">	//而GetNum（）的返回值是运行时才有，不是常量</span><br><span class="line">	//enum &#123;e1 = GetNum(),e2&#125;;//枚举类型，err</span><br><span class="line">	</span><br><span class="line">	enum &#123;e1 = GetNum3(),e2&#125;;</span><br><span class="line">	</span><br><span class="line">	constexpr int tmp = GetNum3();//ok,发生在编译阶段</span><br><span class="line">	enum &#123;a1 = tmp,a2&#125;;//ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="constexpr函数的限制："><a href="#constexpr函数的限制：" class="headerlink" title="constexpr函数的限制："></a>constexpr函数的限制：</h4><blockquote>
<p>函数中只能有一个return语句（有极少特例）</p>
<p>函数必须有返回值</p>
<p>在使用前必须已经有定义</p>
<p>return返回语句表达式中不能使用非常量表达式、全局数据，且必须是一个常量表达式</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">constexpr <span class="type">int</span> <span class="title function_">func01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//err,函数中只能有一个return语句</span></span><br><span class="line">    constexpr <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//err ,return返回语句表达式中不能使用非常量表达式的函数</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">constexpr <span class="type">int</span> <span class="title function_">func02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a;<span class="comment">//返回全局数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#end <span class="keyword">if</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    constexpr <span class="type">int</span> <span class="title function_">func03</span><span class="params">()</span>;<span class="comment">//声明</span></span><br><span class="line">    constexpr <span class="type">int</span> tmp = func03();<span class="comment">//err，在使用前必须已经有定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constexpr <span class="type">int</span> <span class="title function_">func03</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类中成员是常量表达式"><a href="#类中成员是常量表达式" class="headerlink" title="类中成员是常量表达式"></a>类中成员是常量表达式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> public:</span><br><span class="line">    <span class="comment">//constexpr修饰构造函数，构造函数体必须为空</span></span><br><span class="line">    constexpr <span class="title function_">Data</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d)</span>:<span class="title function_">year</span><span class="params">(y)</span>,<span class="title function_">month</span><span class="params">(m)</span>,<span class="title function_">day</span><span class="params">(d)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    constexpr <span class="type">int</span> <span class="title function_">GetYear</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    &#125;</span><br><span class="line">    constexpr <span class="type">int</span> <span class="title function_">GetMonth</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> month;</span><br><span class="line">    &#125;</span><br><span class="line">    constexpr <span class="type">int</span> <span class="title function_">GetDay</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line"> private:</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    constexpr Data <span class="title function_">obj</span><span class="params">(<span class="number">2017</span>,<span class="number">10</span>,<span class="number">10</span>)</span>;<span class="comment">//必须使用常量给构造函数传参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="constexpr和const的区别"><a href="#constexpr和const的区别" class="headerlink" title="constexpr和const的区别"></a>constexpr和const的区别</h4><p>在 C++ 11 标准中，const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。 </p>
<p>用const修饰的变量是“只读”变量，本质上还是个变量，不可以用来初始化容器大小，</p>
<p>但是constexpr修饰的是常量，可以用来初始化容器大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">constexpr <span class="type">int</span> <span class="title function_">sqr1</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="title function_">sqr2</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="type">int</span>,sqr1(<span class="number">10</span>)&gt; mylist1;<span class="comment">//可以，因为sqr1时constexpr函数</span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="type">int</span>,sqr2(<span class="number">10</span>)&gt; mylist1;<span class="comment">//不可以，因为sqr2不是constexpr函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原生字符串字面值"><a href="#原生字符串字面值" class="headerlink" title="原生字符串字面值"></a>原生字符串字面值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">R&quot;(hello,\n,world)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出结果：hello,\n,world</span></span><br><span class="line">    <span class="comment">//R:代表原字符串是什么，输出结果就是什么，括号中是输出的字符串</span></span><br><span class="line">    <span class="comment">//可以把字符串保存在string里</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">R&quot;(hello\4\r</span></span><br><span class="line"><span class="string">    adc,noaojfa</span></span><br><span class="line"><span class="string">    hello\n)&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hello\4\r</span></span><br><span class="line"><span class="comment">    adc,noaojfa</span></span><br><span class="line"><span class="comment">    hello\n</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的改进"><a href="#类的改进" class="headerlink" title="类的改进"></a>类的改进</h2><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A(<span class="type">int</span> x,<span class="type">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        a = x;</span><br><span class="line">        b = y;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">#if0</span><br><span class="line">    <span class="comment">//通过参数列表给基类构造函数传参</span></span><br><span class="line">    B(<span class="type">int</span> x,<span class="type">int</span> y):A(x,y)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继承构造</span></span><br><span class="line">    using A::A;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a=  &quot;</span>&lt;&lt;a &lt;&lt;<span class="string">&quot;b=  &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有增加的成员变量</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    B <span class="title function_">obj</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span>;</span><br><span class="line">    obj.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当定义一个派生类对象时，需要通过函数参数列表给基类中的构造函数传参，但是这个函数中是没有代码实现的，很麻烦</p>
<p>C++11中实现了继承构造，代替了之前的通过函数传参的方法</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote>
<p>C++11允许派生类继承基类的构造函数，但是构造函数不是默认的才可以（默认构造函数，复制构造函数，移动构造函数不可以）</p>
<p>继承构造只能初始化基类的成员变量，不能初始化派生类的成员变量</p>
<p>如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数</p>
<p>一旦使用继承构造函数，编译器不会再为继承类生成构造函数</p>
</blockquote>
<h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//委托构造，一定要通过初始化列表方式调用其他构造</span></span><br><span class="line">    Test():Test(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Test(<span class="type">int</span> x):a(x)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    Test(<span class="type">char</span> x):b(x)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    Test(<span class="type">int</span> x,<span class="type">char</span> y):a(x),b(y)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Test obj;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承控制：final和override"><a href="#继承控制：final和override" class="headerlink" title="继承控制：final和override"></a>继承控制：final和override</h3><p>final：阻止类的进一步派生和虚函数的进一步重写</p>
<p>override：确保在派生类中声明的函数跟基类的虚函数有相同的签名,</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#if0</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">final</span>//加上<span class="keyword">final</span>，指定<span class="title">A1</span>不能派生</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>:</span>public A1<span class="comment">//err</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> final &#123;&#125;<span class="comment">//加上关键字后，变成最终版本的虚函数，不能再重写</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类重写基类的虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span>public B1&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;&#125;<span class="comment">//err，基类中的虚函数时最终版本，无法重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//这是第一个虚函数，没有重写，不能用override修饰</span></span><br><span class="line">    virtual <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>:</span>public A1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//在重写虚函数的地方，加上override，要求重写的虚函数和基类一模一样</span></span><br><span class="line">    virtual <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类默认函数的控制"><a href="#类默认函数的控制" class="headerlink" title="类默认函数的控制"></a>类默认函数的控制</h3><h4 id="default函数"><a href="#default函数" class="headerlink" title="default函数"></a>default函数</h4><p> 通过使用关键字default来控制默认构造函数的生成 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    X() =<span class="keyword">default</span>;<span class="comment">//让编译器提供一个默认的构造函数，效率比用户写的高</span></span><br><span class="line">    </span><br><span class="line">    X(<span class="type">int</span> i)</span><br><span class="line">    &#123;<span class="comment">//写了带参的构造函数，编译器不会提供无参的构造函数</span></span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//default只能修饰类中默认提供的成员函数：无参构造，拷贝构造，析构函数，赋值运算符重载</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> = <span class="keyword">default</span>;<span class="comment">//err，</span></span><br><span class="line">    X2(<span class="type">int</span> a) = <span class="keyword">default</span>;<span class="comment">//err,二者都不是默认提供的成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//default除了可以写在类内，还可以写在类外</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    X3();<span class="comment">//声明</span></span><br><span class="line">    </span><br><span class="line">    X3(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">X3::X3() = <span class="keyword">default</span>;<span class="comment">//default可以放在类的外部</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    X obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注</p>
<ul>
<li>default函数仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。</li>
<li>default函数既可以在类内声明类外定义，也可以在类内直接定义。</li>
</ul>
<h4 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h4><p> deleted 函数。程序员只需在函数声明后加上“&#x3D;delete;”，就可将该函数禁用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    X()&#123;&#125;<span class="comment">//普通无参</span></span><br><span class="line">    <span class="comment">//X(const X &amp;)&#123;&#125;//拷贝构造</span></span><br><span class="line">    X(<span class="type">const</span> X &amp;) = delete;<span class="comment">//拷贝构造,用&quot;=delete&quot;修饰，此函数被禁用</span></span><br><span class="line">    X &amp; operator=(<span class="type">const</span> X &amp;)&#123; <span class="keyword">return</span> *this;&#125;<span class="comment">//赋值运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    X obj1;<span class="comment">//普通无参</span></span><br><span class="line">    <span class="comment">//X obj2 = obj1;//拷贝构造</span></span><br><span class="line">    X obj2 = obj1;<span class="comment">//err,拷贝构造被禁用</span></span><br><span class="line">    </span><br><span class="line">    obj2 = obj1;<span class="comment">//赋值运算符重载函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>必须在函数第一次声明的时候将其声明为 deleted 函数，否则编译器会报错。</li>
<li>deleted 函数特性可以作用于类的特殊成员函数、类的非特殊成员函数、普通函数。。</li>
</ul>
<h2 id="模板的改进"><a href="#模板的改进" class="headerlink" title="模板的改进"></a>模板的改进</h2><h3 id="右尖括号-gt-改进"><a href="#右尖括号-gt-改进" class="headerlink" title="右尖括号&gt;改进"></a>右尖括号&gt;改进</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="type">int</span> i&gt; <span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//模板的尖括号里使用的是另一个模板，这就造成了两个右尖括号写在一起</span></span><br><span class="line">    <span class="comment">//在C++11之前，2个尖括号之间必须要有空格，如下例所示</span></span><br><span class="line">    Y&lt;X&lt;<span class="number">10</span>&gt; &gt; obj1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//C++11，可以将两个右尖括号写在一起</span></span><br><span class="line">    Y&lt;X&lt;<span class="number">10</span>&gt;&gt; obj1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h3><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h5 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h5><p>传统重定义一个类型用typedef</p>
<p>但是定义一个复杂类型的时候，typedef很难办到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef std::map&lt;std::string, int&gt; map_int_t;</span><br><span class="line">// ...</span><br><span class="line">typedef std::map&lt;std::string, std::string&gt; map_str_t;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<p>想要实现，看起来很繁琐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Val&gt;</span><br><span class="line">struct str_map</span><br><span class="line">&#123;</span><br><span class="line">    typedef std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">// ...</span><br><span class="line">str_map&lt;int&gt;::type map1;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<h5 id="using-1"><a href="#using-1" class="headerlink" title="using"></a>using</h5><p>用using重定义别名，这里使用新的using别名定义语法定义了std::map的模板别名str_map_t</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Val&gt;</span><br><span class="line">using str_map_t = std::map&lt;std::string, Val&gt;;</span><br><span class="line">// ...</span><br><span class="line">str_map_t&lt;int&gt; map1;</span><br></pre></td></tr></table></figure>

<h5 id="typedef和using对比"><a href="#typedef和using对比" class="headerlink" title="typedef和using对比"></a>typedef和using对比</h5><p> typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可 </p>
<p> using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型</p>
<p>但是本质上typedef和using都不是创造了新的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* C++98/03 */</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct func_t</span><br><span class="line">&#123;</span><br><span class="line">    typedef void (*type)(T, T);</span><br><span class="line">&#125;;</span><br><span class="line">// 使用 func_t 模板</span><br><span class="line">func_t&lt;int&gt;::type xx_1;</span><br><span class="line">/* C++11 */</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">using func_t = void (*)(T, T);</span><br><span class="line">// 使用 func_t 模板</span><br></pre></td></tr></table></figure>

<h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><p>在以前的C++标准中，类模板可以有默认的模板参数，但是不支持函数的默认模板参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U = int, U N = 0&gt;//类模板的模板参数必须是从右往左</span><br><span class="line">struct Foo</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;typename T = int&gt;  // error in C++98/03: default template arguments</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++11中，支持函数的默认模板参数</p>
<p>也就是说，当模板参数的类型有默认值时，函数是可以被调用的</p>
<p>函数模板的默认模板参数在使用规则上和其它默认模板参数有些不同，它没有必须写在最后的限制，而是可以根据实际调用的编译器自动推导出部分模板参数的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename R = int, typename U&gt;//函数模板的模板参数不要求必须从右往左</span><br><span class="line">R func(U val)</span><br><span class="line">&#123;</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(97);               // R=int, U=int</span><br><span class="line">    func&lt;char&gt;(97);         // R=char, U=int</span><br><span class="line">    func&lt;double, int&gt;(97);  // R=double, U=int</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U &#x3D; int；最后 func&lt;double,int&gt;(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。 </p>
<p>注：当默认模板参数和自行推导参数同时使用时，若无法推导出函数模板的类型，编译器会选择使用默认模板参数，若未设置默认值，则会报错</p>
<h2 id="C-11在函数模板和类模板中使用可变参数"><a href="#C-11在函数模板和类模板中使用可变参数" class="headerlink" title="C++11在函数模板和类模板中使用可变参数"></a>C++11在函数模板和类模板中使用可变参数</h2><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>可变参数：参数的个数和类型都是任意的。</p>
<p>我们通常将容纳多个参数的可变参数称为参数包。  借助 format 字符串，printf() 函数可以轻松判断出参数包中的参数个数和类型。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * format, ... )</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %c&quot;</span>,<span class="number">10</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %c %f&quot;</span>,<span class="number">10</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">1.23</span>);</span><br></pre></td></tr></table></figure>

<p>下面程序中，自定义了一个简单的可变参数函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="comment">//可变参数的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vair_fun</span><span class="params">(<span class="type">int</span> count, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> arg = va_arg(args, <span class="type">int</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//可变参数有 4 个，分别为 10、20、30、40</span></span><br><span class="line">    vair_fun(<span class="number">4</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个参数，一个是count，另一个是可变参数，想要使用参数包中的参数需要借助 <cstdarg> 头文件中的va_start、va_arg以及va_end这三个参数的宏</p>
<ul>
<li>va_start(args, count)：args 是 va_list 类型的变量，我们可以简单的将其视为 char * 类型。借助 count 参数，找到可变参数的起始位置并赋值给 args；</li>
<li>va_arg(args, int)：调用 va_start 找到可变参数起始位置的前提下，通过指明参数类型为 int，va_arg 就可以将可变参数中的第一个参数返回；</li>
<li>va_end(args)：不再使用 args 变量后，应及时调用 va_end 宏清理 args 变量。</li>
</ul>
<p>注意：va_end不具备自行终止的能力，需要用for循环以及count控制终止</p>
<p>使用可变参数注意事项</p>
<blockquote>
<p>1.可变参数必须作为函数的最后一个参数，且一个函数最多只能有一个可变参数</p>
<p>2.可变参数的前面至少要有一个有名参数</p>
<p>3.当可变参数中包含char类型的参数时，va_arg宏要以int类型的方式读取；当可变参数中包含short类型的参数时，va_arg宏要以double类型的方式读取</p>
</blockquote>
<p>C++ 中，可变参数仅适用于函数参数，不适用于模板参数，C++11标准中提供了实现可变参数模板的方法</p>
<h3 id="C-11可变参数模板函数"><a href="#C-11可变参数模板函数" class="headerlink" title="C++11可变参数模板函数"></a>C++11可变参数模板函数</h3><h4 id="可变参数模板函数的定义"><a href="#可变参数模板函数的定义" class="headerlink" title="可变参数模板函数的定义"></a>可变参数模板函数的定义</h4><p>可变参数模板：允许模板中包含任意数量的模板参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... T&gt;<span class="comment">//T叫模板参数包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(T...args)</span> <span class="comment">//args叫函数参数包</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//获取参数包中参数的个数</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    func&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    func&lt;<span class="type">char</span>,<span class="type">char</span>*,<span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;acfsd&#x27;</span>,<span class="number">250</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板参数中， typename（或者 class）后跟 … 就表明 T 是一个可变模板参数，它可以接收多种数据类型，又称模板参数包。vair_fun() 函数中，args 参数的类型用 T… 表示，表示 args 参数可以接收任意个参数，又称函数参数包。</p>
<p> 现在调用函数时就可以传入任意多个参数了，并且这些参数可以是不同类型的。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vair_fun();</span><br><span class="line">vair_fun(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">vair_fun(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">1.23</span>);</span><br></pre></td></tr></table></figure>

<p>我们无法直接获取参数包中的参数，只能展开参数包获取参数，不能使用数组循环展开</p>
<h4 id="参数包展开方式"><a href="#参数包展开方式" class="headerlink" title="参数包展开方式"></a>参数包展开方式</h4><h5 id="递归方式如下"><a href="#递归方式如下" class="headerlink" title="递归方式如下"></a>递归方式如下</h5><ul>
<li>给函数模板增加一个模板参数，这样就可以从接收到的参数包中分离出一个参数出来。</li>
<li>在函数模板中递归调用该函数模板，调用时传入剩下的参数包。</li>
<li>如此递归下去，每次分离出参数包中的一个参数，直到参数包中的所有参数都被取出来。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归终止函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowListArg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展开函数</span></span><br><span class="line">template&lt;class T1, class ...T2&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowListArg</span><span class="params">(T1 value, T2... last)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//打印传入的若干参数中的第一个参数</span></span><br><span class="line">    <span class="comment">//递归调用函数本身</span></span><br><span class="line">	ShowListArg(last...); <span class="comment">//将剩下参数继续向下传</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//供外部调用的函数</span></span><br><span class="line">template&lt;class ...Args&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowList</span><span class="params">(Args... args)</span></span><br><span class="line">&#123;</span><br><span class="line">	ShowListArg(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ShowList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">/*递归调用过程</span></span><br><span class="line"><span class="comment">    ShowList(2,3,4);</span></span><br><span class="line"><span class="comment">    ShowList(3,4);</span></span><br><span class="line"><span class="comment">    ShowList(4);</span></span><br><span class="line"><span class="comment">    ShowList();</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当递归调用ShowList函数模板时，如果传入的参数包中参数的个数为0，那么就会匹配到这个无参的递归终止函数，这样就结束了递归。 </p>
<p>外部调用的一直都是ShowList函数，通过这个函数模板函数自己调用内部函数，</p>
<h5 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h5><p>逗号表达式+初始化列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dispaly</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename... args&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vir_fun</span><span class="params">(args... argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//逗号表达式+初始化列表</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123; (dispaly(argv),<span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vir_fun(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逗号表达式会从左到右依次计算各个表达式，并且将最后一个表达式的值作为返回值进行返回。</li>
<li>将逗号表达式的最后一个表达式设置为一个整型值，确保逗号表达式返回的是一个整型值。</li>
<li>将处理参数包中参数的动作封装成一个函数，将该函数的调用作为逗号表达式的第一个表达式。</li>
</ul>
<p>第十三行展开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; (dispaly(<span class="number">1</span>),<span class="number">0</span>), (dispaly(<span class="string">&quot;http://www.biancheng.net&quot;</span>),<span class="number">0</span>), (dispaly(<span class="number">2.34</span>),<span class="number">0</span>) &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="可变参数模板类"><a href="#可变参数模板类" class="headerlink" title="可变参数模板类"></a>可变参数模板类</h3><h4 id="继承当时展开参数包"><a href="#继承当时展开参数包" class="headerlink" title="继承当时展开参数包"></a>继承当时展开参数包</h4><p>步骤</p>
<blockquote>
<p>1.可变参数模板声明</p>
<p>2.递归继承模板类</p>
<p>3.边界条件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.可变参数模板声明</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> ...<span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.递归继承模板类</span></span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">Head</span>,<span class="keyword">class</span> ...<span class="title">Tail</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&lt;</span>Head,Tail...&gt;:public Car&lt;Tail...&gt;</span><br><span class="line">&#123;<span class="comment">//递归继承本身</span></span><br><span class="line">public:</span><br><span class="line">    Car()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;type = &quot;</span>&lt;&lt;typeid(Head).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.边界条件</span></span><br><span class="line">template&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Car</span>&lt;</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Car&lt;<span class="type">int</span>,<span class="type">char</span> *,<span class="type">double</span>&gt;bmw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模板递归和特化方式展开参数包"><a href="#模板递归和特化方式展开参数包" class="headerlink" title="模板递归和特化方式展开参数包"></a>模板递归和特化方式展开参数包</h4><blockquote>
<p>1.变长模板声明</p>
<p>2.变长模板类定义</p>
<p>3.边界条件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.变长模板声明</span></span><br><span class="line">template&lt;<span class="type">int</span> ...last&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.变长模板类定义</span></span><br><span class="line">template&lt;<span class="type">int</span> first,<span class="type">int</span> ...last&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span>first,last...&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> val = first * Test&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.边界条件</span></span><br><span class="line">template&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Test&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&gt;::val &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h6 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h6><p>能用取址符号 &amp; 取出地址的皆为左值，剩下的都是右值。右值表示字面常量、表达式、函数的非引用返回值等。</p>
<p>而且，匿名变量一律属于右值。</p>
<h3 id="左值引用，右值引用"><a href="#左值引用，右值引用" class="headerlink" title="左值引用，右值引用"></a>左值引用，右值引用</h3><p>引用：给一个内存起一个别名，定义时必须初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp; <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//左值引用</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;<span class="comment">//ok</span></span><br><span class="line">    <span class="type">int</span> &amp;c = <span class="number">1</span>;<span class="comment">//err;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;d = a;<span class="comment">//ok</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;e = <span class="number">1</span>;<span class="comment">//ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> &amp;f = func();<span class="comment">//ok</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;g = func();<span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//const int &amp; 万能引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//右值引用</span></span><br><span class="line">    <span class="comment">//以前是10运行完内存就释放，右值引用是给10这块内存起一个别名,就可以用这个别名来用这块内存</span></span><br><span class="line">    <span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;&amp; b = func02();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> &amp;&amp; c = i+j;<span class="comment">//ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;&amp; d = k;<span class="comment">//err,把一个左值赋值给一个右值引用是不可以的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyString(<span class="type">char</span> *tmp = <span class="string">&quot;acb&quot;</span>)</span><br><span class="line">    &#123;<span class="comment">//普通构造函数</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(tmp);<span class="comment">//长度</span></span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;普通构造函数  str = &quot;</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyString(<span class="type">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;拷贝构造函数  str = &quot;</span>&lt;&lt;tmp.str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyString &amp;operator = (<span class="type">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//赋值运算符重载函数</span></span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == this)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先释放原来的内存</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        delete []str;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重新申请空间</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;赋值运算符重载函数  str = &quot;</span>&lt;&lt;tmp.str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~MyString()</span><br><span class="line">    &#123;<span class="comment">//析构函数</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;析构函数&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete []str;</span><br><span class="line">            len = <span class="number">0</span>; </span><br><span class="line">            str = nullptr;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;已操作delete&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="type">char</span> *str = nullptr;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString <span class="title function_">func</span><span class="params">()</span><span class="comment">//返回普通对象，不是引用</span></span><br><span class="line">&#123;</span><br><span class="line">    MyString <span class="title function_">obj</span><span class="params">(<span class="string">&quot;mike&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Mystring tmp = func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vs2013运行结果</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675997770566.png" alt="1675997770566"></p>
<p>运行结果分析：vs2013做了一次优化</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675997814764.png" alt="1675997814764"></p>
<p>qt运行结果</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675997888090.png" alt="1675997888090"></p>
<p>结果分析：返回的obj对象直接当做tmp</p>
<h6 id="如果都不做优化的过程分析"><a href="#如果都不做优化的过程分析" class="headerlink" title="如果都不做优化的过程分析"></a>如果都不做优化的过程分析</h6><blockquote>
<p>首先MyString obj(“mike”);调用了一次普通构造</p>
<p>然后由返回值return obj;产生了一个新对象（临时对象），调用一次拷贝构造函数</p>
<p>func（）调用完毕，obj释放，调用析构函数</p>
<p>产生的临时对象赋值给tmp，又调用了一次拷贝构造</p>
<p>临时对象使用完毕，调用析构函数，释放</p>
<p>程序调用完毕之后，tmp释放调用析构函数</p>
</blockquote>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>临时对象的维护（创建和销毁）对性能有严重影响</p>
<p>通过转移语义，临时对象中的资源能够转移其他的对象里。</p>
<h4 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h4><h5 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h5><p>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。这意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只有当用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。 </p>
<p>注：移动构造的&amp;&amp;是右值引用 </p>
<p>复制构造与移动构造</p>
<blockquote>
<p>复制构造是这样的：</p>
<p>在对象被复制后临时对象和复制构造的对象各自占有不同的同样大小的堆内存，就是一个副本。临时对象和新建对象a申请的堆内存同时存在。</p>
<p>移动构造是这样的：</p>
<p>就是让这个临时对象它原本控制的内存的空间转移给构造出来的对象，这样就相当于把它移动过去了。原本由临时对象申请的堆内存，由新建对象a接管，临时对象不再指向该堆内存。</p>
</blockquote>
<h6 id="移动构造优点"><a href="#移动构造优点" class="headerlink" title="移动构造优点"></a>移动构造优点</h6><p>移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。即提高程序的执行效率，节省内存消耗。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyString(<span class="type">char</span> *tmp = <span class="string">&quot;acb&quot;</span>)</span><br><span class="line">    &#123;<span class="comment">//普通构造函数</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(tmp);<span class="comment">//长度</span></span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;普通构造函数  str = &quot;</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyString(<span class="type">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;拷贝构造函数  str = &quot;</span>&lt;&lt;tmp.str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="comment">//参数是非const的右值引用</span></span><br><span class="line">    MyString(MyString &amp;&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        str = t.str;<span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line">        len = t.len;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原来指针置空</span></span><br><span class="line">        <span class="comment">//一定要置空，如果不置空，将导致同一块内存回收两次，程序崩溃</span></span><br><span class="line">        t.str = nullptr;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;移动构造函数&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyString &amp;operator = (<span class="type">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//赋值运算符重载函数</span></span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == this)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先释放原来的内存</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        delete []str;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重新申请空间</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;赋值运算符重载函数  str = &quot;</span>&lt;&lt;tmp.str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~MyString()</span><br><span class="line">    &#123;<span class="comment">//析构函数</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;析构函数&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete []str;</span><br><span class="line">            len = <span class="number">0</span>; </span><br><span class="line">            str = nullptr;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;已操作delete&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="type">char</span> *str = nullptr;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString <span class="title function_">func</span><span class="params">()</span><span class="comment">//返回普通对象，不是引用</span></span><br><span class="line">&#123;</span><br><span class="line">    MyString <span class="title function_">obj</span><span class="params">(<span class="string">&quot;mike&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Mystring tmp = func();</span></span><br><span class="line">    MyString &amp;&amp;tmp = func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>移动构造函数执行结果对比</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1675999454074.png" alt="1675999454074"></p>
<p>结果分析</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676015519947.png" alt="1676015519947"></p>
<h4 id="转移赋值函数"><a href="#转移赋值函数" class="headerlink" title="转移赋值函数"></a>转移赋值函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyString(<span class="type">char</span> *tmp = <span class="string">&quot;acb&quot;</span>)</span><br><span class="line">    &#123;<span class="comment">//普通构造函数</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(tmp);<span class="comment">//长度</span></span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;普通构造函数  str = &quot;</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyString(<span class="type">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;拷贝构造函数  str = &quot;</span>&lt;&lt;tmp.str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="comment">//参数是非const的右值引用</span></span><br><span class="line">    MyString(MyString &amp;&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        str = t.str;<span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line">        len = t.len;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原来指针置空</span></span><br><span class="line">        <span class="comment">//一定要置空，如果不置空，将导致同一块堆区空间回收两次，程序崩溃</span></span><br><span class="line">        t.str = nullptr;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;移动构造函数&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MyString &amp;operator = (<span class="type">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//赋值运算符重载函数</span></span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == this)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先释放原来的内存</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        delete []str;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重新申请空间</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = new <span class="type">char</span>[len+<span class="number">1</span>];<span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);<span class="comment">//拷贝内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;赋值运算符重载函数  str = &quot;</span>&lt;&lt;tmp.str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移动赋值函数</span></span><br><span class="line">    <span class="comment">//参数为非const的右值引用</span></span><br><span class="line">    MyString &amp;operator=(<span class="type">const</span> MyString &amp;&amp;tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == this)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先释放原来的内存</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        delete []str;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//无需冲洗申请堆区空间</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = tmp.str;<span class="comment">//地址赋值</span></span><br><span class="line">        tmp.str = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~MyString()</span><br><span class="line">    &#123;<span class="comment">//析构函数</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;析构函数&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete []str;</span><br><span class="line">            len = <span class="number">0</span>; </span><br><span class="line">            str = nullptr;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;已操作delete&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="type">char</span> *str = nullptr;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString <span class="title function_">func</span><span class="params">()</span><span class="comment">//返回普通对象，不是引用</span></span><br><span class="line">&#123;</span><br><span class="line">    MyString <span class="title function_">obj</span><span class="params">(<span class="string">&quot;mike&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Mystring tmp = func();</span></span><br><span class="line">    <span class="comment">//MyString &amp;&amp;tmp = func();</span></span><br><span class="line">    MyString <span class="title function_">tmp</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span>;<span class="comment">//实例化一个对象</span></span><br><span class="line">    tmp = func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正常赋值运算符重载函数执行结果</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676015704535.png" alt="1676015704535"></p>
<p>执行过程分析</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676015834401.png" alt="1676015834401"></p>
<p>移动赋值函数运行结果</p>
<p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676016293690.png" alt="1676016293690"></p>
<h3 id="标准库函数std-move"><a href="#标准库函数std-move" class="headerlink" title="标准库函数std::move"></a>标准库函数std::move</h3><p>这个函数以非常简单的方式将左值引用转换为右值引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//a为左值</span></span><br><span class="line">    <span class="type">int</span> &amp;&amp; b = a;<span class="comment">//err,左值不能绑定到右值引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> &amp;&amp; c = <span class="built_in">std</span>::move(a);<span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//std::move将一个左值转换为右值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c = &quot;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完美转发std-forward"><a href="#完美转发std-forward" class="headerlink" title="完美转发std::forward"></a>完美转发std::forward</h3><p>应用场景：需要将一组参数原封不动的传递给另一个函数</p>
<p>原封不动：左值&#x2F;右值和const&#x2F;non-const 所有这些属性和参数值都不能改变，同时而不产生额外的开销，就好像转发者不存在一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> T &amp;)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;const  T &amp;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt; <span class="type">void</span> <span class="title function_">func</span><span class="params">(T &amp;)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;T &amp;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; <span class="type">void</span> <span class="title function_">forward_val</span><span class="params">(<span class="type">const</span> T &amp;tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    func(tmp);<span class="comment">//定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; <span class="type">void</span> <span class="title function_">forward_val</span><span class="params">(T &amp;tmp)</span>;<span class="comment">// T &amp;</span></span><br><span class="line">&#123;</span><br><span class="line">    func(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a= <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;b = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要给forward_val()重载两个版本，const T &amp; ,T &amp;</span></span><br><span class="line">    forward_val(a);<span class="comment">//T &amp;</span></span><br><span class="line">    forward_val(b);<span class="comment">//const T &amp;</span></span><br><span class="line">    forward_val(<span class="number">111</span>);<span class="comment">//const T &amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数重载的次数和参数的个数是一个正比的关系，这个函数的定义次数是非常低效的</p>
<p>C++11中通过引入“完美折叠”来实现新的模板推导规则来完成完美转发</p>
<h5 id="C-11引用折叠规则"><a href="#C-11引用折叠规则" class="headerlink" title="C++11引用折叠规则"></a>C++11引用折叠规则</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676019157830.png" alt="1676019157830"></p>
<p>一旦定义中出现了左值引用，引用折叠总是优先将其折叠为左值引用，也就是有左值引用折叠后一定是左值引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> T &amp;)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;const  T &amp;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt; <span class="type">void</span> <span class="title function_">func</span><span class="params">(T &amp;)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;T &amp;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt; <span class="type">void</span> <span class="title function_">func</span><span class="params">(T &amp;&amp;)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;T &amp;&amp;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; <span class="type">void</span> <span class="title function_">forward_val</span><span class="params">(T &amp;&amp;tmp)</span>;<span class="comment">// 参数为右值引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//std::forward 保存参数的左值、右值属性</span></span><br><span class="line">    func(<span class="built_in">std</span>::forward&lt;T&gt;(tmp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a= <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;b = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要给forward_val()重载两个版本，const T &amp; ,T &amp;</span></span><br><span class="line">    forward_val(a);<span class="comment">//T &amp;</span></span><br><span class="line">    forward_val(b);<span class="comment">//const T &amp;</span></span><br><span class="line">    forward_val(<span class="number">111</span>);<span class="comment">//T &amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>在C++中 我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。 比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p> C++11 新标准增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。 </p>
<p>智能指针和普通指针的区别就是：智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好的避免忘记释放内存而导致内存泄漏的问题</p>
<h6 id="注"><a href="#注" class="headerlink" title="注"></a>注</h6><blockquote>
<p>C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。 </p>
</blockquote>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个对象只能绑定一个内存</p>
<p> 每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。 </p>
<blockquote>
<p>这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。 </p>
</blockquote>
<p> unique_ptr<T>（T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    ~Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;析构函数\n&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">up1</span><span class="params">(new <span class="type">int</span>(<span class="number">11</span>))</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放控制权，不释放堆区内存</span></span><br><span class="line">    <span class="comment">//up1把指向堆区空间的控制权给了p，up1就不再有控制权，不能再指向该堆区空间</span></span><br><span class="line">    <span class="type">int</span> * p = up1.release();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;*up1&lt;&lt;endl;//err,</span></span><br><span class="line">    </span><br><span class="line">    delete p;<span class="comment">//手动释放</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main03</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">up1</span><span class="params">(new <span class="type">int</span>(<span class="number">11</span>))</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//up1.reset();//如果是无参，作用是显示释放堆区内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有参数，先释放原来的堆区内存，重新给up1绑定一个新的堆区内容</span></span><br><span class="line">    up1.reset(new <span class="type">int</span>(<span class="number">22</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*up1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">up1</span><span class="params">(new <span class="type">int</span>(<span class="number">11</span>))</span>;<span class="comment">//创建智能指针对象</span></span><br><span class="line">    <span class="comment">//unique_ptr&lt;int&gt; up2 = up1;//禁用拷贝构造，err。   因为unique_ptr指针肚子拥有堆区空间的所有权</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把up1的使用权，转移给up2,up1不能再操作堆区空间</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; up2 = <span class="built_in">std</span>::move(up1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;*up2&quot;</span>&lt;&lt;*up2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;*up1&quot;&lt;&lt;*up1&lt;&lt;endl;//err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//智能指针指向了一个堆区的空间，堆区空间里的值是11</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">up1</span><span class="params">(new <span class="type">int</span>(<span class="number">11</span>))</span>;<span class="comment">//创建智能指针对象</span></span><br><span class="line">    <span class="comment">//用完这个对象之后不需要手动释放，指针自动释放</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;*up1&quot;</span>&lt;&lt;*up1&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//重载了operator *()</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//大括号执行完之后就执行了析构函数</span></span><br><span class="line">        <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">up2</span><span class="params">(new Test)</span>;<span class="comment">//无需释放，自动释放</span></span><br><span class="line">        <span class="comment">//认为指定释放堆区   //执行完这个置空操作就执行了析构函数</span></span><br><span class="line">        <span class="comment">//释放多次，不会出现段错误，只会执行一次</span></span><br><span class="line">        up2 = nullptr;<span class="comment">//第1种</span></span><br><span class="line">        up2 = <span class="literal">NULL</span>;<span class="comment">//第2种</span></span><br><span class="line">        up2.reset();<span class="comment">//第3种</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;1111111&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个对象可以绑定同一块内存</p>
<p> 多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sp1</span><span class="params">(new <span class="type">int</span>(<span class="number">11</span>))</span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; sp2 = sp1;<span class="comment">//拷贝构造，有两个对象绑定堆区空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num=&quot;</span>&lt;&lt;sp2.use_count()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//打印计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放sp1，只是计数器减一，堆区空间没有释放</span></span><br><span class="line">    sp1.reset();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num=&quot;</span>&lt;&lt;sp2.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*sp2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;*sp1&lt;&lt;endl;//err，sp1已经释放了和堆区空间的绑定，无法通过sp1操作堆区空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放sp2，计数器减一，当计数器的值为零，堆区空间就是释放</span></span><br><span class="line">    sp2.reset();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num=&quot;</span>&lt;&lt;sp2.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。 </p>
<h6 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h6><blockquote>
<p>1.当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。 </p>
<p> 2.weak_ptr<T> 模板类中没有重载 * 和 -&gt; 运算符，这也就意味着，weak_ptr 类型指针只能访问所指的堆内存，而无法修改它。 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">p1</span><span class="params">(new <span class="type">int</span>(<span class="number">11</span>))</span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; p2 = p1;<span class="comment">//有两个对象绑定堆区空间</span></span><br><span class="line">    </span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp = p1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num=&quot;</span>&lt;&lt;p1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num=&quot;</span>&lt;&lt;wp.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//weak_ptr虽然不和堆区空间绑定，可以通过lock函数获取shared_ptr&lt;int&gt;对象</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; p3 = wp.lock();<span class="comment">//有三个对象绑定堆区空间</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num2=&quot;</span>&lt;&lt;p1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num3=&quot;</span>&lt;&lt;wp.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p1&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;*p2&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;*p3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;*wp&lt;&lt;endl;//err,weak_ptr指针没有重载*和-&gt;，</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时计数器是0，堆区空间释放</span></span><br><span class="line">    p1.reset();</span><br><span class="line">    p2.reset();</span><br><span class="line">    p3.reset();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num2=&quot;</span>&lt;&lt;p1.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;num3=&quot;</span>&lt;&lt;wp.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//当堆区空间释放，wp.lock()获取的返回值为nullptr</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; tmp = wp.lock();</span><br><span class="line">    <span class="keyword">if</span>(tmp == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;堆区空间已经释放\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h2><p>闭包：函数是代码，状态是一组变量，将代码和一组变量捆绑，就形成了闭包。</p>
<p>闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候 ，可以访问这些变量。</p>
<h6 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h6><blockquote>
<p>闭包的状态捆绑，必须发生在运行时</p>
</blockquote>
<h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>在C++中，可调用的实体（可以调动函数的实体）主要包括：函数、函数指针、函数引用、可以隐式转换为函数指定的对象，或者实现了operator() 的对象</p>
<p>C++11中，新增加了一个std::function类模板，对C++中的可用实体进行了封装</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.普通函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;__func__&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.类中静态函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> <span class="title function_">test_func</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;__func__&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;) -&gt;:&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.类中仿函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;__func__&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;) -&gt;:&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.绑定普通函数</span></span><br><span class="line">    <span class="comment">//function&lt;绑定函数的返回值(绑定函数的参数)&gt; 对象名 = 函数地址;</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; f1 = func;<span class="comment">//此时f1是一个指针，指向调用函数的地址</span></span><br><span class="line">    f1();<span class="comment">//等价与func（）</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.绑定类中的静态函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f2 = Test::test_func;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f2(<span class="number">10</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.绑定类中的仿函数，绑定对象,仿函数调用obj（）</span></span><br><span class="line">    MyFunction obj;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f3 = obj;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f3(<span class="number">22</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::function对象最大的用处就是在实现函数回调，类似于函数指针</p>
<h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h4><p>是一种机制，可以预先把指定可调用实体的某些参数绑定到己有的变量，产生一个新的可调用实体，这种机制在回调函数的使用过程中也颇为有用。</p>
<p>C++11中的std::bind，绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一个参数是绑定的函数的实体，接下来是绑定的函数的 参数</span></span><br><span class="line">    bind(func,<span class="number">11</span>,<span class="number">22</span>)();<span class="comment">//输出11 ，22</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//std::placeholders::_1,函数调用时，被第一个参数替换</span></span><br><span class="line">    <span class="comment">//std::placeholders::_2,函数调用时，被第二个参数替换</span></span><br><span class="line">    <span class="comment">//输出11 ，22</span></span><br><span class="line">    bind(func,<span class="built_in">std</span>::placeholders::_1,<span class="built_in">std</span>::placeholders::_2)(<span class="number">11</span>,<span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line">    using namespace <span class="built_in">std</span>::placeholders;</span><br><span class="line">    bind(func,<span class="number">11</span>,_1)(<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>);<span class="comment">//输出11 ，22。后面的33,44没有作用</span></span><br><span class="line">    </span><br><span class="line">    bind(func,_2,_1)(<span class="number">11</span>,<span class="number">22</span>);<span class="comment">//输出22,11</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bind(func,_2,22)(11);//err,没有第二个参数</span></span><br><span class="line">    bind(func,_2,<span class="number">22</span>)(<span class="number">11</span>,<span class="number">0</span>);<span class="comment">//0 22</span></span><br><span class="line">    bind(func,_3,<span class="number">22</span>)(<span class="number">11</span>,<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//3 22</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bind和function配合使用"><a href="#bind和function配合使用" class="headerlink" title="bind和function配合使用"></a>bind和function配合使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">    &#123;<span class="comment">//成员函数</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a;<span class="comment">//成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Test obj;<span class="comment">//创建对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定成员函数</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f1 = bind(&amp;Test::func,&amp;obj,_1,_2);</span><br><span class="line">    f1(<span class="number">11</span>,<span class="number">22</span>);<span class="comment">//obj.func(11,22)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定成员变量</span></span><br><span class="line">    function&lt;<span class="type">int</span> &amp;()&gt; f2 = bind(&amp;Test::a,&amp;obj);</span><br><span class="line">    f2 = <span class="number">111</span>;<span class="comment">//obj.a = 111</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;obj.a = &quot;</span>&lt;&lt;obj.a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><h4 id="lambda-基础使用"><a href="#lambda-基础使用" class="headerlink" title="lambda 基础使用"></a>lambda 基础使用</h4><p>定义一个lambda匿名函数</p>
<blockquote>
<p>[外部变量访问方式说明符] (参数) mutable noexcept&#x2F;throw() -&gt; 返回值类型<br>{<br>  函数体;<br>}; </p>
</blockquote>
<ol>
<li>[外部变量方位方式说明符]<br>[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</li>
</ol>
<blockquote>
<p>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。 </p>
</blockquote>
<ol start="2">
<li><p>(参数)<br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略； </p>
</li>
<li><p>mutable<br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
</li>
</ol>
<blockquote>
<p>注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量； </p>
</blockquote>
<ol start="4">
<li><p>noexcept&#x2F;throw()<br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。 </p>
</li>
<li><p>-&gt; 返回值类型<br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt; 返回值类型</code>。</p>
</li>
<li><p>函数体<br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
</li>
</ol>
<h5 id="一个最简单的-lambda-匿名函数："><a href="#一个最简单的-lambda-匿名函数：" class="headerlink" title="一个最简单的 lambda 匿名函数："></a>一个最简单的 lambda 匿名函数：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h5><p><img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\1676036165671.png" alt="1676036165671"></p>
<blockquote>
<p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [&#x3D;，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//err,[]为空，没有捕获任何变量</span></span><br><span class="line">        <span class="comment">//auto f1 = []()&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> f1 = [=]()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> f2 = [&amp;]()&#123;<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//捕获类成员变量，全局变量,不能捕获局部变量</span></span><br><span class="line">        <span class="keyword">auto</span> f3 = [this]()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//err</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f1 = []()&#123;&#125;;</span><br><span class="line">    <span class="comment">//a,b以值传递方式</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = [a,b]()&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> f3 = [a,b](<span class="type">int</span> x,<span class="type">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;x&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;y&quot;</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f3(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//方括号用来捕获外部变量，小括号中才是传入的参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以值传递方式传给lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = [=]&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以引用方式捕获外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = [&amp;]&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a以值传递，其他外部变量以引用方式传递</span></span><br><span class="line">    <span class="keyword">auto</span> f6 = [&amp;,a]&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a以引用传递，其他外部变量以值传递</span></span><br><span class="line">    <span class="keyword">auto</span> f7 = [=,&amp;a]&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认情况下，lambda函数，以const修饰函数体，值传递无法修改，想修改加mutable</span></span><br><span class="line">    <span class="keyword">auto</span> f8 = [=]() mutable</span><br><span class="line">    &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以值拷贝和引用捕获参数的区别"><a href="#以值拷贝和引用捕获参数的区别" class="headerlink" title="以值拷贝和引用捕获参数的区别"></a>以值拷贝和引用捕获参数的区别</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> f2 = [&amp;]()</span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">111</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f2();<span class="comment">//111</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//111</span></span><br><span class="line">    <span class="comment">//以引用传递可以改变外部变量的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a  = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//lambda表达式，新建一个变量，外部变量给这个变量复制一份，值传递</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = [=]() mutable</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">111</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f1();<span class="comment">//111</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//10</span></span><br><span class="line">    </span><br><span class="line">    a = <span class="number">222</span>;</span><br><span class="line">    f1();<span class="comment">//111,以值传递进去，就是一个临时变量，就和外部没关系了</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lambda表达式和仿函数的联系"><a href="#lambda表达式和仿函数的联系" class="headerlink" title="lambda表达式和仿函数的联系"></a>lambda表达式和仿函数的联系</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyFunction(<span class="type">int</span> i): r(i)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//仿函数，重载operator()</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> tmp)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tmp+r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//仿函数的调用</span></span><br><span class="line">    MyFunction <span class="title function_">obj</span><span class="params">(tmp)</span>;<span class="comment">//调用构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用仿函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;result1=&quot;</span>&lt;&lt;obj(<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//11</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//仿函数是编译期实现lambda表达式的一种方式</span></span><br><span class="line">    <span class="comment">//lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> f = [tmp] (<span class="type">int</span> t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tmp+t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;result2=&quot;</span>&lt;&lt;f(<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//11</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lambda类型"><a href="#lambda类型" class="headerlink" title="lambda类型"></a>lambda类型</h4><p>lambda表达式的类型在C++11中被称为：闭包类型</p>
<p>每一个lambda表达式会产生一个临时对象（右值）。严格的讲，lambda函数并非函数指针</p>
<h5 id="lambda表达式转换成函数指针"><a href="#lambda表达式转换成函数指针" class="headerlink" title="lambda表达式转换成函数指针"></a>lambda表达式转换成函数指针</h5><p>前提是lambda表达式没有捕获任何变量，且函数指针的函数原型，必须跟lambda函数有着相同的调用方式</p>
<h4 id="lambda优势"><a href="#lambda优势" class="headerlink" title="lambda优势"></a>lambda优势</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//std::for_each</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; largeNums;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tmp = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> &amp;n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            largeNums.push_back(n);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums.push_back(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//lambda表达式</span></span><br><span class="line">    <span class="comment">//优势：可以直接写匿名函数的代码；不需要通过回调的方式看函数中的实现代码</span></span><br><span class="line">    for_each(nums.begin(),nums.end(),</span><br><span class="line">            [&amp;](<span class="type">int</span> &amp;n)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span>(n&gt;tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                largeNums.push_back(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    for_each(nums.begin(),nums.end(),</span><br><span class="line">            [](<span class="type">int</span> &amp;n)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main02</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums.push_back(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用回调函数的方式</span></span><br><span class="line">    for_each(nums.begin(),nums.end(),func);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(auto ite = nums.begin(); ite != nums.end(); ite++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        func(*ite);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ite = largeNums.begin(); ite != largeNums.end(); ite ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*ite&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums.push_back(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.传统操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ite = nums.begin(); ite != nums.end(); ite++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*ite &gt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            largeNums.push_back(*ite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ite = largeNums.begin(); ite != largeNums.end(); ite ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*ite&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
































      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/">C++11新特性</a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage"></a></p>
        <p><span>Created:</span>2023-02-11, 16:03:53</p>
        <p><span>Updated:</span>2023-02-11, 16:03:15</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/" title="C++11新特性">http://example.com/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/</a>
            <span class="copy-path" data-clipboard-text="From http://example.com/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/　　By " title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/">
                    数据结构笔记
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFC-11"><span class="toc-number">1.</span> <span class="toc-text">一、什么是C++11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IDE"><span class="toc-number">1.1.</span> <span class="toc-text">IDE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">2.</span> <span class="toc-text">二、类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">2.1.</span> <span class="toc-text">auto</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8C%E4%B8%AD"><span class="toc-number">2.1.1.</span> <span class="toc-text">在C中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8C-11%E4%B8%AD"><span class="toc-number">2.1.2.</span> <span class="toc-text">在C++11中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">auto高级用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">auto易错点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">2.2.</span> <span class="toc-text">decltype</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-number">2.2.1.</span> <span class="toc-text">decltype推导规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">类的构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#make-tuple-%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">make_tuple()函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tuple%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">tuple常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%86%85%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.1.</span> <span class="toc-text">类内成员初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84"><span class="toc-number">2.3.3.</span> <span class="toc-text">C中的类型收窄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B2%E6%AD%A2%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84"><span class="toc-number">2.3.4.</span> <span class="toc-text">列表初始化防止类型收窄</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.4.</span> <span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="toc-number">2.5.</span> <span class="toc-text">静态断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noexcept%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.6.</span> <span class="toc-text">noexcept修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nullptr"><span class="toc-number">2.7.</span> <span class="toc-text">nullptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.8.</span> <span class="toc-text">强类型枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%9E%9A%E4%B8%BE%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">2.8.1.</span> <span class="toc-text">传统枚举局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE-1"><span class="toc-number">2.8.2.</span> <span class="toc-text">强类型枚举</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88vs2013-%E4%B8%8D%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">常量表达式（vs2013 不支持）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr%E5%87%BD%E6%95%B0%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%9A"><span class="toc-number">2.9.1.</span> <span class="toc-text">constexpr函数的限制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E6%98%AF%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.9.2.</span> <span class="toc-text">类中成员是常量表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.3.</span> <span class="toc-text">constexpr和const的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">2.10.</span> <span class="toc-text">原生字符串字面值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">3.</span> <span class="toc-text">类的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-number">3.1.</span> <span class="toc-text">继承构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"><span class="toc-number">3.2.</span> <span class="toc-text">委托构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A7%E5%88%B6%EF%BC%9Afinal%E5%92%8Coverride"><span class="toc-number">3.3.</span> <span class="toc-text">继承控制：final和override</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">3.3.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#override"><span class="toc-number">3.3.2.</span> <span class="toc-text">override</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">类默认函数的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#default%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">default函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.2.</span> <span class="toc-text">delete函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">4.</span> <span class="toc-text">模板的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7-gt-%E6%94%B9%E8%BF%9B"><span class="toc-number">4.1.</span> <span class="toc-text">右尖括号&gt;改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">4.2.</span> <span class="toc-text">模板的别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using"><span class="toc-number">4.3.</span> <span class="toc-text">using</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#typedef"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#using-1"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">using</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#typedef%E5%92%8Cusing%E5%AF%B9%E6%AF%94"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">typedef和using对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">函数模板的默认模板参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E5%9C%A8%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">C++11在函数模板和类模板中使用可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C"><span class="toc-number">5.0.1.</span> <span class="toc-text">C++</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">C++11可变参数模板函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">可变参数模板函数的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%85%E5%B1%95%E5%BC%80%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">参数包展开方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%A6%82%E4%B8%8B"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">递归方式如下</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">非递归方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">可变参数模板类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%BD%93%E6%97%B6%E5%B1%95%E5%BC%80%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-number">5.2.1.</span> <span class="toc-text">继承当时展开参数包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%80%92%E5%BD%92%E5%92%8C%E7%89%B9%E5%8C%96%E6%96%B9%E5%BC%8F%E5%B1%95%E5%BC%80%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-number">5.2.2.</span> <span class="toc-text">模板递归和特化方式展开参数包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC"><span class="toc-number">6.0.0.0.1.</span> <span class="toc-text">左值右值</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">左值引用，右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">7.</span> <span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%83%BD%E4%B8%8D%E5%81%9A%E4%BC%98%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">7.0.0.0.1.</span> <span class="toc-text">如果都不做优化的过程分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">移动语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">转移构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E4%BC%98%E7%82%B9"><span class="toc-number">7.1.1.1.1.</span> <span class="toc-text">移动构造优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.2.</span> <span class="toc-text">转移赋值函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0std-move"><span class="toc-number">7.2.</span> <span class="toc-text">标准库函数std::move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91std-forward"><span class="toc-number">7.3.</span> <span class="toc-text">完美转发std::forward</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C-11%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E8%A7%84%E5%88%99"><span class="toc-number">7.3.0.1.</span> <span class="toc-text">C++11引用折叠规则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8"><span class="toc-number">8.0.0.0.1.</span> <span class="toc-text">注</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">8.1.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">8.2.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">8.3.</span> <span class="toc-text">weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8-1"><span class="toc-number">8.3.0.0.1.</span> <span class="toc-text">注</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.</span> <span class="toc-text">闭包的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8-2"><span class="toc-number">9.0.0.0.1.</span> <span class="toc-text">注</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-bind%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-number">9.1.</span> <span class="toc-text">std::bind绑定器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-function"><span class="toc-number">9.1.1.</span> <span class="toc-text">std::function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-bind"><span class="toc-number">9.1.2.</span> <span class="toc-text">std::bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind%E5%92%8Cfunction%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">9.1.3.</span> <span class="toc-text">bind和function配合使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">9.2.1.</span> <span class="toc-text">lambda 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-lambda-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">一个最简单的 lambda 匿名函数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">lambda匿名函数中的[外部变量]</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%80%BC%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.2.</span> <span class="toc-text">以值拷贝和引用捕获参数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">9.2.3.</span> <span class="toc-text">lambda表达式和仿函数的联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.2.4.</span> <span class="toc-text">lambda类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%88%90%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">9.2.4.1.</span> <span class="toc-text">lambda表达式转换成函数指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E4%BC%98%E5%8A%BF"><span class="toc-number">9.2.5.</span> <span class="toc-text">lambda优势</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide"  title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"C++11新特性　| 蔡胖子　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="Back to Homepage"><i class="fa fa-home"></i></a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/" title="Next: 数据结构笔记">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/02/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/">C++11新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B6%E6%AE%B5_1/">数据结构笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/31/hexo%E4%BD%BF%E7%94%A8/">hexo使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/31/%E5%B9%B3%E6%B7%A1%E7%9A%84%E8%A5%BF%E7%93%9C/">平淡的西瓜</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/31/C++%E7%AC%94%E8%AE%B0/">C++笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/26/hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2023 蔡胖子
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>